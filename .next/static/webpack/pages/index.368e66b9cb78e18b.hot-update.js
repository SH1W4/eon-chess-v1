"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/shared/engine/ChessEngineBase.ts":
/*!**********************************************!*\
  !*** ./src/shared/engine/ChessEngineBase.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChessEngineBase\": function() { return /* binding */ ChessEngineBase; }\n/* harmony export */ });\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var _constants_game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/game */ \"./src/shared/constants/game.ts\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Implementação base do motor de xadrez.\n * \n * Esta classe fornece a funcionalidade central para um motor de xadrez,\n * incluindo gerenciamento de estado do jogo, validação de movimentos,\n * avaliação de posição e eventos do jogo.\n * \n * @implements {ChessEngine}\n */ class ChessEngineBase {\n    // Estado do jogo\n    /**\n   * Obtém a representação atual do tabuleiro.\n   * \n   * @returns Uma matriz 8x8 representando o tabuleiro, onde cada elemento\n   * é uma peça de xadrez ou null para casas vazias.\n   */ getBoard() {\n        const board = this.game.board();\n        return board.map((row)=>row.map((square)=>square ? {\n                    type: square.type,\n                    color: square.color === \"w\" ? \"white\" : \"black\"\n                } : null));\n    }\n    /**\n   * Obtém a posição atual em notação FEN.\n   * \n   * @returns String FEN representando o estado atual do jogo\n   */ getFEN() {\n        return this.game.fen();\n    }\n    /**\n   * Define uma nova posição para o jogo usando notação FEN.\n   * \n   * @param fen - String FEN representando a nova posição\n   * @throws {Error} Se a string FEN for inválida\n   * @emits {POSITION_CHANGED} Quando a posição é alterada com sucesso\n   */ setFEN(fen) {\n        try {\n            // Na nova versão do chess.js, load() já valida o FEN\n            this.game.load(fen);\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen\n            });\n        } catch (e) {\n            throw new Error(\"Invalid FEN string\");\n        }\n    }\n    // Movimentos\n    /**\n   * Obtém todos os movimentos legais possíveis para uma peça em uma determinada posição.\n   * \n   * @param position - Posição da peça no tabuleiro\n   * @returns Lista de movimentos legais possíveis\n   */ getPossibleMoves(position) {\n        try {\n            const moves = this.game.moves({\n                square: this.positionToSquare(position),\n                verbose: true\n            });\n            return moves.map((move)=>({\n                    from: this.squareToPosition(move.from),\n                    to: this.squareToPosition(move.to),\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                }));\n        } catch (e) {\n            // Se houver erro na geração de movimentos, retorna lista vazia\n            return [];\n        }\n    }\n    /**\n   * Executa um movimento no tabuleiro.\n   * \n   * @param from - Posição inicial da peça\n   * @param to - Posição final da peça\n   * @returns true se o movimento foi executado com sucesso, false caso contrário\n   * @emits {MOVE_MADE} Quando um movimento é realizado com sucesso\n   * @emits {CHECK} Quando o movimento resulta em xeque\n   * @emits {GAME_OVER} Quando o movimento resulta em fim de jogo\n   */ makeMove(from, to) {\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\" // Auto-promove para rainha por padrão\n            });\n            if (move) {\n                const chessMove = {\n                    from,\n                    to,\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                };\n                this.emitEvent({\n                    type: \"MOVE_MADE\",\n                    move: chessMove\n                });\n                if (this.isCheck()) {\n                    this.emitEvent({\n                        type: \"CHECK\",\n                        kingPosition: this.findKing(this.getCurrentPlayer())\n                    });\n                }\n                if (this.isGameOver()) {\n                    let result = \"draw\";\n                    if (this.isCheckmate()) {\n                        result = this.getCurrentPlayer() === \"white\" ? \"black\" : \"white\";\n                    }\n                    this.emitEvent({\n                        type: \"GAME_OVER\",\n                        result\n                    });\n                }\n                return true;\n            }\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n   * Desfaz o último movimento realizado.\n   * \n   * @returns true se havia um movimento para desfazer, false caso contrário\n   * @emits {POSITION_CHANGED} Quando o movimento é desfeito com sucesso\n   */ undoLastMove() {\n        const move = this.game.undo();\n        if (move) {\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen: this.getFEN()\n            });\n            return true;\n        }\n        return false;\n    }\n    // Estado do jogo\n    /**\n   * Verifica se o jogador atual está em xeque.\n   * \n   * @returns true se o jogador atual está em xeque, false caso contrário\n   */ isCheck() {\n        return this.game.isCheck();\n    }\n    /**\n   * Verifica se o jogador atual está em xeque-mate.\n   * \n   * @returns true se o jogador atual está em xeque-mate, false caso contrário\n   */ isCheckmate() {\n        return this.game.isCheckmate();\n    }\n    /**\n   * Verifica se o jogo está empatado.\n   * \n   * @returns true se o jogo está empatado, false caso contrário\n   */ isDraw() {\n        return this.game.isDraw();\n    }\n    /**\n   * Verifica se o jogo terminou (xeque-mate ou empate).\n   * \n   * @returns true se o jogo terminou, false caso contrário\n   */ isGameOver() {\n        return this.game.isGameOver();\n    }\n    /**\n   * Obtém o jogador atual.\n   * \n   * @returns 'white' para as brancas, 'black' para as pretas\n   */ getCurrentPlayer() {\n        const turn = this.game.turn();\n        return turn === \"w\" ? \"white\" : \"black\";\n    }\n    // Avaliação e análise\n    /**\n   * Avalia a posição atual do jogo.\n   * \n   * Esta função considera diversos fatores para avaliar a posição:\n   * - Material: Valor das peças presentes no tabuleiro\n   * - Posição: Qualidade do posicionamento das peças\n   * - Mobilidade: Quantidade de movimentos disponíveis\n   * - Segurança do Rei: Avaliação da proteção do rei\n   * - Estrutura de Peões: Qualidade da estrutura de peões\n   * \n   * @returns Um número que representa a avaliação da posição.\n   * Valores positivos favorecem as brancas, negativos favorecem as pretas.\n   */ evaluatePosition() {\n        // Implementação básica de avaliação\n        const weights = this.options.evaluationParameters || {\n            materialWeight: 1,\n            positionWeight: 0.1,\n            mobilityWeight: 0.1,\n            kingSafetyWeight: 0.2,\n            pawnStructureWeight: 0.1\n        };\n        let score = 0;\n        // Material\n        score += this.evaluateMaterial() * weights.materialWeight;\n        // Posição das peças\n        score += this.evaluatePiecePositions() * weights.positionWeight;\n        // Mobilidade\n        score += this.evaluateMobility() * weights.mobilityWeight;\n        // Segurança do rei\n        score += this.evaluateKingSafety() * weights.kingSafetyWeight;\n        // Estrutura de peões\n        score += this.evaluatePawnStructure() * weights.pawnStructureWeight;\n        return score;\n    }\n    evaluatePiecePositions() {\n        // Simple piece-square tables evaluation\n        const pieceSquareValues = {\n            p: [\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50\n                ],\n                [\n                    10,\n                    10,\n                    20,\n                    30,\n                    30,\n                    20,\n                    10,\n                    10\n                ],\n                [\n                    5,\n                    5,\n                    10,\n                    25,\n                    25,\n                    10,\n                    5,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    20,\n                    20,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    5,\n                    -5,\n                    -10,\n                    0,\n                    0,\n                    -10,\n                    -5,\n                    5\n                ],\n                [\n                    5,\n                    10,\n                    10,\n                    -20,\n                    -20,\n                    10,\n                    10,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            n: [\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -30,\n                    0,\n                    10,\n                    15,\n                    15,\n                    10,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    15,\n                    20,\n                    20,\n                    15,\n                    5,\n                    -30\n                ],\n                [\n                    -30,\n                    0,\n                    15,\n                    20,\n                    20,\n                    15,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    10,\n                    15,\n                    15,\n                    10,\n                    5,\n                    -30\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    5,\n                    5,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ]\n            ],\n            b: [\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ],\n                [\n                    -10,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    5,\n                    10,\n                    10,\n                    5,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    5,\n                    10,\n                    10,\n                    5,\n                    5,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    10,\n                    10,\n                    10,\n                    10,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    0,\n                    0,\n                    0,\n                    0,\n                    5,\n                    -10\n                ],\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ]\n            ]\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const pieceTable = pieceSquareValues[piece.type];\n                    if (pieceTable) {\n                        const positionValue = pieceTable[piece.color === \"w\" ? row : 7 - row][col];\n                        score += piece.color === \"w\" ? positionValue : -positionValue;\n                    }\n                }\n            }\n        }\n        return score;\n    }\n    /**\n   * Encontra o melhor movimento possível para o jogador atual.\n   * \n   * @param depth - Profundidade máxima de busca na árvore de movimentos\n   * @returns O melhor movimento encontrado, ou null se nenhum movimento for possível\n   * @todo Implementar algoritmo minimax com poda alpha-beta\n   */ getBestMove(depth) {\n        // TODO: Implementar busca minimax com poda alpha-beta\n        return null;\n    }\n    /**\n   * Obtém o histórico completo de movimentos do jogo.\n   * \n   * @returns Lista de movimentos realizados desde o início do jogo\n   */ getGameHistory() {\n        return this.game.history({\n            verbose: true\n        }).map((move)=>({\n                from: this.squareToPosition(move.from),\n                to: this.squareToPosition(move.to),\n                piece: {\n                    type: move.piece,\n                    color: move.color === \"w\" ? \"white\" : \"black\"\n                },\n                captured: move.captured ? {\n                    type: move.captured,\n                    color: move.color === \"w\" ? \"black\" : \"white\"\n                } : undefined,\n                promotion: move.promotion\n            }));\n    }\n    // Validação\n    /**\n   * Verifica se um movimento é válido sem executá-lo.\n   * \n   * @param from - Posição inicial da peça\n   * @param to - Posição final da peça\n   * @returns true se o movimento é legal, false caso contrário\n   */ isValidMove(from, to) {\n        // Validação básica de posição\n        if (!this.isValidPosition(from) || !this.isValidPosition(to)) {\n            return false;\n        }\n        // Verifica se a peça pertence ao jogador atual\n        const piece = this.game.board()[from.row][from.col];\n        if (!piece || piece.color !== (this.getCurrentPlayer() === \"white\" ? \"w\" : \"b\")) {\n            return false;\n        }\n        // Tenta fazer o movimento no chess.js\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\"\n            });\n            if (move) {\n                // Desfaz o movimento para manter o estado original\n                this.game.undo();\n                return true;\n            }\n        } catch (e) {\n        // Ignora erros do chess.js\n        }\n        return false;\n    }\n    /**\n   * Verifica se uma posição está dentro dos limites do tabuleiro.\n   * \n   * @param position - Posição a ser verificada\n   * @returns true se a posição é válida, false caso contrário\n   */ isValidPosition(position) {\n        return position.row >= 0 && position.row < 8 && position.col >= 0 && position.col < 8;\n    }\n    // Utilidades\n    /**\n   * Reinicia o jogo para a posição inicial.\n   * \n   * @emits {POSITION_CHANGED} Quando o tabuleiro é reiniciado\n   */ reset() {\n        this.game.reset();\n        this.positionCache.clear();\n        this.emitEvent({\n            type: \"POSITION_CHANGED\",\n            fen: this.getFEN()\n        });\n    }\n    /**\n   * Cria uma cópia independente do motor de xadrez atual.\n   * \n   * @returns Uma nova instância do motor com o mesmo estado atual\n   */ clone() {\n        const clonedEngine = new ChessEngineBase(this.options);\n        clonedEngine.setFEN(this.getFEN());\n        return clonedEngine;\n    }\n    // Métodos protegidos auxiliares\n    positionToSquare(position) {\n        const file = String.fromCharCode(\"a\".charCodeAt(0) + position.col);\n        const rank = 8 - position.row;\n        return \"\".concat(file).concat(rank);\n    }\n    squareToPosition(square) {\n        const col = square.charCodeAt(0) - \"a\".charCodeAt(0);\n        const row = 8 - parseInt(square[1]);\n        return {\n            row,\n            col\n        };\n    }\n    findKing(color) {\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece && piece.type === \"k\" && piece.color === (color === \"white\" ? \"w\" : \"b\")) {\n                    return {\n                        row,\n                        col\n                    };\n                }\n            }\n        }\n        throw new Error(\"King not found\");\n    }\n    emitEvent(event) {\n        this.eventEmitter.emit(\"engine-event\", event);\n    }\n    // Métodos de avaliação\n    evaluateMaterial() {\n        const pieceValues = {\n            p: 1,\n            n: 3,\n            b: 3,\n            r: 5,\n            q: 9,\n            k: 0\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const value = pieceValues[piece.type];\n                    score += piece.color === \"w\" ? value : -value;\n                }\n            }\n        }\n        return score;\n    }\n    evaluateMobility() {\n        const whiteMoves = this.game.moves().length;\n        // Clona o jogo para ver os movimentos do oponente\n        const tempGame = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(this.game.fen());\n        tempGame.load(this.game.fen().replace(\" w \", \" b \"));\n        const blackMoves = tempGame.moves().length;\n        return whiteMoves - blackMoves;\n    }\n    evaluateKingSafety() {\n        // TODO: Implementar avaliação de segurança do rei\n        return 0;\n    }\n    evaluatePawnStructure() {\n        // TODO: Implementar avaliação de estrutura de peões\n        return 0;\n    }\n    // Event handlers\n    on(eventName, handler) {\n        this.eventEmitter.on(eventName, handler);\n    }\n    off(eventName, handler) {\n        this.eventEmitter.off(eventName, handler);\n    }\n    /**\n   * Cria uma nova instância do motor de xadrez.\n   * \n   * @param options - Opções de configuração do motor\n   * @param options.startPosition - Posição inicial em notação FEN (opcional)\n   * @param options.evaluationParameters - Parâmetros para avaliação de posição (opcional)\n   */ constructor(options = {}){\n        this.game = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(options.startPosition || _constants_game__WEBPACK_IMPORTED_MODULE_1__.INITIAL_FEN);\n        this.options = options;\n        this.eventEmitter = new events__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();\n        this.positionCache = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUM7QUFhZTtBQUNWO0FBRXRDOzs7Ozs7OztDQVFDLEdBQ00sTUFBTUc7SUEyQlgsaUJBQWlCO0lBQ2pCOzs7OztHQUtDLEdBQ0RDLFdBQTJCO1FBQ3pCLE1BQU1DLFFBQVEsSUFBSSxDQUFDQyxJQUFJLENBQUNELEtBQUs7UUFDN0IsT0FBT0EsTUFBTUUsR0FBRyxDQUFDQyxDQUFBQSxNQUNmQSxJQUFJRCxHQUFHLENBQUNFLENBQUFBLFNBQ05BLFNBQVM7b0JBQ1BDLE1BQU1ELE9BQU9DLElBQUk7b0JBQ2pCQyxPQUFPRixPQUFPRSxLQUFLLEtBQUssTUFBTSxVQUFVLE9BQU87Z0JBQ2pELElBQUksSUFBSTtJQUdkO0lBRUE7Ozs7R0FJQyxHQUNEQyxTQUFpQjtRQUNmLE9BQU8sSUFBSSxDQUFDTixJQUFJLENBQUNPLEdBQUc7SUFDdEI7SUFFQTs7Ozs7O0dBTUMsR0FDREMsT0FBT0QsR0FBVyxFQUFRO1FBQ3hCLElBQUk7WUFDRixxREFBcUQ7WUFDckQsSUFBSSxDQUFDUCxJQUFJLENBQUNTLElBQUksQ0FBQ0Y7WUFDZixJQUFJLENBQUNHLFNBQVMsQ0FBQztnQkFDYk4sTUFBTTtnQkFDTkc7WUFDRjtRQUNGLEVBQUUsT0FBT0ksR0FBRztZQUNWLE1BQU0sSUFBSUMsTUFBTSxzQkFBc0I7UUFDeEM7SUFDRjtJQUVBLGFBQWE7SUFDYjs7Ozs7R0FLQyxHQUNEQyxpQkFBaUJDLFFBQXVCLEVBQWU7UUFDckQsSUFBSTtZQUNGLE1BQU1DLFFBQVEsSUFBSSxDQUFDZixJQUFJLENBQUNlLEtBQUssQ0FBQztnQkFDNUJaLFFBQVEsSUFBSSxDQUFDYSxnQkFBZ0IsQ0FBQ0Y7Z0JBQzlCRyxTQUFTLElBQUk7WUFDZjtZQUVBLE9BQU9GLE1BQU1kLEdBQUcsQ0FBQ2lCLENBQUFBLE9BQVM7b0JBQ3hCQyxNQUFNLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNG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TyxDQUFDLE9BQU87UUFDN0MsTUFBTUMsYUFBYUYsU0FBU3pFLEtBQUssR0FBR3dFLE1BQU07UUFFMUMsT0FBT0QsYUFBYUk7SUFDdEI7SUFFUXRDLHFCQUE2QjtRQUNuQyxrREFBa0Q7UUFDbEQsT0FBTztJQUNUO0lBRVFDLHdCQUFnQztRQUN0QyxvREFBb0Q7UUFDcEQsT0FBTztJQUNUO0lBRUEsaUJBQWlCO0lBQ2pCc0MsR0FBR0MsU0FBaUIsRUFBRUMsT0FBcUMsRUFBUTtRQUNqRSxJQUFJLENBQUNkLFlBQVksQ0FBQ1ksRUFBRSxDQUFDQyxXQUFXQztJQUNsQztJQUVBQyxJQUFJRixTQUFpQixFQUFFQyxPQUFxQyxFQUFRO1FBQ2xFLElBQUksQ0FBQ2QsWUFBWSxDQUFDZSxHQUFHLENBQUNGLFdBQVdDO0lBQ25DO0lBaGdCQTs7Ozs7O0dBTUMsR0FDREUsWUFBWXRELFVBQXlCLENBQUMsQ0FBQyxDQUFFO1FBQ3ZDLElBQUksQ0FBQ3pDLElBQUksR0FBRyxJQUFJTiwyQ0FBS0EsQ0FBQytDLFFBQVF1RCxhQUFhLElBQUlyRyx3REFBV0E7UUFDMUQsSUFBSSxDQUFDOEMsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ3NDLFlBQVksR0FBRyxJQUFJbkYsZ0RBQVlBO1FBQ3BDLElBQUksQ0FBQ3dFLGFBQWEsR0FBRyxJQUFJNkI7SUFDM0I7QUFxZkYsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHM/ZjI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzcyB9IGZyb20gJ2NoZXNzLmpzJztcbmltcG9ydCB7IFxuICBDaGVzc0VuZ2luZSwgXG4gIEVuZ2luZU9wdGlvbnMsIFxuICBFbmdpbmVBbmFseXNpcyxcbiAgRW5naW5lRXZlbnQgXG59IGZyb20gJy4uL3R5cGVzL2VuZ2luZSc7XG5pbXBvcnQgeyBcbiAgQ2hlc3NQb3NpdGlvbiwgXG4gIENoZXNzUGllY2UsIFxuICBDaGVzc01vdmUsXG4gIFBpZWNlVHlwZVxufSBmcm9tICcuLi90eXBlcy9jaGVzcyc7XG5pbXBvcnQgeyBJTklUSUFMX0ZFTiB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogSW1wbGVtZW50YcOnw6NvIGJhc2UgZG8gbW90b3IgZGUgeGFkcmV6LlxuICogXG4gKiBFc3RhIGNsYXNzZSBmb3JuZWNlIGEgZnVuY2lvbmFsaWRhZGUgY2VudHJhbCBwYXJhIHVtIG1vdG9yIGRlIHhhZHJleixcbiAqIGluY2x1aW5kbyBnZXJlbmNpYW1lbnRvIGRlIGVzdGFkbyBkbyBqb2dvLCB2YWxpZGHDp8OjbyBkZSBtb3ZpbWVudG9zLFxuICogYXZhbGlhw6fDo28gZGUgcG9zacOnw6NvIGUgZXZlbnRvcyBkbyBqb2dvLlxuICogXG4gKiBAaW1wbGVtZW50cyB7Q2hlc3NFbmdpbmV9XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVzc0VuZ2luZUJhc2UgaW1wbGVtZW50cyBDaGVzc0VuZ2luZSB7XG4gIC8qKiBJbnN0w6JuY2lhIGRvIGNoZXNzLmpzIHF1ZSBnZXJlbmNpYSBhcyByZWdyYXMgZSBlc3RhZG8gZG8gam9nbyAqL1xuICBwcm90ZWN0ZWQgZ2FtZTogQ2hlc3M7XG5cbiAgLyoqIE9ww6fDtWVzIGRlIGNvbmZpZ3VyYcOnw6NvIGRvIG1vdG9yICovXG4gIHByb3RlY3RlZCBvcHRpb25zOiBFbmdpbmVPcHRpb25zO1xuXG4gIC8qKiBFbWlzc29yIGRlIGV2ZW50b3MgcGFyYSBub3RpZmljYXIgbXVkYW7Dp2FzIG5vIGVzdGFkbyBkbyBqb2dvICovXG4gIHByb3RlY3RlZCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuICAvKiogQ2FjaGUgZGUgYW7DoWxpc2VzIGRlIHBvc2nDp8OjbyBwYXJhIG90aW1pemHDp8OjbyAqL1xuICBwcm90ZWN0ZWQgcG9zaXRpb25DYWNoZTogTWFwPHN0cmluZywgRW5naW5lQW5hbHlzaXM+O1xuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBub3ZhIGluc3TDom5jaWEgZG8gbW90b3IgZGUgeGFkcmV6LlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcMOnw7VlcyBkZSBjb25maWd1cmHDp8OjbyBkbyBtb3RvclxuICAgKiBAcGFyYW0gb3B0aW9ucy5zdGFydFBvc2l0aW9uIC0gUG9zacOnw6NvIGluaWNpYWwgZW0gbm90YcOnw6NvIEZFTiAob3BjaW9uYWwpXG4gICAqIEBwYXJhbSBvcHRpb25zLmV2YWx1YXRpb25QYXJhbWV0ZXJzIC0gUGFyw6JtZXRyb3MgcGFyYSBhdmFsaWHDp8OjbyBkZSBwb3Npw6fDo28gKG9wY2lvbmFsKVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRW5naW5lT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5nYW1lID0gbmV3IENoZXNzKG9wdGlvbnMuc3RhcnRQb3NpdGlvbiB8fCBJTklUSUFMX0ZFTik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnBvc2l0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvLyBFc3RhZG8gZG8gam9nb1xuICAvKipcbiAgICogT2J0w6ltIGEgcmVwcmVzZW50YcOnw6NvIGF0dWFsIGRvIHRhYnVsZWlyby5cbiAgICogXG4gICAqIEByZXR1cm5zIFVtYSBtYXRyaXogOHg4IHJlcHJlc2VudGFuZG8gbyB0YWJ1bGVpcm8sIG9uZGUgY2FkYSBlbGVtZW50b1xuICAgKiDDqSB1bWEgcGXDp2EgZGUgeGFkcmV6IG91IG51bGwgcGFyYSBjYXNhcyB2YXppYXMuXG4gICAqL1xuICBnZXRCb2FyZCgpOiBDaGVzc1BpZWNlW11bXSB7XG4gICAgY29uc3QgYm9hcmQgPSB0aGlzLmdhbWUuYm9hcmQoKTtcbiAgICByZXR1cm4gYm9hcmQubWFwKHJvdyA9PiBcbiAgICAgIHJvdy5tYXAoc3F1YXJlID0+IFxuICAgICAgICBzcXVhcmUgPyB7XG4gICAgICAgICAgdHlwZTogc3F1YXJlLnR5cGUgYXMgUGllY2VUeXBlLFxuICAgICAgICAgIGNvbG9yOiBzcXVhcmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICAgIH0gOiBudWxsXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gYSBwb3Npw6fDo28gYXR1YWwgZW0gbm90YcOnw6NvIEZFTi5cbiAgICogXG4gICAqIEByZXR1cm5zIFN0cmluZyBGRU4gcmVwcmVzZW50YW5kbyBvIGVzdGFkbyBhdHVhbCBkbyBqb2dvXG4gICAqL1xuICBnZXRGRU4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nYW1lLmZlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSB1bWEgbm92YSBwb3Npw6fDo28gcGFyYSBvIGpvZ28gdXNhbmRvIG5vdGHDp8OjbyBGRU4uXG4gICAqIFxuICAgKiBAcGFyYW0gZmVuIC0gU3RyaW5nIEZFTiByZXByZXNlbnRhbmRvIGEgbm92YSBwb3Npw6fDo29cbiAgICogQHRocm93cyB7RXJyb3J9IFNlIGEgc3RyaW5nIEZFTiBmb3IgaW52w6FsaWRhXG4gICAqIEBlbWl0cyB7UE9TSVRJT05fQ0hBTkdFRH0gUXVhbmRvIGEgcG9zacOnw6NvIMOpIGFsdGVyYWRhIGNvbSBzdWNlc3NvXG4gICAqL1xuICBzZXRGRU4oZmVuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgLy8gTmEgbm92YSB2ZXJzw6NvIGRvIGNoZXNzLmpzLCBsb2FkKCkgasOhIHZhbGlkYSBvIEZFTlxuICAgICAgdGhpcy5nYW1lLmxvYWQoZmVuKTtcbiAgICAgIHRoaXMuZW1pdEV2ZW50KHsgXG4gICAgICAgIHR5cGU6ICdQT1NJVElPTl9DSEFOR0VEJywgXG4gICAgICAgIGZlbiBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBGRU4gc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTW92aW1lbnRvc1xuICAvKipcbiAgICogT2J0w6ltIHRvZG9zIG9zIG1vdmltZW50b3MgbGVnYWlzIHBvc3PDrXZlaXMgcGFyYSB1bWEgcGXDp2EgZW0gdW1hIGRldGVybWluYWRhIHBvc2nDp8Ojby5cbiAgICogXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFBvc2nDp8OjbyBkYSBwZcOnYSBubyB0YWJ1bGVpcm9cbiAgICogQHJldHVybnMgTGlzdGEgZGUgbW92aW1lbnRvcyBsZWdhaXMgcG9zc8OtdmVpc1xuICAgKi9cbiAgZ2V0UG9zc2libGVNb3Zlcyhwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbik6IENoZXNzTW92ZVtdIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLmdhbWUubW92ZXMoeyBcbiAgICAgICAgc3F1YXJlOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUocG9zaXRpb24pLFxuICAgICAgICB2ZXJib3NlOiB0cnVlIFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBtb3Zlcy5tYXAobW92ZSA9PiAoe1xuICAgICAgICBmcm9tOiB0aGlzLnNxdWFyZVRvUG9zaXRpb24obW92ZS5mcm9tKSxcbiAgICAgICAgdG86IHRoaXMuc3F1YXJlVG9Qb3NpdGlvbihtb3ZlLnRvKSxcbiAgICAgICAgcGllY2U6IHtcbiAgICAgICAgICB0eXBlOiBtb3ZlLnBpZWNlIGFzIFBpZWNlVHlwZSxcbiAgICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ3doaXRlJyA6ICdibGFjaydcbiAgICAgICAgfSxcbiAgICAgICAgY2FwdHVyZWQ6IG1vdmUuY2FwdHVyZWQgPyB7XG4gICAgICAgICAgdHlwZTogbW92ZS5jYXB0dXJlZCBhcyBQaWVjZVR5cGUsXG4gICAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICdibGFjaycgOiAnd2hpdGUnXG4gICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIHByb21vdGlvbjogbW92ZS5wcm9tb3Rpb24gYXMgUGllY2VUeXBlIHwgdW5kZWZpbmVkLFxuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFNlIGhvdXZlciBlcnJvIG5hIGdlcmHDp8OjbyBkZSBtb3ZpbWVudG9zLCByZXRvcm5hIGxpc3RhIHZhemlhXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGEgdW0gbW92aW1lbnRvIG5vIHRhYnVsZWlyby5cbiAgICogXG4gICAqIEBwYXJhbSBmcm9tIC0gUG9zacOnw6NvIGluaWNpYWwgZGEgcGXDp2FcbiAgICogQHBhcmFtIHRvIC0gUG9zacOnw6NvIGZpbmFsIGRhIHBlw6dhXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBtb3ZpbWVudG8gZm9pIGV4ZWN1dGFkbyBjb20gc3VjZXNzbywgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqIEBlbWl0cyB7TU9WRV9NQURFfSBRdWFuZG8gdW0gbW92aW1lbnRvIMOpIHJlYWxpemFkbyBjb20gc3VjZXNzb1xuICAgKiBAZW1pdHMge0NIRUNLfSBRdWFuZG8gbyBtb3ZpbWVudG8gcmVzdWx0YSBlbSB4ZXF1ZVxuICAgKiBAZW1pdHMge0dBTUVfT1ZFUn0gUXVhbmRvIG8gbW92aW1lbnRvIHJlc3VsdGEgZW0gZmltIGRlIGpvZ29cbiAgICovXG4gIG1ha2VNb3ZlKGZyb206IENoZXNzUG9zaXRpb24sIHRvOiBDaGVzc1Bvc2l0aW9uKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLmdhbWUubW92ZSh7XG4gICAgICAgIGZyb206IHRoaXMucG9zaXRpb25Ub1NxdWFyZShmcm9tKSxcbiAgICAgICAgdG86IHRoaXMucG9zaXRpb25Ub1NxdWFyZSh0byksXG4gICAgICAgIHByb21vdGlvbjogJ3EnIC8vIEF1dG8tcHJvbW92ZSBwYXJhIHJhaW5oYSBwb3IgcGFkcsOjb1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIGNvbnN0IGNoZXNzTW92ZTogQ2hlc3NNb3ZlID0ge1xuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgcGllY2U6IHtcbiAgICAgICAgICAgIHR5cGU6IG1vdmUucGllY2UsXG4gICAgICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ3doaXRlJyA6ICdibGFjaydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVkOiBtb3ZlLmNhcHR1cmVkID8ge1xuICAgICAgICAgICAgdHlwZTogbW92ZS5jYXB0dXJlZCxcbiAgICAgICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnYmxhY2snIDogJ3doaXRlJ1xuICAgICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgcHJvbW90aW9uOiBtb3ZlLnByb21vdGlvbixcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVtaXRFdmVudCh7IHR5cGU6ICdNT1ZFX01BREUnLCBtb3ZlOiBjaGVzc01vdmUgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNDaGVjaygpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0RXZlbnQoeyBcbiAgICAgICAgICAgIHR5cGU6ICdDSEVDSycsXG4gICAgICAgICAgICBraW5nUG9zaXRpb246IHRoaXMuZmluZEtpbmcodGhpcy5nZXRDdXJyZW50UGxheWVyKCkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0dhbWVPdmVyKCkpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gJ2RyYXcnO1xuICAgICAgICAgIGlmICh0aGlzLmlzQ2hlY2ttYXRlKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0Q3VycmVudFBsYXllcigpID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KHsgdHlwZTogJ0dBTUVfT1ZFUicsIHJlc3VsdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzZmF6IG8gw7psdGltbyBtb3ZpbWVudG8gcmVhbGl6YWRvLlxuICAgKiBcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBoYXZpYSB1bSBtb3ZpbWVudG8gcGFyYSBkZXNmYXplciwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqIEBlbWl0cyB7UE9TSVRJT05fQ0hBTkdFRH0gUXVhbmRvIG8gbW92aW1lbnRvIMOpIGRlc2ZlaXRvIGNvbSBzdWNlc3NvXG4gICAqL1xuICB1bmRvTGFzdE1vdmUoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbW92ZSA9IHRoaXMuZ2FtZS51bmRvKCk7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgIHRoaXMuZW1pdEV2ZW50KHsgXG4gICAgICAgIHR5cGU6ICdQT1NJVElPTl9DSEFOR0VEJyxcbiAgICAgICAgZmVuOiB0aGlzLmdldEZFTigpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFc3RhZG8gZG8gam9nb1xuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyBqb2dhZG9yIGF0dWFsIGVzdMOhIGVtIHhlcXVlLlxuICAgKiBcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIGpvZ2Fkb3IgYXR1YWwgZXN0w6EgZW0geGVxdWUsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNDaGVjaygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nYW1lLmlzQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIGpvZ2Fkb3IgYXR1YWwgZXN0w6EgZW0geGVxdWUtbWF0ZS5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBqb2dhZG9yIGF0dWFsIGVzdMOhIGVtIHhlcXVlLW1hdGUsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNDaGVja21hdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0NoZWNrbWF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gam9nbyBlc3TDoSBlbXBhdGFkby5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBqb2dvIGVzdMOhIGVtcGF0YWRvLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzRHJhdygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nYW1lLmlzRHJhdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gam9nbyB0ZXJtaW5vdSAoeGVxdWUtbWF0ZSBvdSBlbXBhdGUpLlxuICAgKiBcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIGpvZ28gdGVybWlub3UsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNHYW1lT3ZlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nYW1lLmlzR2FtZU92ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gbyBqb2dhZG9yIGF0dWFsLlxuICAgKiBcbiAgICogQHJldHVybnMgJ3doaXRlJyBwYXJhIGFzIGJyYW5jYXMsICdibGFjaycgcGFyYSBhcyBwcmV0YXNcbiAgICovXG4gIGdldEN1cnJlbnRQbGF5ZXIoKTogJ3doaXRlJyB8ICdibGFjaycge1xuICAgIGNvbnN0IHR1cm4gPSB0aGlzLmdhbWUudHVybigpO1xuICAgIHJldHVybiB0dXJuID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJztcbiAgfVxuXG4gIC8vIEF2YWxpYcOnw6NvIGUgYW7DoWxpc2VcbiAgLyoqXG4gICAqIEF2YWxpYSBhIHBvc2nDp8OjbyBhdHVhbCBkbyBqb2dvLlxuICAgKiBcbiAgICogRXN0YSBmdW7Dp8OjbyBjb25zaWRlcmEgZGl2ZXJzb3MgZmF0b3JlcyBwYXJhIGF2YWxpYXIgYSBwb3Npw6fDo286XG4gICAqIC0gTWF0ZXJpYWw6IFZhbG9yIGRhcyBwZcOnYXMgcHJlc2VudGVzIG5vIHRhYnVsZWlyb1xuICAgKiAtIFBvc2nDp8OjbzogUXVhbGlkYWRlIGRvIHBvc2ljaW9uYW1lbnRvIGRhcyBwZcOnYXNcbiAgICogLSBNb2JpbGlkYWRlOiBRdWFudGlkYWRlIGRlIG1vdmltZW50b3MgZGlzcG9uw612ZWlzXG4gICAqIC0gU2VndXJhbsOnYSBkbyBSZWk6IEF2YWxpYcOnw6NvIGRhIHByb3Rlw6fDo28gZG8gcmVpXG4gICAqIC0gRXN0cnV0dXJhIGRlIFBlw7VlczogUXVhbGlkYWRlIGRhIGVzdHJ1dHVyYSBkZSBwZcO1ZXNcbiAgICogXG4gICAqIEByZXR1cm5zIFVtIG7Dum1lcm8gcXVlIHJlcHJlc2VudGEgYSBhdmFsaWHDp8OjbyBkYSBwb3Npw6fDo28uXG4gICAqIFZhbG9yZXMgcG9zaXRpdm9zIGZhdm9yZWNlbSBhcyBicmFuY2FzLCBuZWdhdGl2b3MgZmF2b3JlY2VtIGFzIHByZXRhcy5cbiAgICovXG4gIGV2YWx1YXRlUG9zaXRpb24oKTogbnVtYmVyIHtcbiAgICAvLyBJbXBsZW1lbnRhw6fDo28gYsOhc2ljYSBkZSBhdmFsaWHDp8Ojb1xuICAgIGNvbnN0IHdlaWdodHMgPSB0aGlzLm9wdGlvbnMuZXZhbHVhdGlvblBhcmFtZXRlcnMgfHwge1xuICAgICAgbWF0ZXJpYWxXZWlnaHQ6IDEsXG4gICAgICBwb3NpdGlvbldlaWdodDogMC4xLFxuICAgICAgbW9iaWxpdHlXZWlnaHQ6IDAuMSxcbiAgICAgIGtpbmdTYWZldHlXZWlnaHQ6IDAuMixcbiAgICAgIHBhd25TdHJ1Y3R1cmVXZWlnaHQ6IDAuMVxuICAgIH07XG5cbiAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgLy8gTWF0ZXJpYWxcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlTWF0ZXJpYWwoKSAqIHdlaWdodHMubWF0ZXJpYWxXZWlnaHQ7XG5cbiAgICAvLyBQb3Npw6fDo28gZGFzIHBlw6dhc1xuICAgIHNjb3JlICs9IHRoaXMuZXZhbHVhdGVQaWVjZVBvc2l0aW9ucygpICogd2VpZ2h0cy5wb3NpdGlvbldlaWdodDtcblxuICAgIC8vIE1vYmlsaWRhZGVcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlTW9iaWxpdHkoKSAqIHdlaWdodHMubW9iaWxpdHlXZWlnaHQ7XG5cbiAgICAvLyBTZWd1cmFuw6dhIGRvIHJlaVxuICAgIHNjb3JlICs9IHRoaXMuZXZhbHVhdGVLaW5nU2FmZXR5KCkgKiB3ZWlnaHRzLmtpbmdTYWZldHlXZWlnaHQ7XG5cbiAgICAvLyBFc3RydXR1cmEgZGUgcGXDtWVzXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZVBhd25TdHJ1Y3R1cmUoKSAqIHdlaWdodHMucGF3blN0cnVjdHVyZVdlaWdodDtcblxuICAgIHJldHVybiBzY29yZTtcbiAgfVxuXG4gIHByaXZhdGUgZXZhbHVhdGVQaWVjZVBvc2l0aW9ucygpOiBudW1iZXIge1xuICAgIC8vIFNpbXBsZSBwaWVjZS1zcXVhcmUgdGFibGVzIGV2YWx1YXRpb25cbiAgICBjb25zdCBwaWVjZVNxdWFyZVZhbHVlcyA9IHtcbiAgICAgIHA6IFsgLy8gUGF3bnNcbiAgICAgICAgWzAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwXSxcbiAgICAgICAgWzUwLCA1MCwgNTAsIDUwLCA1MCwgNTAsIDUwLCA1MF0sXG4gICAgICAgIFsxMCwgMTAsIDIwLCAzMCwgMzAsIDIwLCAxMCwgMTBdLFxuICAgICAgICBbNSwgIDUsIDEwLCAyNSwgMjUsIDEwLCAgNSwgIDVdLFxuICAgICAgICBbMCwgIDAsICAwLCAyMCwgMjAsICAwLCAgMCwgIDBdLFxuICAgICAgICBbNSwgLTUsLTEwLCAgMCwgIDAsLTEwLCAtNSwgIDVdLFxuICAgICAgICBbNSwgMTAsIDEwLC0yMCwtMjAsIDEwLCAxMCwgIDVdLFxuICAgICAgICBbMCwgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDBdXG4gICAgICBdLFxuICAgICAgbjogWyAvLyBLbmlnaHRzXG4gICAgICAgIFstNTAsLTQwLC0zMCwtMzAsLTMwLC0zMCwtNDAsLTUwXSxcbiAgICAgICAgWy00MCwtMjAsICAwLCAgMCwgIDAsICAwLC0yMCwtNDBdLFxuICAgICAgICBbLTMwLCAgMCwgMTAsIDE1LCAxNSwgMTAsICAwLC0zMF0sXG4gICAgICAgIFstMzAsICA1LCAxNSwgMjAsIDIwLCAxNSwgIDUsLTMwXSxcbiAgICAgICAgWy0zMCwgIDAsIDE1LCAyMCwgMjAsIDE1LCAgMCwtMzBdLFxuICAgICAgICBbLTMwLCAgNSwgMTAsIDE1LCAxNSwgMTAsICA1LC0zMF0sXG4gICAgICAgIFstNDAsLTIwLCAgMCwgIDUsICA1LCAgMCwtMjAsLTQwXSxcbiAgICAgICAgWy01MCwtNDAsLTMwLC0zMCwtMzAsLTMwLC00MCwtNTBdXG4gICAgICBdLFxuICAgICAgYjogWyAvLyBCaXNob3BzXG4gICAgICAgIFstMjAsLTEwLC0xMCwtMTAsLTEwLC0xMCwtMTAsLTIwXSxcbiAgICAgICAgWy0xMCwgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwtMTBdLFxuICAgICAgICBbLTEwLCAgMCwgIDUsIDEwLCAxMCwgIDUsICAwLC0xMF0sXG4gICAgICAgIFstMTAsICA1LCAgNSwgMTAsIDEwLCAgNSwgIDUsLTEwXSxcbiAgICAgICAgWy0xMCwgIDAsIDEwLCAxMCwgMTAsIDEwLCAgMCwtMTBdLFxuICAgICAgICBbLTEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLC0xMF0sXG4gICAgICAgIFstMTAsICA1LCAgMCwgIDAsICAwLCAgMCwgIDUsLTEwXSxcbiAgICAgICAgWy0yMCwtMTAsLTEwLC0xMCwtMTAsLTEwLC0xMCwtMjBdXG4gICAgICBdXG4gICAgfTtcblxuICAgIGxldCBzY29yZSA9IDA7XG4gICAgY29uc3QgYm9hcmQgPSB0aGlzLmdhbWUuYm9hcmQoKTtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDg7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA4OyBjb2wrKykge1xuICAgICAgICBjb25zdCBwaWVjZSA9IGJvYXJkW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKHBpZWNlKSB7XG4gICAgICAgICAgY29uc3QgcGllY2VUYWJsZSA9IHBpZWNlU3F1YXJlVmFsdWVzW3BpZWNlLnR5cGUgYXMga2V5b2YgdHlwZW9mIHBpZWNlU3F1YXJlVmFsdWVzXTtcbiAgICAgICAgICBpZiAocGllY2VUYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25WYWx1ZSA9IHBpZWNlVGFibGVbcGllY2UuY29sb3IgPT09ICd3JyA/IHJvdyA6IDcgLSByb3ddW2NvbF07XG4gICAgICAgICAgICBzY29yZSArPSBwaWVjZS5jb2xvciA9PT0gJ3cnID8gcG9zaXRpb25WYWx1ZSA6IC1wb3NpdGlvblZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY29yZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvbnRyYSBvIG1lbGhvciBtb3ZpbWVudG8gcG9zc8OtdmVsIHBhcmEgbyBqb2dhZG9yIGF0dWFsLlxuICAgKiBcbiAgICogQHBhcmFtIGRlcHRoIC0gUHJvZnVuZGlkYWRlIG3DoXhpbWEgZGUgYnVzY2EgbmEgw6Fydm9yZSBkZSBtb3ZpbWVudG9zXG4gICAqIEByZXR1cm5zIE8gbWVsaG9yIG1vdmltZW50byBlbmNvbnRyYWRvLCBvdSBudWxsIHNlIG5lbmh1bSBtb3ZpbWVudG8gZm9yIHBvc3PDrXZlbFxuICAgKiBAdG9kbyBJbXBsZW1lbnRhciBhbGdvcml0bW8gbWluaW1heCBjb20gcG9kYSBhbHBoYS1iZXRhXG4gICAqL1xuICBnZXRCZXN0TW92ZShkZXB0aDogbnVtYmVyKTogQ2hlc3NNb3ZlIHwgbnVsbCB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50YXIgYnVzY2EgbWluaW1heCBjb20gcG9kYSBhbHBoYS1iZXRhXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG8gaGlzdMOzcmljbyBjb21wbGV0byBkZSBtb3ZpbWVudG9zIGRvIGpvZ28uXG4gICAqIFxuICAgKiBAcmV0dXJucyBMaXN0YSBkZSBtb3ZpbWVudG9zIHJlYWxpemFkb3MgZGVzZGUgbyBpbsOtY2lvIGRvIGpvZ29cbiAgICovXG4gIGdldEdhbWVIaXN0b3J5KCk6IENoZXNzTW92ZVtdIHtcbiAgICByZXR1cm4gdGhpcy5nYW1lLmhpc3RvcnkoeyB2ZXJib3NlOiB0cnVlIH0pLm1hcChtb3ZlID0+ICh7XG4gICAgICBmcm9tOiB0aGlzLnNxdWFyZVRvUG9zaXRpb24obW92ZS5mcm9tKSxcbiAgICAgIHRvOiB0aGlzLnNxdWFyZVRvUG9zaXRpb24obW92ZS50byksXG4gICAgICBwaWVjZToge1xuICAgICAgICB0eXBlOiBtb3ZlLnBpZWNlLFxuICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ3doaXRlJyA6ICdibGFjaydcbiAgICAgIH0sXG4gICAgICBjYXB0dXJlZDogbW92ZS5jYXB0dXJlZCA/IHtcbiAgICAgICAgdHlwZTogbW92ZS5jYXB0dXJlZCxcbiAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICdibGFjaycgOiAnd2hpdGUnXG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgcHJvbW90aW9uOiBtb3ZlLnByb21vdGlvbixcbiAgICB9KSk7XG4gIH1cblxuICAvLyBWYWxpZGHDp8Ojb1xuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW0gbW92aW1lbnRvIMOpIHbDoWxpZG8gc2VtIGV4ZWN1dMOhLWxvLlxuICAgKiBcbiAgICogQHBhcmFtIGZyb20gLSBQb3Npw6fDo28gaW5pY2lhbCBkYSBwZcOnYVxuICAgKiBAcGFyYW0gdG8gLSBQb3Npw6fDo28gZmluYWwgZGEgcGXDp2FcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIG1vdmltZW50byDDqSBsZWdhbCwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc1ZhbGlkTW92ZShmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICAgIC8vIFZhbGlkYcOnw6NvIGLDoXNpY2EgZGUgcG9zacOnw6NvXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRQb3NpdGlvbihmcm9tKSB8fCAhdGhpcy5pc1ZhbGlkUG9zaXRpb24odG8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZpY2Egc2UgYSBwZcOnYSBwZXJ0ZW5jZSBhbyBqb2dhZG9yIGF0dWFsXG4gICAgY29uc3QgcGllY2UgPSB0aGlzLmdhbWUuYm9hcmQoKVtmcm9tLnJvd11bZnJvbS5jb2xdO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgIT09ICh0aGlzLmdldEN1cnJlbnRQbGF5ZXIoKSA9PT0gJ3doaXRlJyA/ICd3JyA6ICdiJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUZW50YSBmYXplciBvIG1vdmltZW50byBubyBjaGVzcy5qc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtb3ZlID0gdGhpcy5nYW1lLm1vdmUoe1xuICAgICAgICBmcm9tOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUoZnJvbSksXG4gICAgICAgIHRvOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUodG8pLFxuICAgICAgICBwcm9tb3Rpb246ICdxJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIC8vIERlc2ZheiBvIG1vdmltZW50byBwYXJhIG1hbnRlciBvIGVzdGFkbyBvcmlnaW5hbFxuICAgICAgICB0aGlzLmdhbWUudW5kbygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZ25vcmEgZXJyb3MgZG8gY2hlc3MuanNcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgdW1hIHBvc2nDp8OjbyBlc3TDoSBkZW50cm8gZG9zIGxpbWl0ZXMgZG8gdGFidWxlaXJvLlxuICAgKiBcbiAgICogQHBhcmFtIHBvc2l0aW9uIC0gUG9zacOnw6NvIGEgc2VyIHZlcmlmaWNhZGFcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBhIHBvc2nDp8OjbyDDqSB2w6FsaWRhLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzVmFsaWRQb3NpdGlvbihwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwb3NpdGlvbi5yb3cgPj0gMCAmJiBwb3NpdGlvbi5yb3cgPCA4ICYmXG4gICAgICAgICAgIHBvc2l0aW9uLmNvbCA+PSAwICYmIHBvc2l0aW9uLmNvbCA8IDg7XG4gIH1cblxuICAvLyBVdGlsaWRhZGVzXG4gIC8qKlxuICAgKiBSZWluaWNpYSBvIGpvZ28gcGFyYSBhIHBvc2nDp8OjbyBpbmljaWFsLlxuICAgKiBcbiAgICogQGVtaXRzIHtQT1NJVElPTl9DSEFOR0VEfSBRdWFuZG8gbyB0YWJ1bGVpcm8gw6kgcmVpbmljaWFkb1xuICAgKi9cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5nYW1lLnJlc2V0KCk7XG4gICAgdGhpcy5wb3NpdGlvbkNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5lbWl0RXZlbnQoeyBcbiAgICAgIHR5cGU6ICdQT1NJVElPTl9DSEFOR0VEJyxcbiAgICAgIGZlbjogdGhpcy5nZXRGRU4oKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyaWEgdW1hIGPDs3BpYSBpbmRlcGVuZGVudGUgZG8gbW90b3IgZGUgeGFkcmV6IGF0dWFsLlxuICAgKiBcbiAgICogQHJldHVybnMgVW1hIG5vdmEgaW5zdMOibmNpYSBkbyBtb3RvciBjb20gbyBtZXNtbyBlc3RhZG8gYXR1YWxcbiAgICovXG4gIGNsb25lKCk6IENoZXNzRW5naW5lIHtcbiAgICBjb25zdCBjbG9uZWRFbmdpbmUgPSBuZXcgQ2hlc3NFbmdpbmVCYXNlKHRoaXMub3B0aW9ucyk7XG4gICAgY2xvbmVkRW5naW5lLnNldEZFTih0aGlzLmdldEZFTigpKTtcbiAgICByZXR1cm4gY2xvbmVkRW5naW5lO1xuICB9XG5cbiAgLy8gTcOpdG9kb3MgcHJvdGVnaWRvcyBhdXhpbGlhcmVzXG4gIHByb3RlY3RlZCBwb3NpdGlvblRvU3F1YXJlKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uKTogc3RyaW5nIHtcbiAgICBjb25zdCBmaWxlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgnYScuY2hhckNvZGVBdCgwKSArIHBvc2l0aW9uLmNvbCk7XG4gICAgY29uc3QgcmFuayA9IDggLSBwb3NpdGlvbi5yb3c7XG4gICAgcmV0dXJuIGAke2ZpbGV9JHtyYW5rfWA7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3F1YXJlVG9Qb3NpdGlvbihzcXVhcmU6IHN0cmluZyk6IENoZXNzUG9zaXRpb24ge1xuICAgIGNvbnN0IGNvbCA9IHNxdWFyZS5jaGFyQ29kZUF0KDApIC0gJ2EnLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3Qgcm93ID0gOCAtIHBhcnNlSW50KHNxdWFyZVsxXSk7XG4gICAgcmV0dXJuIHsgcm93LCBjb2wgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBmaW5kS2luZyhjb2xvcjogJ3doaXRlJyB8ICdibGFjaycpOiBDaGVzc1Bvc2l0aW9uIHtcbiAgICBjb25zdCBib2FyZCA9IHRoaXMuZ2FtZS5ib2FyZCgpO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDg7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA4OyBjb2wrKykge1xuICAgICAgICBjb25zdCBwaWVjZSA9IGJvYXJkW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKHBpZWNlICYmIFxuICAgICAgICAgICAgcGllY2UudHlwZSA9PT0gJ2snICYmIFxuICAgICAgICAgICAgcGllY2UuY29sb3IgPT09IChjb2xvciA9PT0gJ3doaXRlJyA/ICd3JyA6ICdiJykpIHtcbiAgICAgICAgICByZXR1cm4geyByb3csIGNvbCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignS2luZyBub3QgZm91bmQnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBlbWl0RXZlbnQoZXZlbnQ6IEVuZ2luZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZW5naW5lLWV2ZW50JywgZXZlbnQpO1xuICB9XG5cbiAgLy8gTcOpdG9kb3MgZGUgYXZhbGlhw6fDo29cbiAgcHJpdmF0ZSBldmFsdWF0ZU1hdGVyaWFsKCk6IG51bWJlciB7XG4gICAgY29uc3QgcGllY2VWYWx1ZXMgPSB7XG4gICAgICBwOiAxLFxuICAgICAgbjogMyxcbiAgICAgIGI6IDMsXG4gICAgICByOiA1LFxuICAgICAgcTogOSxcbiAgICAgIGs6IDBcbiAgICB9O1xuXG4gICAgbGV0IHNjb3JlID0gMDtcbiAgICBjb25zdCBib2FyZCA9IHRoaXMuZ2FtZS5ib2FyZCgpO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDg7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbcm93XVtjb2xdO1xuICAgICAgICBpZiAocGllY2UpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBpZWNlVmFsdWVzW3BpZWNlLnR5cGUgYXMga2V5b2YgdHlwZW9mIHBpZWNlVmFsdWVzXTtcbiAgICAgICAgICBzY29yZSArPSBwaWVjZS5jb2xvciA9PT0gJ3cnID8gdmFsdWUgOiAtdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlTW9iaWxpdHkoKTogbnVtYmVyIHtcbiAgICBjb25zdCB3aGl0ZU1vdmVzID0gdGhpcy5nYW1lLm1vdmVzKCkubGVuZ3RoO1xuICAgIC8vIENsb25hIG8gam9nbyBwYXJhIHZlciBvcyBtb3ZpbWVudG9zIGRvIG9wb25lbnRlXG4gICAgY29uc3QgdGVtcEdhbWUgPSBuZXcgQ2hlc3ModGhpcy5nYW1lLmZlbigpKTtcbiAgICB0ZW1wR2FtZS5sb2FkKHRoaXMuZ2FtZS5mZW4oKS5yZXBsYWNlKCcgdyAnLCAnIGIgJykpO1xuICAgIGNvbnN0IGJsYWNrTW92ZXMgPSB0ZW1wR2FtZS5tb3ZlcygpLmxlbmd0aDtcbiAgICBcbiAgICByZXR1cm4gd2hpdGVNb3ZlcyAtIGJsYWNrTW92ZXM7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlS2luZ1NhZmV0eSgpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGF2YWxpYcOnw6NvIGRlIHNlZ3VyYW7Dp2EgZG8gcmVpXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlUGF3blN0cnVjdHVyZSgpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGF2YWxpYcOnw6NvIGRlIGVzdHJ1dHVyYSBkZSBwZcO1ZXNcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiAoZXZlbnQ6IEVuZ2luZUV2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogKGV2ZW50OiBFbmdpbmVFdmVudCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ2hlc3MiLCJJTklUSUFMX0ZFTiIsIkV2ZW50RW1pdHRlciIsIkNoZXNzRW5naW5lQmFzZSIsImdldEJvYXJkIiwiYm9hcmQiLCJnYW1lIiwibWFwIiwicm93Iiwic3F1YXJlIiwidHlwZSIsImNvbG9yIiwiZ2V0RkVOIiwiZmVuIiwic2V0RkVOIiwibG9hZCIsImVtaXRFdmVudCIsImUiLCJFcnJvciIsImdldFBvc3NpYmxlTW92ZXMiLCJwb3NpdGlvbiIsIm1vdmVzIiwicG9zaXRpb25Ub1NxdWFyZSIsInZlcmJvc2UiLCJtb3ZlIiwiZnJvbSIsInNxdWFyZVRvUG9zaXRpb24iLCJ0byIsInBpZWNlIiwiY2FwdHVyZWQiLCJ1bmRlZmluZWQiLCJwcm9tb3Rpb24iLCJtYWtlTW92ZSIsImNoZXNzTW92ZSIsImlzQ2hlY2siLCJraW5nUG9zaXRpb24iLCJmaW5kS2luZyIsImdldEN1cnJlbnRQbGF5ZXIiLCJpc0dhbWVPdmVyIiwicmVzdWx0IiwiaXNDaGVja21hdGUiLCJ1bmRvTGFzdE1vdmUiLCJ1bmRvIiwiaXNEcmF3IiwidHVybiIsImV2YWx1YXRlUG9zaXRpb24iLCJ3ZWlnaHRzIiwib3B0aW9ucyIsImV2YWx1YXRpb25QYXJhbWV0ZXJzIiwibWF0ZXJpYWxXZWlnaHQiLCJwb3NpdGlvbldlaWdodCIsIm1vYmlsaXR5V2VpZ2h0Iiwia2luZ1NhZmV0eVdlaWdodCIsInBhd25TdHJ1Y3R1cmVXZWlnaHQiLCJzY29yZSIsImV2YWx1YXRlTWF0ZXJpYWwiLCJldmFsdWF0ZVBpZWNlUG9zaXRpb25zIiwiZXZhbHVhdGVNb2JpbGl0eSIsImV2YWx1YXRlS2luZ1NhZmV0eSIsImV2YWx1YXRlUGF3blN0cnVjdHVyZSIsInBpZWNlU3F1YXJlVmFsdWVzIiwicCIsIm4iLCJiIiwiY29sIiwicGllY2VUYWJsZSIsInBvc2l0aW9uVmFsdWUiLCJnZXRCZXN0TW92ZSIsImRlcHRoIiwiZ2V0R2FtZUhpc3RvcnkiLCJoaXN0b3J5IiwiaXNWYWxpZE1vdmUiLCJpc1ZhbGlkUG9zaXRpb24iLCJyZXNldCIsInBvc2l0aW9uQ2FjaGUiLCJjbGVhciIsImNsb25lIiwiY2xvbmVkRW5naW5lIiwiZmlsZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJyYW5rIiwicGFyc2VJbnQiLCJldmVudCIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJwaWVjZVZhbHVlcyIsInIiLCJxIiwiayIsInZhbHVlIiwid2hpdGVNb3ZlcyIsImxlbmd0aCIsInRlbXBHYW1lIiwicmVwbGFjZSIsImJsYWNrTW92ZXMiLCJvbiIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJvZmYiLCJjb25zdHJ1Y3RvciIsInN0YXJ0UG9zaXRpb24iLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shared/engine/ChessEngineBase.ts\n"));

/***/ })

});