"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/shared/engine/ChessEngineBase.ts":
/*!**********************************************!*\
  !*** ./src/shared/engine/ChessEngineBase.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChessEngineBase\": function() { return /* binding */ ChessEngineBase; }\n/* harmony export */ });\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var _monitoring_ArquimaxMonitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./monitoring/ArquimaxMonitor */ \"./src/shared/engine/monitoring/ArquimaxMonitor.ts\");\n/* harmony import */ var _constants_game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/game */ \"./src/shared/constants/game.ts\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\n * Implementação base do motor de xadrez.\n * \n * Esta classe fornece a funcionalidade central para um motor de xadrez,\n * incluindo gerenciamento de estado do jogo, validação de movimentos,\n * avaliação de posição e eventos do jogo.\n * \n * @implements {ChessEngine}\n */ class ChessEngineBase {\n    // Estado do jogo\n    /**\n   * Obtém a representação atual do tabuleiro.\n   * \n   * @returns Uma matriz 8x8 representando o tabuleiro, onde cada elemento\n   * é uma peça de xadrez ou null para casas vazias.\n   */ getBoard() {\n        const board = this.game.board();\n        return board.map((row)=>row.map((square)=>square ? {\n                    type: square.type,\n                    color: square.color === \"w\" ? \"white\" : \"black\"\n                } : null));\n    }\n    /**\n   * Obtém a posição atual em notação FEN.\n   * \n   * @returns String FEN representando o estado atual do jogo\n   */ getFEN() {\n        return this.game.fen();\n    }\n    /**\n   * Define uma nova posição para o jogo usando notação FEN.\n   * \n   * @param fen - String FEN representando a nova posição\n   * @throws {Error} Se a string FEN for inválida\n   * @emits {POSITION_CHANGED} Quando a posição é alterada com sucesso\n   */ setFEN(fen) {\n        try {\n            // Na nova versão do chess.js, load() já valida o FEN\n            this.game.load(fen);\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen\n            });\n        } catch (e) {\n            throw new Error(\"Invalid FEN string\");\n        }\n    }\n    // Movimentos\n    /**\n   * Obtém todos os movimentos legais possíveis para uma peça em uma determinada posição.\n   * \n   * @param position - Posição da peça no tabuleiro\n   * @returns Lista de movimentos legais possíveis\n   */ getPossibleMoves(position) {\n        try {\n            const square = this.positionToSquare(position);\n            const fen = this.getFEN();\n            const cacheKey = \"\".concat(fen, \":\").concat(square);\n            const cacheHit = this.positionCache.has(cacheKey);\n            let moves;\n            if (cacheHit) {\n                const cache = this.positionCache.get(cacheKey);\n                moves = cache.bestLine;\n            } else {\n                moves = this.game.moves({\n                    square,\n                    verbose: true\n                });\n                // Cache the result\n                this.positionCache.set(cacheKey, {\n                    evaluation: 0,\n                    depth: 0,\n                    bestLine: moves,\n                    threats: [],\n                    positionalFeatures: {\n                        pawnStructure: 0,\n                        kingSafety: 0,\n                        mobility: 0,\n                        centerControl: 0,\n                        pieceActivity: 0\n                    }\n                });\n            }\n            this.monitor.recordCacheAccess(cacheHit);\n            return moves.map((move)=>({\n                    from: this.squareToPosition(move.from),\n                    to: this.squareToPosition(move.to),\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                }));\n        } catch (e) {\n            // Se houver erro na geração de movimentos, retorna lista vazia\n            return [];\n        }\n    }\n    /**\n   * Executa um movimento no tabuleiro.\n   * \n   * @param from - Posição inicial da peça\n   * @param to - Posição final da peça\n   * @returns true se o movimento foi executado com sucesso, false caso contrário\n   * @emits {MOVE_MADE} Quando um movimento é realizado com sucesso\n   * @emits {CHECK} Quando o movimento resulta em xeque\n   * @emits {GAME_OVER} Quando o movimento resulta em fim de jogo\n   */ makeMove(from, to) {\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\" // Auto-promove para rainha por padrão\n            });\n            if (move) {\n                const chessMove = {\n                    from,\n                    to,\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                };\n                this.emitEvent({\n                    type: \"MOVE_MADE\",\n                    move: chessMove\n                });\n                if (this.isCheck()) {\n                    this.emitEvent({\n                        type: \"CHECK\",\n                        kingPosition: this.findKing(this.getCurrentPlayer())\n                    });\n                }\n                if (this.isGameOver()) {\n                    let result = \"draw\";\n                    if (this.isCheckmate()) {\n                        result = this.getCurrentPlayer() === \"white\" ? \"black\" : \"white\";\n                    }\n                    this.emitEvent({\n                        type: \"GAME_OVER\",\n                        result\n                    });\n                }\n                return true;\n            }\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n   * Desfaz o último movimento realizado.\n   * \n   * @returns true se havia um movimento para desfazer, false caso contrário\n   * @emits {POSITION_CHANGED} Quando o movimento é desfeito com sucesso\n   */ undoLastMove() {\n        const move = this.game.undo();\n        if (move) {\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen: this.getFEN()\n            });\n            return true;\n        }\n        return false;\n    }\n    // Estado do jogo\n    /**\n   * Verifica se o jogador atual está em xeque.\n   * \n   * @returns true se o jogador atual está em xeque, false caso contrário\n   */ isCheck() {\n        return this.game.isCheck();\n    }\n    /**\n   * Verifica se o jogador atual está em xeque-mate.\n   * \n   * @returns true se o jogador atual está em xeque-mate, false caso contrário\n   */ isCheckmate() {\n        return this.game.isCheckmate();\n    }\n    /**\n   * Verifica se o jogo está empatado.\n   * \n   * @returns true se o jogo está empatado, false caso contrário\n   */ isDraw() {\n        return this.game.isDraw();\n    }\n    /**\n   * Verifica se o jogo terminou (xeque-mate ou empate).\n   * \n   * @returns true se o jogo terminou, false caso contrário\n   */ isGameOver() {\n        return this.game.isGameOver();\n    }\n    /**\n   * Obtém o jogador atual.\n   * \n   * @returns 'white' para as brancas, 'black' para as pretas\n   */ getCurrentPlayer() {\n        const turn = this.game.turn();\n        return turn === \"w\" ? \"white\" : \"black\";\n    }\n    // Avaliação e análise\n    /**\n   * Avalia a posição atual do jogo.\n   * \n   * Esta função considera diversos fatores para avaliar a posição:\n   * - Material: Valor das peças presentes no tabuleiro\n   * - Posição: Qualidade do posicionamento das peças\n   * - Mobilidade: Quantidade de movimentos disponíveis\n   * - Segurança do Rei: Avaliação da proteção do rei\n   * - Estrutura de Peões: Qualidade da estrutura de peões\n   * \n   * @returns Um número que representa a avaliação da posição.\n   * Valores positivos favorecem as brancas, negativos favorecem as pretas.\n   */ evaluatePosition() {\n        // Implementação básica de avaliação\n        const weights = this.options.evaluationParameters || {\n            materialWeight: 1,\n            positionWeight: 0.1,\n            mobilityWeight: 0.1,\n            kingSafetyWeight: 0.2,\n            pawnStructureWeight: 0.1\n        };\n        let score = 0;\n        // Material\n        score += this.evaluateMaterial() * weights.materialWeight;\n        // Posição das peças\n        score += this.evaluatePiecePositions() * weights.positionWeight;\n        // Mobilidade\n        score += this.evaluateMobility() * weights.mobilityWeight;\n        // Segurança do rei\n        score += this.evaluateKingSafety() * weights.kingSafetyWeight;\n        // Estrutura de peões\n        score += this.evaluatePawnStructure() * weights.pawnStructureWeight;\n        return score;\n    }\n    evaluatePiecePositions() {\n        // Simple piece-square tables evaluation\n        const pieceSquareValues = {\n            p: [\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50\n                ],\n                [\n                    10,\n                    10,\n                    20,\n                    30,\n                    30,\n                    20,\n                    10,\n                    10\n                ],\n                [\n                    5,\n                    5,\n                    10,\n                    25,\n                    25,\n                    10,\n                    5,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    20,\n                    20,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    5,\n                    -5,\n                    -10,\n                    0,\n                    0,\n                    -10,\n                    -5,\n                    5\n                ],\n                [\n                    5,\n                    10,\n                    10,\n                    -20,\n                    -20,\n                    10,\n                    10,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            n: [\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -30,\n                    0,\n                    10,\n                    15,\n                    15,\n                    10,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    15,\n                    20,\n                    20,\n                    15,\n                    5,\n                    -30\n                ],\n                [\n                    -30,\n                    0,\n                    15,\n                    20,\n                    20,\n                    15,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    10,\n                    15,\n                    15,\n                    10,\n                    5,\n                    -30\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    5,\n                    5,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ]\n            ],\n            b: [\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ],\n                [\n                    -10,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    5,\n                    10,\n                    10,\n                    5,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    5,\n                    10,\n                    10,\n                    5,\n                    5,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    10,\n                    10,\n                    10,\n                    10,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    0,\n                    0,\n                    0,\n                    0,\n                    5,\n                    -10\n                ],\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ]\n            ]\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const pieceTable = pieceSquareValues[piece.type];\n                    if (pieceTable) {\n                        const positionValue = pieceTable[piece.color === \"w\" ? row : 7 - row][col];\n                        score += piece.color === \"w\" ? positionValue : -positionValue;\n                    }\n                }\n            }\n        }\n        return score;\n    }\n    /**\n   * Encontra o melhor movimento possível para o jogador atual.\n   * \n   * @param depth - Profundidade máxima de busca na árvore de movimentos\n   * @returns O melhor movimento encontrado, ou null se nenhum movimento for possível\n   * @todo Implementar algoritmo minimax com poda alpha-beta\n   */ getBestMove(depth) {\n        // TODO: Implementar busca minimax com poda alpha-beta\n        return null;\n    }\n    /**\n   * Obtém o histórico completo de movimentos do jogo.\n   * \n   * @returns Lista de movimentos realizados desde o início do jogo\n   */ getGameHistory() {\n        return this.game.history({\n            verbose: true\n        }).map((move)=>({\n                from: this.squareToPosition(move.from),\n                to: this.squareToPosition(move.to),\n                piece: {\n                    type: move.piece,\n                    color: move.color === \"w\" ? \"white\" : \"black\"\n                },\n                captured: move.captured ? {\n                    type: move.captured,\n                    color: move.color === \"w\" ? \"black\" : \"white\"\n                } : undefined,\n                promotion: move.promotion\n            }));\n    }\n    // Validação\n    /**\n   * Verifica se um movimento é válido sem executá-lo.\n   * \n   * @param from - Posição inicial da peça\n   * @param to - Posição final da peça\n   * @returns true se o movimento é legal, false caso contrário\n   */ isValidMove(from, to) {\n        // Validação básica de posição\n        if (!this.isValidPosition(from) || !this.isValidPosition(to)) {\n            return false;\n        }\n        // Verifica se a peça pertence ao jogador atual\n        const piece = this.game.board()[from.row][from.col];\n        if (!piece || piece.color !== (this.getCurrentPlayer() === \"white\" ? \"w\" : \"b\")) {\n            return false;\n        }\n        // Tenta fazer o movimento no chess.js\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\"\n            });\n            if (move) {\n                // Desfaz o movimento para manter o estado original\n                this.game.undo();\n                return true;\n            }\n        } catch (e) {\n        // Ignora erros do chess.js\n        }\n        return false;\n    }\n    /**\n   * Verifica se uma posição está dentro dos limites do tabuleiro.\n   * \n   * @param position - Posição a ser verificada\n   * @returns true se a posição é válida, false caso contrário\n   */ isValidPosition(position) {\n        return position.row >= 0 && position.row < 8 && position.col >= 0 && position.col < 8;\n    }\n    // Utilidades\n    /**\n   * Reinicia o jogo para a posição inicial.\n   * \n   * @emits {POSITION_CHANGED} Quando o tabuleiro é reiniciado\n   */ reset() {\n        this.game.reset();\n        this.positionCache.clear();\n        this.emitEvent({\n            type: \"POSITION_CHANGED\",\n            fen: this.getFEN()\n        });\n    }\n    /**\n   * Cria uma cópia independente do motor de xadrez atual.\n   * \n   * @returns Uma nova instância do motor com o mesmo estado atual\n   */ clone() {\n        const clonedEngine = new ChessEngineBase(this.options);\n        clonedEngine.setFEN(this.getFEN());\n        return clonedEngine;\n    }\n    // Métodos protegidos auxiliares\n    positionToSquare(position) {\n        const file = String.fromCharCode(\"a\".charCodeAt(0) + position.col);\n        const rank = 8 - position.row;\n        return \"\".concat(file).concat(rank);\n    }\n    squareToPosition(square) {\n        const col = square.charCodeAt(0) - \"a\".charCodeAt(0);\n        const row = 8 - parseInt(square[1]);\n        return {\n            row,\n            col\n        };\n    }\n    findKing(color) {\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece && piece.type === \"k\" && piece.color === (color === \"white\" ? \"w\" : \"b\")) {\n                    return {\n                        row,\n                        col\n                    };\n                }\n            }\n        }\n        throw new Error(\"King not found\");\n    }\n    /**\n   * Verifica o status de saúde do motor.\n   * \n   * @returns Status atual do motor incluindo métricas de desempenho\n   */ checkHealth() {\n        return this.monitor.checkHealth();\n    }\n    /**\n   * Emite um evento do motor.\n   * \n   * @param event - Evento a ser emitido\n   */ emitEvent(event) {\n        this.eventEmitter.emit(\"engine-event\", event);\n        this.monitor.recordEvent(event);\n    }\n    // Métodos de avaliação\n    evaluateMaterial() {\n        const pieceValues = {\n            p: 1,\n            n: 3,\n            b: 3,\n            r: 5,\n            q: 9,\n            k: 0\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const value = pieceValues[piece.type];\n                    score += piece.color === \"w\" ? value : -value;\n                }\n            }\n        }\n        return score;\n    }\n    evaluateMobility() {\n        const whiteMoves = this.game.moves().length;\n        // Clona o jogo para ver os movimentos do oponente\n        const tempGame = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(this.game.fen());\n        tempGame.load(this.game.fen().replace(\" w \", \" b \"));\n        const blackMoves = tempGame.moves().length;\n        return whiteMoves - blackMoves;\n    }\n    evaluateKingSafety() {\n        // TODO: Implementar avaliação de segurança do rei\n        return 0;\n    }\n    evaluatePawnStructure() {\n        // TODO: Implementar avaliação de estrutura de peões\n        return 0;\n    }\n    // Event handlers\n    on(eventName, handler) {\n        this.eventEmitter.on(eventName, handler);\n    }\n    off(eventName, handler) {\n        this.eventEmitter.off(eventName, handler);\n    }\n    /**\n   * Cria uma nova instância do motor de xadrez.\n   * \n   * @param options - Opções de configuração do motor\n   * @param options.startPosition - Posição inicial em notação FEN (opcional)\n   * @param options.evaluationParameters - Parâmetros para avaliação de posição (opcional)\n   */ constructor(options = {}){\n        this.game = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(options.startPosition || _constants_game__WEBPACK_IMPORTED_MODULE_2__.INITIAL_FEN);\n        this.options = options;\n        this.eventEmitter = new events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n        this.positionCache = new Map();\n        this.monitor = new _monitoring_ArquimaxMonitor__WEBPACK_IMPORTED_MODULE_1__.ArquimaxMonitor();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBYzhCO0FBQ2Y7QUFDVjtBQUV0Qzs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1JO0lBOEJYLGlCQUFpQjtJQUNqQjs7Ozs7R0FLQyxHQUNEQyxXQUEyQjtRQUN6QixNQUFNQyxRQUFRLElBQUksQ0FBQ0MsSUFBSSxDQUFDRCxLQUFLO1FBQzdCLE9BQU9BLE1BQU1FLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFDZkEsSUFBSUQsR0FBRyxDQUFDRSxDQUFBQSxTQUNOQSxTQUFTO29CQUNQQyxNQUFNRCxPQUFPQyxJQUFJO29CQUNqQkMsT0FBT0YsT0FBT0UsS0FBSyxLQUFLLE1BQU0sVUFBVSxPQUFPO2dCQUNqRCxJQUFJLElBQUk7SUFHZDtJQUVBOzs7O0dBSUMsR0FDREMsU0FBaUI7UUFDZixPQUFPLElBQUksQ0FBQ04sSUFBSSxDQUFDTyxHQUFHO0lBQ3RCO0lBRUE7Ozs7OztHQU1DLEdBQ0RDLE9BQU9ELEdBQVcsRUFBUTtRQUN4QixJQUFJO1lBQ0YscURBQXFEO1lBQ3JELElBQUksQ0FBQ1AsSUFBSSxDQUFDUyxJQUFJLENBQUNGO1lBQ2YsSUFBSSxDQUFDRyxTQUFTLENBQUM7Z0JBQ2JOLE1BQU07Z0JBQ05HO1lBQ0Y7UUFDRixFQUFFLE9BQU9JLEdBQUc7WUFDVixNQUFNLElBQUlDLE1BQU0sc0JBQXNCO1FBQ3hDO0lBQ0Y7SUFFQSxhQUFhO0lBQ2I7Ozs7O0dBS0MsR0FDREMsaUJBQWlCQyxRQUF1QixFQUFlO1FBQ3JELElBQUk7WUFDRixNQUFNWCxTQUFTLElBQUksQ0FBQ1ksZ0JBQWdCLENBQUNEO1lBQ3JDLE1BQU1QLE1BQU0sSUFBSSxDQUFDRCxNQUFNO1lBQ3ZCLE1BQU1VLFdBQVcsR0FBVWIsT0FBUEksS0FBSSxLQUFVLE9BQVBKO1lBQzNCLE1BQU1jLFdBQVcsSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ0g7WUFFeEMsSUFB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QUFJO29CQUFJO2lCQUFFO2FBQ2hDO1lBQ0RDLEdBQUc7Z0JBQ0Q7b0JBQUMsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFHLENBQUM7b0JBQUs7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUUsQ0FBQztvQkFBRyxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFLO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUs7b0JBQUc7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUs7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBRztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSztvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFLO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBSztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBRSxDQUFDO29CQUFHLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztpQkFBRzthQUNsQztZQUNEQyxHQUFHO2dCQUNEO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFJO29C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ZixZQUFZLENBQUNhLEVBQUUsQ0FBQ0MsV0FBV0M7SUFDbEM7SUFFQUMsSUFBSUYsU0FBaUIsRUFBRUMsT0FBcUMsRUFBUTtRQUNsRSxJQUFJLENBQUNmLFlBQVksQ0FBQ2dCLEdBQUcsQ0FBQ0YsV0FBV0M7SUFDbkM7SUEzaUJBOzs7Ozs7R0FNQyxHQUNERSxZQUFZdEQsVUFBeUIsQ0FBQyxDQUFDLENBQUU7UUFDdkMsSUFBSSxDQUFDNUQsSUFBSSxHQUFHLElBQUlQLDJDQUFLQSxDQUFDbUUsUUFBUXVELGFBQWEsSUFBSXhILHdEQUFXQTtRQUMxRCxJQUFJLENBQUNpRSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDcUMsWUFBWSxHQUFHLElBQUlyRyxnREFBWUE7UUFDcEMsSUFBSSxDQUFDc0IsYUFBYSxHQUFHLElBQUlrRztRQUN6QixJQUFJLENBQUNqRixPQUFPLEdBQUcsSUFBSXpDLHdFQUFlQTtJQUNwQztBQStoQkYsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHM/ZjI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzcyB9IGZyb20gJ2NoZXNzLmpzJztcbmltcG9ydCB7IFxuICBDaGVzc0VuZ2luZSwgXG4gIEVuZ2luZU9wdGlvbnMsIFxuICBFbmdpbmVBbmFseXNpcyxcbiAgRW5naW5lRXZlbnQsXG4gIEhlYWx0aFN0YXR1c1xufSBmcm9tICcuLi90eXBlcy9lbmdpbmUnO1xuaW1wb3J0IHsgXG4gIENoZXNzUG9zaXRpb24sIFxuICBDaGVzc1BpZWNlLCBcbiAgQ2hlc3NNb3ZlLFxuICBQaWVjZVR5cGVcbn0gZnJvbSAnLi4vdHlwZXMvY2hlc3MnO1xuaW1wb3J0IHsgQXJxdWltYXhNb25pdG9yIH0gZnJvbSAnLi9tb25pdG9yaW5nL0FycXVpbWF4TW9uaXRvcic7XG5pbXBvcnQgeyBJTklUSUFMX0ZFTiB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogSW1wbGVtZW50YcOnw6NvIGJhc2UgZG8gbW90b3IgZGUgeGFkcmV6LlxuICogXG4gKiBFc3RhIGNsYXNzZSBmb3JuZWNlIGEgZnVuY2lvbmFsaWRhZGUgY2VudHJhbCBwYXJhIHVtIG1vdG9yIGRlIHhhZHJleixcbiAqIGluY2x1aW5kbyBnZXJlbmNpYW1lbnRvIGRlIGVzdGFkbyBkbyBqb2dvLCB2YWxpZGHDp8OjbyBkZSBtb3ZpbWVudG9zLFxuICogYXZhbGlhw6fDo28gZGUgcG9zacOnw6NvIGUgZXZlbnRvcyBkbyBqb2dvLlxuICogXG4gKiBAaW1wbGVtZW50cyB7Q2hlc3NFbmdpbmV9XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVzc0VuZ2luZUJhc2UgaW1wbGVtZW50cyBDaGVzc0VuZ2luZSB7XG4gIC8qKiBJbnN0w6JuY2lhIGRvIGNoZXNzLmpzIHF1ZSBnZXJlbmNpYSBhcyByZWdyYXMgZSBlc3RhZG8gZG8gam9nbyAqL1xuICBwcm90ZWN0ZWQgZ2FtZTogQ2hlc3M7XG5cbiAgLyoqIE9ww6fDtWVzIGRlIGNvbmZpZ3VyYcOnw6NvIGRvIG1vdG9yICovXG4gIHByb3RlY3RlZCBvcHRpb25zOiBFbmdpbmVPcHRpb25zO1xuXG4gIC8qKiBFbWlzc29yIGRlIGV2ZW50b3MgcGFyYSBub3RpZmljYXIgbXVkYW7Dp2FzIG5vIGVzdGFkbyBkbyBqb2dvICovXG4gIHByb3RlY3RlZCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuICAvKiogQ2FjaGUgZGUgYW7DoWxpc2VzIGRlIHBvc2nDp8OjbyBwYXJhIG90aW1pemHDp8OjbyAqL1xuICBwcm90ZWN0ZWQgcG9zaXRpb25DYWNoZTogTWFwPHN0cmluZywgRW5naW5lQW5hbHlzaXM+O1xuXG4gIHByaXZhdGUgbW9uaXRvcjogQXJxdWltYXhNb25pdG9yO1xuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBub3ZhIGluc3TDom5jaWEgZG8gbW90b3IgZGUgeGFkcmV6LlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcMOnw7VlcyBkZSBjb25maWd1cmHDp8OjbyBkbyBtb3RvclxuICAgKiBAcGFyYW0gb3B0aW9ucy5zdGFydFBvc2l0aW9uIC0gUG9zacOnw6NvIGluaWNpYWwgZW0gbm90YcOnw6NvIEZFTiAob3BjaW9uYWwpXG4gICAqIEBwYXJhbSBvcHRpb25zLmV2YWx1YXRpb25QYXJhbWV0ZXJzIC0gUGFyw6JtZXRyb3MgcGFyYSBhdmFsaWHDp8OjbyBkZSBwb3Npw6fDo28gKG9wY2lvbmFsKVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRW5naW5lT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5nYW1lID0gbmV3IENoZXNzKG9wdGlvbnMuc3RhcnRQb3NpdGlvbiB8fCBJTklUSUFMX0ZFTik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnBvc2l0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tb25pdG9yID0gbmV3IEFycXVpbWF4TW9uaXRvcigpO1xuICB9XG5cbiAgLy8gRXN0YWRvIGRvIGpvZ29cbiAgLyoqXG4gICAqIE9idMOpbSBhIHJlcHJlc2VudGHDp8OjbyBhdHVhbCBkbyB0YWJ1bGVpcm8uXG4gICAqIFxuICAgKiBAcmV0dXJucyBVbWEgbWF0cml6IDh4OCByZXByZXNlbnRhbmRvIG8gdGFidWxlaXJvLCBvbmRlIGNhZGEgZWxlbWVudG9cbiAgICogw6kgdW1hIHBlw6dhIGRlIHhhZHJleiBvdSBudWxsIHBhcmEgY2FzYXMgdmF6aWFzLlxuICAgKi9cbiAgZ2V0Qm9hcmQoKTogQ2hlc3NQaWVjZVtdW10ge1xuICAgIGNvbnN0IGJvYXJkID0gdGhpcy5nYW1lLmJvYXJkKCk7XG4gICAgcmV0dXJuIGJvYXJkLm1hcChyb3cgPT4gXG4gICAgICByb3cubWFwKHNxdWFyZSA9PiBcbiAgICAgICAgc3F1YXJlID8ge1xuICAgICAgICAgIHR5cGU6IHNxdWFyZS50eXBlIGFzIFBpZWNlVHlwZSxcbiAgICAgICAgICBjb2xvcjogc3F1YXJlLmNvbG9yID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgICB9IDogbnVsbFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIGEgcG9zacOnw6NvIGF0dWFsIGVtIG5vdGHDp8OjbyBGRU4uXG4gICAqIFxuICAgKiBAcmV0dXJucyBTdHJpbmcgRkVOIHJlcHJlc2VudGFuZG8gbyBlc3RhZG8gYXR1YWwgZG8gam9nb1xuICAgKi9cbiAgZ2V0RkVOKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5mZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgdW1hIG5vdmEgcG9zacOnw6NvIHBhcmEgbyBqb2dvIHVzYW5kbyBub3Rhw6fDo28gRkVOLlxuICAgKiBcbiAgICogQHBhcmFtIGZlbiAtIFN0cmluZyBGRU4gcmVwcmVzZW50YW5kbyBhIG5vdmEgcG9zacOnw6NvXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBTZSBhIHN0cmluZyBGRU4gZm9yIGludsOhbGlkYVxuICAgKiBAZW1pdHMge1BPU0lUSU9OX0NIQU5HRUR9IFF1YW5kbyBhIHBvc2nDp8OjbyDDqSBhbHRlcmFkYSBjb20gc3VjZXNzb1xuICAgKi9cbiAgc2V0RkVOKGZlbjogc3RyaW5nKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5hIG5vdmEgdmVyc8OjbyBkbyBjaGVzcy5qcywgbG9hZCgpIGrDoSB2YWxpZGEgbyBGRU5cbiAgICAgIHRoaXMuZ2FtZS5sb2FkKGZlbik7XG4gICAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsIFxuICAgICAgICBmZW4gXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRkVOIHN0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmltZW50b3NcbiAgLyoqXG4gICAqIE9idMOpbSB0b2RvcyBvcyBtb3ZpbWVudG9zIGxlZ2FpcyBwb3Nzw612ZWlzIHBhcmEgdW1hIHBlw6dhIGVtIHVtYSBkZXRlcm1pbmFkYSBwb3Npw6fDo28uXG4gICAqIFxuICAgKiBAcGFyYW0gcG9zaXRpb24gLSBQb3Npw6fDo28gZGEgcGXDp2Egbm8gdGFidWxlaXJvXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIG1vdmltZW50b3MgbGVnYWlzIHBvc3PDrXZlaXNcbiAgICovXG4gIGdldFBvc3NpYmxlTW92ZXMocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBDaGVzc01vdmVbXSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMucG9zaXRpb25Ub1NxdWFyZShwb3NpdGlvbik7XG4gICAgICBjb25zdCBmZW4gPSB0aGlzLmdldEZFTigpO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtmZW59OiR7c3F1YXJlfWA7XG4gICAgICBjb25zdCBjYWNoZUhpdCA9IHRoaXMucG9zaXRpb25DYWNoZS5oYXMoY2FjaGVLZXkpO1xuICAgICAgXG4gICAgICBsZXQgbW92ZXM7XG4gICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBvc2l0aW9uQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgbW92ZXMgPSBjYWNoZSEuYmVzdExpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3ZlcyA9IHRoaXMuZ2FtZS5tb3Zlcyh7IFxuICAgICAgICAgIHNxdWFyZSxcbiAgICAgICAgICB2ZXJib3NlOiB0cnVlIFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICB0aGlzLnBvc2l0aW9uQ2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgZXZhbHVhdGlvbjogMCxcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBiZXN0TGluZTogbW92ZXMsXG4gICAgICAgICAgdGhyZWF0czogW10sXG4gICAgICAgICAgcG9zaXRpb25hbEZlYXR1cmVzOiB7XG4gICAgICAgICAgICBwYXduU3RydWN0dXJlOiAwLFxuICAgICAgICAgICAga2luZ1NhZmV0eTogMCxcbiAgICAgICAgICAgIG1vYmlsaXR5OiAwLFxuICAgICAgICAgICAgY2VudGVyQ29udHJvbDogMCxcbiAgICAgICAgICAgIHBpZWNlQWN0aXZpdHk6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLm1vbml0b3IucmVjb3JkQ2FjaGVBY2Nlc3MoY2FjaGVIaXQpO1xuXG4gICAgICByZXR1cm4gbW92ZXMubWFwKG1vdmUgPT4gKHtcbiAgICAgICAgZnJvbTogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUuZnJvbSksXG4gICAgICAgIHRvOiB0aGlzLnNxdWFyZVRvUG9zaXRpb24obW92ZS50byksXG4gICAgICAgIHBpZWNlOiB7XG4gICAgICAgICAgdHlwZTogbW92ZS5waWVjZSBhcyBQaWVjZVR5cGUsXG4gICAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmVkOiBtb3ZlLmNhcHR1cmVkID8ge1xuICAgICAgICAgIHR5cGU6IG1vdmUuY2FwdHVyZWQgYXMgUGllY2VUeXBlLFxuICAgICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnYmxhY2snIDogJ3doaXRlJ1xuICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICBwcm9tb3Rpb246IG1vdmUucHJvbW90aW9uIGFzIFBpZWNlVHlwZSB8IHVuZGVmaW5lZCxcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBTZSBob3V2ZXIgZXJybyBuYSBnZXJhw6fDo28gZGUgbW92aW1lbnRvcywgcmV0b3JuYSBsaXN0YSB2YXppYVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRhIHVtIG1vdmltZW50byBubyB0YWJ1bGVpcm8uXG4gICAqIFxuICAgKiBAcGFyYW0gZnJvbSAtIFBvc2nDp8OjbyBpbmljaWFsIGRhIHBlw6dhXG4gICAqIEBwYXJhbSB0byAtIFBvc2nDp8OjbyBmaW5hbCBkYSBwZcOnYVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gbW92aW1lbnRvIGZvaSBleGVjdXRhZG8gY29tIHN1Y2Vzc28sIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKiBAZW1pdHMge01PVkVfTUFERX0gUXVhbmRvIHVtIG1vdmltZW50byDDqSByZWFsaXphZG8gY29tIHN1Y2Vzc29cbiAgICogQGVtaXRzIHtDSEVDS30gUXVhbmRvIG8gbW92aW1lbnRvIHJlc3VsdGEgZW0geGVxdWVcbiAgICogQGVtaXRzIHtHQU1FX09WRVJ9IFF1YW5kbyBvIG1vdmltZW50byByZXN1bHRhIGVtIGZpbSBkZSBqb2dvXG4gICAqL1xuICBtYWtlTW92ZShmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtb3ZlID0gdGhpcy5nYW1lLm1vdmUoe1xuICAgICAgICBmcm9tOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUoZnJvbSksXG4gICAgICAgIHRvOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUodG8pLFxuICAgICAgICBwcm9tb3Rpb246ICdxJyAvLyBBdXRvLXByb21vdmUgcGFyYSByYWluaGEgcG9yIHBhZHLDo29cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobW92ZSkge1xuICAgICAgICBjb25zdCBjaGVzc01vdmU6IENoZXNzTW92ZSA9IHtcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBpZWNlOiB7XG4gICAgICAgICAgICB0eXBlOiBtb3ZlLnBpZWNlLFxuICAgICAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlZDogbW92ZS5jYXB0dXJlZCA/IHtcbiAgICAgICAgICAgIHR5cGU6IG1vdmUuY2FwdHVyZWQsXG4gICAgICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ2JsYWNrJyA6ICd3aGl0ZSdcbiAgICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHByb21vdGlvbjogbW92ZS5wcm9tb3Rpb24sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoeyB0eXBlOiAnTU9WRV9NQURFJywgbW92ZTogY2hlc3NNb3ZlIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KHsgXG4gICAgICAgICAgICB0eXBlOiAnQ0hFQ0snLFxuICAgICAgICAgICAga2luZ1Bvc2l0aW9uOiB0aGlzLmZpbmRLaW5nKHRoaXMuZ2V0Q3VycmVudFBsYXllcigpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNHYW1lT3ZlcigpKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9ICdkcmF3JztcbiAgICAgICAgICBpZiAodGhpcy5pc0NoZWNrbWF0ZSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldEN1cnJlbnRQbGF5ZXIoKSA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXRFdmVudCh7IHR5cGU6ICdHQU1FX09WRVInLCByZXN1bHQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2ZheiBvIMO6bHRpbW8gbW92aW1lbnRvIHJlYWxpemFkby5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgaGF2aWEgdW0gbW92aW1lbnRvIHBhcmEgZGVzZmF6ZXIsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKiBAZW1pdHMge1BPU0lUSU9OX0NIQU5HRUR9IFF1YW5kbyBvIG1vdmltZW50byDDqSBkZXNmZWl0byBjb20gc3VjZXNzb1xuICAgKi9cbiAgdW5kb0xhc3RNb3ZlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG1vdmUgPSB0aGlzLmdhbWUudW5kbygpO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsXG4gICAgICAgIGZlbjogdGhpcy5nZXRGRU4oKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXN0YWRvIGRvIGpvZ29cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gam9nYWRvciBhdHVhbCBlc3TDoSBlbSB4ZXF1ZS5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBqb2dhZG9yIGF0dWFsIGVzdMOhIGVtIHhlcXVlLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzQ2hlY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0NoZWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyBqb2dhZG9yIGF0dWFsIGVzdMOhIGVtIHhlcXVlLW1hdGUuXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gam9nYWRvciBhdHVhbCBlc3TDoSBlbSB4ZXF1ZS1tYXRlLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzQ2hlY2ttYXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdhbWUuaXNDaGVja21hdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIGpvZ28gZXN0w6EgZW1wYXRhZG8uXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gam9nbyBlc3TDoSBlbXBhdGFkbywgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc0RyYXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0RyYXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIGpvZ28gdGVybWlub3UgKHhlcXVlLW1hdGUgb3UgZW1wYXRlKS5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBqb2dvIHRlcm1pbm91LCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzR2FtZU92ZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0dhbWVPdmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG8gam9nYWRvciBhdHVhbC5cbiAgICogXG4gICAqIEByZXR1cm5zICd3aGl0ZScgcGFyYSBhcyBicmFuY2FzLCAnYmxhY2snIHBhcmEgYXMgcHJldGFzXG4gICAqL1xuICBnZXRDdXJyZW50UGxheWVyKCk6ICd3aGl0ZScgfCAnYmxhY2snIHtcbiAgICBjb25zdCB0dXJuID0gdGhpcy5nYW1lLnR1cm4oKTtcbiAgICByZXR1cm4gdHVybiA9PT0gJ3cnID8gJ3doaXRlJyA6ICdibGFjayc7XG4gIH1cblxuICAvLyBBdmFsaWHDp8OjbyBlIGFuw6FsaXNlXG4gIC8qKlxuICAgKiBBdmFsaWEgYSBwb3Npw6fDo28gYXR1YWwgZG8gam9nby5cbiAgICogXG4gICAqIEVzdGEgZnVuw6fDo28gY29uc2lkZXJhIGRpdmVyc29zIGZhdG9yZXMgcGFyYSBhdmFsaWFyIGEgcG9zacOnw6NvOlxuICAgKiAtIE1hdGVyaWFsOiBWYWxvciBkYXMgcGXDp2FzIHByZXNlbnRlcyBubyB0YWJ1bGVpcm9cbiAgICogLSBQb3Npw6fDo286IFF1YWxpZGFkZSBkbyBwb3NpY2lvbmFtZW50byBkYXMgcGXDp2FzXG4gICAqIC0gTW9iaWxpZGFkZTogUXVhbnRpZGFkZSBkZSBtb3ZpbWVudG9zIGRpc3BvbsOtdmVpc1xuICAgKiAtIFNlZ3VyYW7Dp2EgZG8gUmVpOiBBdmFsaWHDp8OjbyBkYSBwcm90ZcOnw6NvIGRvIHJlaVxuICAgKiAtIEVzdHJ1dHVyYSBkZSBQZcO1ZXM6IFF1YWxpZGFkZSBkYSBlc3RydXR1cmEgZGUgcGXDtWVzXG4gICAqIFxuICAgKiBAcmV0dXJucyBVbSBuw7ptZXJvIHF1ZSByZXByZXNlbnRhIGEgYXZhbGlhw6fDo28gZGEgcG9zacOnw6NvLlxuICAgKiBWYWxvcmVzIHBvc2l0aXZvcyBmYXZvcmVjZW0gYXMgYnJhbmNhcywgbmVnYXRpdm9zIGZhdm9yZWNlbSBhcyBwcmV0YXMuXG4gICAqL1xuICBldmFsdWF0ZVBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgLy8gSW1wbGVtZW50YcOnw6NvIGLDoXNpY2EgZGUgYXZhbGlhw6fDo29cbiAgICBjb25zdCB3ZWlnaHRzID0gdGhpcy5vcHRpb25zLmV2YWx1YXRpb25QYXJhbWV0ZXJzIHx8IHtcbiAgICAgIG1hdGVyaWFsV2VpZ2h0OiAxLFxuICAgICAgcG9zaXRpb25XZWlnaHQ6IDAuMSxcbiAgICAgIG1vYmlsaXR5V2VpZ2h0OiAwLjEsXG4gICAgICBraW5nU2FmZXR5V2VpZ2h0OiAwLjIsXG4gICAgICBwYXduU3RydWN0dXJlV2VpZ2h0OiAwLjFcbiAgICB9O1xuXG4gICAgbGV0IHNjb3JlID0gMDtcblxuICAgIC8vIE1hdGVyaWFsXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZU1hdGVyaWFsKCkgKiB3ZWlnaHRzLm1hdGVyaWFsV2VpZ2h0O1xuXG4gICAgLy8gUG9zacOnw6NvIGRhcyBwZcOnYXNcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlUGllY2VQb3NpdGlvbnMoKSAqIHdlaWdodHMucG9zaXRpb25XZWlnaHQ7XG5cbiAgICAvLyBNb2JpbGlkYWRlXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZU1vYmlsaXR5KCkgKiB3ZWlnaHRzLm1vYmlsaXR5V2VpZ2h0O1xuXG4gICAgLy8gU2VndXJhbsOnYSBkbyByZWlcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlS2luZ1NhZmV0eSgpICogd2VpZ2h0cy5raW5nU2FmZXR5V2VpZ2h0O1xuXG4gICAgLy8gRXN0cnV0dXJhIGRlIHBlw7Vlc1xuICAgIHNjb3JlICs9IHRoaXMuZXZhbHVhdGVQYXduU3RydWN0dXJlKCkgKiB3ZWlnaHRzLnBhd25TdHJ1Y3R1cmVXZWlnaHQ7XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlUGllY2VQb3NpdGlvbnMoKTogbnVtYmVyIHtcbiAgICAvLyBTaW1wbGUgcGllY2Utc3F1YXJlIHRhYmxlcyBldmFsdWF0aW9uXG4gICAgY29uc3QgcGllY2VTcXVhcmVWYWx1ZXMgPSB7XG4gICAgICBwOiBbIC8vIFBhd25zXG4gICAgICAgIFswLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLCAgMF0sXG4gICAgICAgIFs1MCwgNTAsIDUwLCA1MCwgNTAsIDUwLCA1MCwgNTBdLFxuICAgICAgICBbMTAsIDEwLCAyMCwgMzAsIDMwLCAyMCwgMTAsIDEwXSxcbiAgICAgICAgWzUsICA1LCAxMCwgMjUsIDI1LCAxMCwgIDUsICA1XSxcbiAgICAgICAgWzAsICAwLCAgMCwgMjAsIDIwLCAgMCwgIDAsICAwXSxcbiAgICAgICAgWzUsIC01LC0xMCwgIDAsICAwLC0xMCwgLTUsICA1XSxcbiAgICAgICAgWzUsIDEwLCAxMCwtMjAsLTIwLCAxMCwgMTAsICA1XSxcbiAgICAgICAgWzAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwXVxuICAgICAgXSxcbiAgICAgIG46IFsgLy8gS25pZ2h0c1xuICAgICAgICBbLTUwLC00MCwtMzAsLTMwLC0zMCwtMzAsLTQwLC01MF0sXG4gICAgICAgIFstNDAsLTIwLCAgMCwgIDAsICAwLCAgMCwtMjAsLTQwXSxcbiAgICAgICAgWy0zMCwgIDAsIDEwLCAxNSwgMTUsIDEwLCAgMCwtMzBdLFxuICAgICAgICBbLTMwLCAgNSwgMTUsIDIwLCAyMCwgMTUsICA1LC0zMF0sXG4gICAgICAgIFstMzAsICAwLCAxNSwgMjAsIDIwLCAxNSwgIDAsLTMwXSxcbiAgICAgICAgWy0zMCwgIDUsIDEwLCAxNSwgMTUsIDEwLCAgNSwtMzBdLFxuICAgICAgICBbLTQwLC0yMCwgIDAsICA1LCAgNSwgIDAsLTIwLC00MF0sXG4gICAgICAgIFstNTAsLTQwLC0zMCwtMzAsLTMwLC0zMCwtNDAsLTUwXVxuICAgICAgXSxcbiAgICAgIGI6IFsgLy8gQmlzaG9wc1xuICAgICAgICBbLTIwLC0xMCwtMTAsLTEwLC0xMCwtMTAsLTEwLC0yMF0sXG4gICAgICAgIFstMTAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsLTEwXSxcbiAgICAgICAgWy0xMCwgIDAsICA1LCAxMCwgMTAsICA1LCAgMCwtMTBdLFxuICAgICAgICBbLTEwLCAgNSwgIDUsIDEwLCAxMCwgIDUsICA1LC0xMF0sXG4gICAgICAgIFstMTAsICAwLCAxMCwgMTAsIDEwLCAxMCwgIDAsLTEwXSxcbiAgICAgICAgWy0xMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwtMTBdLFxuICAgICAgICBbLTEwLCAgNSwgIDAsICAwLCAgMCwgIDAsICA1LC0xMF0sXG4gICAgICAgIFstMjAsLTEwLC0xMCwtMTAsLTEwLC0xMCwtMTAsLTIwXVxuICAgICAgXVxuICAgIH07XG5cbiAgICBsZXQgc2NvcmUgPSAwO1xuICAgIGNvbnN0IGJvYXJkID0gdGhpcy5nYW1lLmJvYXJkKCk7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgIGNvbnN0IHBpZWNlVGFibGUgPSBwaWVjZVNxdWFyZVZhbHVlc1twaWVjZS50eXBlIGFzIGtleW9mIHR5cGVvZiBwaWVjZVNxdWFyZVZhbHVlc107XG4gICAgICAgICAgaWYgKHBpZWNlVGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uVmFsdWUgPSBwaWVjZVRhYmxlW3BpZWNlLmNvbG9yID09PSAndycgPyByb3cgOiA3IC0gcm93XVtjb2xdO1xuICAgICAgICAgICAgc2NvcmUgKz0gcGllY2UuY29sb3IgPT09ICd3JyA/IHBvc2l0aW9uVmFsdWUgOiAtcG9zaXRpb25WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICAvKipcbiAgICogRW5jb250cmEgbyBtZWxob3IgbW92aW1lbnRvIHBvc3PDrXZlbCBwYXJhIG8gam9nYWRvciBhdHVhbC5cbiAgICogXG4gICAqIEBwYXJhbSBkZXB0aCAtIFByb2Z1bmRpZGFkZSBtw6F4aW1hIGRlIGJ1c2NhIG5hIMOhcnZvcmUgZGUgbW92aW1lbnRvc1xuICAgKiBAcmV0dXJucyBPIG1lbGhvciBtb3ZpbWVudG8gZW5jb250cmFkbywgb3UgbnVsbCBzZSBuZW5odW0gbW92aW1lbnRvIGZvciBwb3Nzw612ZWxcbiAgICogQHRvZG8gSW1wbGVtZW50YXIgYWxnb3JpdG1vIG1pbmltYXggY29tIHBvZGEgYWxwaGEtYmV0YVxuICAgKi9cbiAgZ2V0QmVzdE1vdmUoZGVwdGg6IG51bWJlcik6IENoZXNzTW92ZSB8IG51bGwge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGJ1c2NhIG1pbmltYXggY29tIHBvZGEgYWxwaGEtYmV0YVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSBvIGhpc3TDs3JpY28gY29tcGxldG8gZGUgbW92aW1lbnRvcyBkbyBqb2dvLlxuICAgKiBcbiAgICogQHJldHVybnMgTGlzdGEgZGUgbW92aW1lbnRvcyByZWFsaXphZG9zIGRlc2RlIG8gaW7DrWNpbyBkbyBqb2dvXG4gICAqL1xuICBnZXRHYW1lSGlzdG9yeSgpOiBDaGVzc01vdmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5oaXN0b3J5KHsgdmVyYm9zZTogdHJ1ZSB9KS5tYXAobW92ZSA9PiAoe1xuICAgICAgZnJvbTogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUuZnJvbSksXG4gICAgICB0bzogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUudG8pLFxuICAgICAgcGllY2U6IHtcbiAgICAgICAgdHlwZTogbW92ZS5waWVjZSxcbiAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICB9LFxuICAgICAgY2FwdHVyZWQ6IG1vdmUuY2FwdHVyZWQgPyB7XG4gICAgICAgIHR5cGU6IG1vdmUuY2FwdHVyZWQsXG4gICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnYmxhY2snIDogJ3doaXRlJ1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHByb21vdGlvbjogbW92ZS5wcm9tb3Rpb24sXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gVmFsaWRhw6fDo29cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIHVtIG1vdmltZW50byDDqSB2w6FsaWRvIHNlbSBleGVjdXTDoS1sby5cbiAgICogXG4gICAqIEBwYXJhbSBmcm9tIC0gUG9zacOnw6NvIGluaWNpYWwgZGEgcGXDp2FcbiAgICogQHBhcmFtIHRvIC0gUG9zacOnw6NvIGZpbmFsIGRhIHBlw6dhXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBtb3ZpbWVudG8gw6kgbGVnYWwsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNWYWxpZE1vdmUoZnJvbTogQ2hlc3NQb3NpdGlvbiwgdG86IENoZXNzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgICAvLyBWYWxpZGHDp8OjbyBiw6FzaWNhIGRlIHBvc2nDp8Ojb1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUG9zaXRpb24oZnJvbSkgfHwgIXRoaXMuaXNWYWxpZFBvc2l0aW9uKHRvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhIHNlIGEgcGXDp2EgcGVydGVuY2UgYW8gam9nYWRvciBhdHVhbFxuICAgIGNvbnN0IHBpZWNlID0gdGhpcy5nYW1lLmJvYXJkKClbZnJvbS5yb3ddW2Zyb20uY29sXTtcbiAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLmNvbG9yICE9PSAodGhpcy5nZXRDdXJyZW50UGxheWVyKCkgPT09ICd3aGl0ZScgPyAndycgOiAnYicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGVudGEgZmF6ZXIgbyBtb3ZpbWVudG8gbm8gY2hlc3MuanNcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW92ZSA9IHRoaXMuZ2FtZS5tb3ZlKHtcbiAgICAgICAgZnJvbTogdGhpcy5wb3NpdGlvblRvU3F1YXJlKGZyb20pLFxuICAgICAgICB0bzogdGhpcy5wb3NpdGlvblRvU3F1YXJlKHRvKSxcbiAgICAgICAgcHJvbW90aW9uOiAncSdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobW92ZSkge1xuICAgICAgICAvLyBEZXNmYXogbyBtb3ZpbWVudG8gcGFyYSBtYW50ZXIgbyBlc3RhZG8gb3JpZ2luYWxcbiAgICAgICAgdGhpcy5nYW1lLnVuZG8oKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWdub3JhIGVycm9zIGRvIGNoZXNzLmpzXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIHVtYSBwb3Npw6fDo28gZXN0w6EgZGVudHJvIGRvcyBsaW1pdGVzIGRvIHRhYnVsZWlyby5cbiAgICogXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFBvc2nDp8OjbyBhIHNlciB2ZXJpZmljYWRhXG4gICAqIEByZXR1cm5zIHRydWUgc2UgYSBwb3Npw6fDo28gw6kgdsOhbGlkYSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc1ZhbGlkUG9zaXRpb24ocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgICByZXR1cm4gcG9zaXRpb24ucm93ID49IDAgJiYgcG9zaXRpb24ucm93IDwgOCAmJlxuICAgICAgICAgICBwb3NpdGlvbi5jb2wgPj0gMCAmJiBwb3NpdGlvbi5jb2wgPCA4O1xuICB9XG5cbiAgLy8gVXRpbGlkYWRlc1xuICAvKipcbiAgICogUmVpbmljaWEgbyBqb2dvIHBhcmEgYSBwb3Npw6fDo28gaW5pY2lhbC5cbiAgICogXG4gICAqIEBlbWl0cyB7UE9TSVRJT05fQ0hBTkdFRH0gUXVhbmRvIG8gdGFidWxlaXJvIMOpIHJlaW5pY2lhZG9cbiAgICovXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuZ2FtZS5yZXNldCgpO1xuICAgIHRoaXMucG9zaXRpb25DYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuZW1pdEV2ZW50KHsgXG4gICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsXG4gICAgICBmZW46IHRoaXMuZ2V0RkVOKClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBjw7NwaWEgaW5kZXBlbmRlbnRlIGRvIG1vdG9yIGRlIHhhZHJleiBhdHVhbC5cbiAgICogXG4gICAqIEByZXR1cm5zIFVtYSBub3ZhIGluc3TDom5jaWEgZG8gbW90b3IgY29tIG8gbWVzbW8gZXN0YWRvIGF0dWFsXG4gICAqL1xuICBjbG9uZSgpOiBDaGVzc0VuZ2luZSB7XG4gICAgY29uc3QgY2xvbmVkRW5naW5lID0gbmV3IENoZXNzRW5naW5lQmFzZSh0aGlzLm9wdGlvbnMpO1xuICAgIGNsb25lZEVuZ2luZS5zZXRGRU4odGhpcy5nZXRGRU4oKSk7XG4gICAgcmV0dXJuIGNsb25lZEVuZ2luZTtcbiAgfVxuXG4gIC8vIE3DqXRvZG9zIHByb3RlZ2lkb3MgYXV4aWxpYXJlc1xuICBwcm90ZWN0ZWQgcG9zaXRpb25Ub1NxdWFyZShwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbik6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJ2EnLmNoYXJDb2RlQXQoMCkgKyBwb3NpdGlvbi5jb2wpO1xuICAgIGNvbnN0IHJhbmsgPSA4IC0gcG9zaXRpb24ucm93O1xuICAgIHJldHVybiBgJHtmaWxlfSR7cmFua31gO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNxdWFyZVRvUG9zaXRpb24oc3F1YXJlOiBzdHJpbmcpOiBDaGVzc1Bvc2l0aW9uIHtcbiAgICBjb25zdCBjb2wgPSBzcXVhcmUuY2hhckNvZGVBdCgwKSAtICdhJy5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IHJvdyA9IDggLSBwYXJzZUludChzcXVhcmVbMV0pO1xuICAgIHJldHVybiB7IHJvdywgY29sIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgZmluZEtpbmcoY29sb3I6ICd3aGl0ZScgfCAnYmxhY2snKTogQ2hlc3NQb3NpdGlvbiB7XG4gICAgY29uc3QgYm9hcmQgPSB0aGlzLmdhbWUuYm9hcmQoKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgICAgIGlmIChwaWVjZSAmJiBcbiAgICAgICAgICAgIHBpZWNlLnR5cGUgPT09ICdrJyAmJiBcbiAgICAgICAgICAgIHBpZWNlLmNvbG9yID09PSAoY29sb3IgPT09ICd3aGl0ZScgPyAndycgOiAnYicpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcm93LCBjb2wgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tpbmcgbm90IGZvdW5kJyk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2EgbyBzdGF0dXMgZGUgc2HDumRlIGRvIG1vdG9yLlxuICAgKiBcbiAgICogQHJldHVybnMgU3RhdHVzIGF0dWFsIGRvIG1vdG9yIGluY2x1aW5kbyBtw6l0cmljYXMgZGUgZGVzZW1wZW5ob1xuICAgKi9cbiAgcHVibGljIGNoZWNrSGVhbHRoKCk6IEhlYWx0aFN0YXR1cyB7XG4gICAgcmV0dXJuIHRoaXMubW9uaXRvci5jaGVja0hlYWx0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRlIHVtIGV2ZW50byBkbyBtb3Rvci5cbiAgICogXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50byBhIHNlciBlbWl0aWRvXG4gICAqL1xuICBwcm90ZWN0ZWQgZW1pdEV2ZW50KGV2ZW50OiBFbmdpbmVFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2VuZ2luZS1ldmVudCcsIGV2ZW50KTtcbiAgICB0aGlzLm1vbml0b3IucmVjb3JkRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgLy8gTcOpdG9kb3MgZGUgYXZhbGlhw6fDo29cbiAgcHJpdmF0ZSBldmFsdWF0ZU1hdGVyaWFsKCk6IG51bWJlciB7XG4gICAgY29uc3QgcGllY2VWYWx1ZXMgPSB7XG4gICAgICBwOiAxLFxuICAgICAgbjogMyxcbiAgICAgIGI6IDMsXG4gICAgICByOiA1LFxuICAgICAgcTogOSxcbiAgICAgIGs6IDBcbiAgICB9O1xuXG4gICAgbGV0IHNjb3JlID0gMDtcbiAgICBjb25zdCBib2FyZCA9IHRoaXMuZ2FtZS5ib2FyZCgpO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDg7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbcm93XVtjb2xdO1xuICAgICAgICBpZiAocGllY2UpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBpZWNlVmFsdWVzW3BpZWNlLnR5cGUgYXMga2V5b2YgdHlwZW9mIHBpZWNlVmFsdWVzXTtcbiAgICAgICAgICBzY29yZSArPSBwaWVjZS5jb2xvciA9PT0gJ3cnID8gdmFsdWUgOiAtdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlTW9iaWxpdHkoKTogbnVtYmVyIHtcbiAgICBjb25zdCB3aGl0ZU1vdmVzID0gdGhpcy5nYW1lLm1vdmVzKCkubGVuZ3RoO1xuICAgIC8vIENsb25hIG8gam9nbyBwYXJhIHZlciBvcyBtb3ZpbWVudG9zIGRvIG9wb25lbnRlXG4gICAgY29uc3QgdGVtcEdhbWUgPSBuZXcgQ2hlc3ModGhpcy5nYW1lLmZlbigpKTtcbiAgICB0ZW1wR2FtZS5sb2FkKHRoaXMuZ2FtZS5mZW4oKS5yZXBsYWNlKCcgdyAnLCAnIGIgJykpO1xuICAgIGNvbnN0IGJsYWNrTW92ZXMgPSB0ZW1wR2FtZS5tb3ZlcygpLmxlbmd0aDtcbiAgICBcbiAgICByZXR1cm4gd2hpdGVNb3ZlcyAtIGJsYWNrTW92ZXM7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlS2luZ1NhZmV0eSgpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGF2YWxpYcOnw6NvIGRlIHNlZ3VyYW7Dp2EgZG8gcmVpXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlUGF3blN0cnVjdHVyZSgpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGF2YWxpYcOnw6NvIGRlIGVzdHJ1dHVyYSBkZSBwZcO1ZXNcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiAoZXZlbnQ6IEVuZ2luZUV2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogKGV2ZW50OiBFbmdpbmVFdmVudCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ2hlc3MiLCJBcnF1aW1heE1vbml0b3IiLCJJTklUSUFMX0ZFTiIsIkV2ZW50RW1pdHRlciIsIkNoZXNzRW5naW5lQmFzZSIsImdldEJvYXJkIiwiYm9hcmQiLCJnYW1lIiwibWFwIiwicm93Iiwic3F1YXJlIiwidHlwZSIsImNvbG9yIiwiZ2V0RkVOIiwiZmVuIiwic2V0RkVOIiwibG9hZCIsImVtaXRFdmVudCIsImUiLCJFcnJvciIsImdldFBvc3NpYmxlTW92ZXMiLCJwb3NpdGlvbiIsInBvc2l0aW9uVG9TcXVhcmUiLCJjYWNoZUtleSIsImNhY2hlSGl0IiwicG9zaXRpb25DYWNoZSIsImhhcyIsIm1vdmVzIiwiY2FjaGUiLCJnZXQiLCJiZXN0TGluZSIsInZlcmJvc2UiLCJzZXQiLCJldmFsdWF0aW9uIiwiZGVwdGgiLCJ0aHJlYXRzIiwicG9zaXRpb25hbEZlYXR1cmVzIiwicGF3blN0cnVjdHVyZSIsImtpbmdTYWZldHkiLCJtb2JpbGl0eSIsImNlbnRlckNvbnRyb2wiLCJwaWVjZUFjdGl2aXR5IiwibW9uaXRvciIsInJlY29yZENhY2hlQWNjZXNzIiwibW92ZSIsImZyb20iLCJzcXVhcmVUb1Bvc2l0aW9uIiwidG8iLCJwaWVjZSIsImNhcHR1cmVkIiwidW5kZWZpbmVkIiwicHJvbW90aW9uIiwibWFrZU1vdmUiLCJjaGVzc01vdmUiLCJpc0NoZWNrIiwia2luZ1Bvc2l0aW9uIiwiZmluZEtpbmciLCJnZXRDdXJyZW50UGxheWVyIiwiaXNHYW1lT3ZlciIsInJlc3VsdCIsImlzQ2hlY2ttYXRlIiwidW5kb0xhc3RNb3ZlIiwidW5kbyIsImlzRHJhdyIsInR1cm4iLCJldmFsdWF0ZVBvc2l0aW9uIiwid2VpZ2h0cyIsIm9wdGlvbnMiLCJldmFsdWF0aW9uUGFyYW1ldGVycyIsIm1hdGVyaWFsV2VpZ2h0IiwicG9zaXRpb25XZWlnaHQiLCJtb2JpbGl0eVdlaWdodCIsImtpbmdTYWZldHlXZWlnaHQiLCJwYXduU3RydWN0dXJlV2VpZ2h0Iiwic2NvcmUiLCJldmFsdWF0ZU1hdGVyaWFsIiwiZXZhbHVhdGVQaWVjZVBvc2l0aW9ucyIsImV2YWx1YXRlTW9iaWxpdHkiLCJldmFsdWF0ZUtpbmdTYWZldHkiLCJldmFsdWF0ZVBhd25TdHJ1Y3R1cmUiLCJwaWVjZVNxdWFyZVZhbHVlcyIsInAiLCJuIiwiYiIsImNvbCIsInBpZWNlVGFibGUiLCJwb3NpdGlvblZhbHVlIiwiZ2V0QmVzdE1vdmUiLCJnZXRHYW1lSGlzdG9yeSIsImhpc3RvcnkiLCJpc1ZhbGlkTW92ZSIsImlzVmFsaWRQb3NpdGlvbiIsInJlc2V0IiwiY2xlYXIiLCJjbG9uZSIsImNsb25lZEVuZ2luZSIsImZpbGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUF0IiwicmFuayIsInBhcnNlSW50IiwiY2hlY2tIZWFsdGgiLCJldmVudCIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJyZWNvcmRFdmVudCIsInBpZWNlVmFsdWVzIiwiciIsInEiLCJrIiwidmFsdWUiLCJ3aGl0ZU1vdmVzIiwibGVuZ3RoIiwidGVtcEdhbWUiLCJyZXBsYWNlIiwiYmxhY2tNb3ZlcyIsIm9uIiwiZXZlbnROYW1lIiwiaGFuZGxlciIsIm9mZiIsImNvbnN0cnVjdG9yIiwic3RhcnRQb3NpdGlvbiIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/shared/engine/ChessEngineBase.ts\n"));

/***/ }),

/***/ "./src/shared/engine/monitoring/ArquimaxMonitor.ts":
/*!*********************************************************!*\
  !*** ./src/shared/engine/monitoring/ArquimaxMonitor.ts ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArquimaxMonitor\": function() { return /* binding */ ArquimaxMonitor; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n/**\n * Sistema de monitoramento ARQUIMAX para o motor de xadrez.\n * \n * Responsável por:\n * - Coleta de métricas em tempo real\n * - Verificações de saúde do sistema\n * - Monitoramento de performance\n * - Logs de eventos\n */ class ArquimaxMonitor {\n    /**\n   * Registra um evento do motor de xadrez.\n   * \n   * @param event - Evento a ser registrado\n   */ recordEvent(event) {\n        this.eventEmitter.emit(\"engine-event\", event);\n        if (event.type === \"MOVE_MADE\") {\n            this.moveCount++;\n            this.updateMovesPerSecond();\n        }\n    }\n    /**\n   * Realiza verificação de saúde do sistema.\n   * \n   * @returns Status atual de saúde do sistema\n   */ checkHealth() {\n        const now = Date.now();\n        // Atualiza métricas apenas se passou o intervalo definido\n        if (now - this.lastHealthCheck >= this.healthCheckInterval) {\n            this.updateMetrics();\n            this.lastHealthCheck = now;\n        }\n        return {\n            status: this.evaluateHealth(),\n            metrics: this.metrics,\n            timestamp: now\n        };\n    }\n    /**\n   * Obtém métricas atuais do sistema.\n   * \n   * @returns Métricas coletadas\n   */ getMetrics() {\n        return {\n            ...this.metrics\n        };\n    }\n    recordCacheAccess(hit) {\n        this.cacheAccesses++;\n        if (hit) this.cacheHits++;\n        this.metrics.cacheHitRate = this.cacheHits / this.cacheAccesses;\n    }\n    /**\n   * Registra tempo de pensamento para um movimento.\n   * \n   * @param thinkingTime - Tempo em millisegundos\n   */ recordThinkingTime(thinkingTime) {\n        const current = this.metrics.averageThinkingTime;\n        this.metrics.averageThinkingTime = (current * this.moveCount + thinkingTime) / (this.moveCount + 1);\n    }\n    updateMovesPerSecond() {\n        const elapsedSeconds = (Date.now() - this.startTime) / 1000;\n        this.metrics.movesPerSecond = this.moveCount / elapsedSeconds;\n    }\n    async updateMetrics() {\n        // Atualiza uso de memória\n        if (process.memoryUsage) {\n            const { heapUsed  } = process.memoryUsage();\n            this.metrics.memoryUsage = heapUsed / 1024 / 1024; // Em MB\n        }\n        // Atualiza uso de CPU (implementação simplificada)\n        this.metrics.cpuUsage = await this.measureCPUUsage();\n    }\n    evaluateHealth() {\n        // Critérios de saúde\n        const memoryThreshold = 512; // MB\n        const cpuThreshold = 80; // %\n        const moveRateThreshold = 0.5; // moves/sec\n        if (this.metrics.memoryUsage > memoryThreshold || this.metrics.cpuUsage > cpuThreshold) {\n            return \"unhealthy\";\n        }\n        // Sistema recém iniciado está saudável por padrão\n        if (this.moveCount === 0) {\n            return \"healthy\";\n        }\n        if (this.metrics.movesPerSecond < moveRateThreshold || this.metrics.cacheHitRate < 0.3 && this.moveCount > 10) {\n            return \"degraded\";\n        }\n        return \"healthy\";\n    }\n    async measureCPUUsage() {\n        // Implementação simplificada de medição de CPU\n        // Em uma implementação real, usaríamos métricas do sistema operacional\n        return new Promise((resolve)=>{\n            setTimeout(()=>{\n                // Simula medição de CPU entre 0-100%\n                resolve(Math.random() * 100);\n            }, 100);\n        });\n    }\n    constructor(){\n        /**\n   * Registra uso de cache.\n   * \n   * @param hit - true se houve hit no cache, false se houve miss\n   */ this.cacheHits = 0;\n        this.cacheAccesses = 0;\n        this.metrics = {\n            movesPerSecond: 0,\n            averageThinkingTime: 0,\n            cacheHitRate: 0,\n            memoryUsage: 0,\n            cpuUsage: 0\n        };\n        this.eventEmitter = new events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this.startTime = Date.now();\n        this.moveCount = 0;\n        this.lastHealthCheck = Date.now();\n        this.healthCheckInterval = 5000; // 5 segundos\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9tb25pdG9yaW5nL0FycXVpbWF4TW9uaXRvci50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNDO0FBR3RDOzs7Ozs7OztDQVFDLEdBQ00sTUFBTUM7SUF1Qlg7Ozs7R0FJQyxHQUNELFlBQW1CRSxLQUFrQixFQUFRO1FBQzNDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsZ0JBQWdCRjtRQUV2QyxJQUFJQSxNQUFNRyxJQUFJLEtBQUssYUFBYTtZQUM5QixJQUFJLENBQUNDLFNBQVM7WUFDZCxJQUFJLENBQUNDLG9CQUFvQjtRQUMzQixDQUFDO0lBQ0g7SUFFQTs7OztHQUlDLEdBQ0QsY0FBbUM7UUFDakMsTUFBTUUsTUFBTUMsS0FBS0QsR0FBRztRQUVwQiwwREFBMEQ7UUFDMUQsSUFBSUEsTUFBTSxJQUFJLENBQUNFLGVBQWUsSUFBSSxJQUFJLENBQUNDLG1CQUFtQixFQUFFO1lBQzFELElBQUksQ0FBQ0MsYUFBYTtZQUNsQixJQUFJLENBQUNGLGVBQWUsR0FBR0Y7UUFDekIsQ0FBQztRQUVELE9BQU87WUFDTEssUUFBUSxJQUFJLENBQUNDLGNBQWM7WUFDM0JDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxXQUFXUjtRQUNiO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0QsYUFBbUM7UUFDakMsT0FBTztZQUFFLEdBQUcsSUFBSSxDQUFDTyxPQUFPO1FBQUM7SUFDM0I7SUFVT0csa0JBQWtCQyxHQUFZLEVBQVE7UUFDM0MsSUFBSSxDQUFDQyxhQUFhO1FBQ2xCLElBQUlELEtBQUssSUFBSSxDQUFDRSxTQUFTO1FBQ3ZCLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxZQUFZLEdBQUcsSUFBSSxDQUFDRCxTQUFTLEdBQUcsSUFBSSxDQUFDRCxhQUFhO0lBQ2pFO0lBRUE7Ozs7R0FJQyxHQUNELG1CQUEwQkksWUFBb0IsRUFBUTtRQUNwRCxNQUFNQyxVQUFVLElBQUksQ0FBQ1YsT0FBTyxDQUFDVyxtQkFBbUI7UUFDaEQsSUFBSSxDQUFDWCxPQUFPLENBQUNXLG1CQUFtQixHQUM5QixDQUFDRCxVQUFVLElBQUksQ0FBQ3BCLFNBQVMsR0FBR21CLFlBQVcsSUFBTSxLQUFJLENBQUNuQixTQUFTLEdBQUc7SUFDbEU7SUFFUUMsdUJBQTZCO1FBQ25DLE1BQU1xQixpQkFBaUIsQ0FBQ2xCLEtBQUtELEdBQUcsS0FBSyxJQUFJLENBQUNvQixTQUFTLElBQUk7UUFDdkQsSUFBSSxDQUFDYixPQUFPLENBQUNjLGNBQWMsR0FBRyxJQUFJLENBQUN4QixTQUFTLEdBQUdzQjtJQUNqRDtJQUVBLE1BQWNmLGdCQUErQjtRQUMzQywwQkFBMEI7UUFDMUIsSUFBSWtCLE9BQU9BLENBQUNDLFdBQVcsRUFBRTtZQUN2QixNQUFNLEVBQUVDLFNBQVEsRUFBRSxHQUFHRixPQUFPQSxDQUFDQyxXQUFXO1lBQ3hDLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ2dCLFdBQVcsR0FBR0MsV0FBVyxPQUFPLE1BQU0sUUFBUTtRQUM3RCxDQUFDO1FBRUQsbURBQW1EO1FBQ25ELElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ2tCLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQ0MsZUFBZTtJQUNwRDtJQUVRcEIsaUJBQXVEO1FBQzdELHFCQUFxQjtRQUNyQixNQUFNcUIsa0JBQWtCLEtBQUssS0FBSztRQUNsQyxNQUFNQyxlQUFlLElBQUksSUFBSTtRQUM3QixNQUFNQyxvQkFBb0IsS0FBSyxZQUFZO1FBRTNDLElBQ0UsSUFBSSxDQUFDdEIsT0FBTyxDQUFDZ0IsV0FBVyxHQUFHSSxtQkFDM0IsSUFBSSxDQUFDcEIsT0FBTyxDQUFDa0IsUUFBUSxHQUFHRyxjQUN4QjtZQUNBLE9BQU87UUFDVCxDQUFDO1FBRUQsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDL0IsU0FBUyxLQUFLLEdBQUc7WUFDeEIsT0FBTztRQUNULENBQUM7UUFFRCxJQUNFLElBQUksQ0FBQ1UsT0FBTyxDQUFDYyxjQUFjLEdBQUdRLHFCQUM3QixJQUFJLENBQUN0QixPQUFPLENBQUNPLFlBQVksR0FBRyxPQUFPLElBQUksQ0FBQ2pCLFNBQVMsR0FBRyxJQUNyRDtZQUNBLE9BQU87UUFDVCxDQUFDO1FBRUQsT0FBTztJQUNUO0lBRUEsTUFBYzZCLGtCQUFtQztRQUMvQywrQ0FBK0M7UUFDL0MsdUVBQXVFO1FBQ3ZFLE9BQU8sSUFBSUksUUFBUSxDQUFDQyxVQUFZO1lBQzlCQyxXQUFXLElBQU07Z0JBQ2YscUNBQXFDO2dCQUNyQ0QsUUFBUUUsS0FBS0MsTUFBTSxLQUFLO1lBQzFCLEdBQUc7UUFDTDtJQUNGO0lBeklBQyxhQUFjO1FBMkRkOzs7O0dBSUMsUUFDT3RCLFlBQW9CO2FBQ3BCRCxnQkFBd0I7UUFoRTlCLElBQUksQ0FBQ0wsT0FBTyxHQUFHO1lBQ2JjLGdCQUFnQjtZQUNoQkgscUJBQXFCO1lBQ3JCSixjQUFjO1lBQ2RTLGFBQWE7WUFDYkUsVUFBVTtRQUNaO1FBQ0EsSUFBSSxDQUFDL0IsWUFBWSxHQUFHLElBQUlKLGdEQUFZQTtRQUNwQyxJQUFJLENBQUM4QixTQUFTLEdBQUduQixLQUFLRCxHQUFHO1FBQ3pCLElBQUksQ0FBQ0gsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0ssZUFBZSxHQUFHRCxLQUFLRCxHQUFHO1FBQy9CLElBQUksQ0FBQ0csbUJBQW1CLEdBQUcsTUFBTSxhQUFhO0lBQ2hEO0FBNkhGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NoYXJlZC9lbmdpbmUvbW9uaXRvcmluZy9BcnF1aW1heE1vbml0b3IudHM/ZDgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgRW5naW5lRXZlbnQsIEVuZ2luZU1ldHJpY3MsIEhlYWx0aFN0YXR1cyB9IGZyb20gJy4uLy4uL3R5cGVzL2VuZ2luZSc7XG5cbi8qKlxuICogU2lzdGVtYSBkZSBtb25pdG9yYW1lbnRvIEFSUVVJTUFYIHBhcmEgbyBtb3RvciBkZSB4YWRyZXouXG4gKiBcbiAqIFJlc3BvbnPDoXZlbCBwb3I6XG4gKiAtIENvbGV0YSBkZSBtw6l0cmljYXMgZW0gdGVtcG8gcmVhbFxuICogLSBWZXJpZmljYcOnw7VlcyBkZSBzYcO6ZGUgZG8gc2lzdGVtYVxuICogLSBNb25pdG9yYW1lbnRvIGRlIHBlcmZvcm1hbmNlXG4gKiAtIExvZ3MgZGUgZXZlbnRvc1xuICovXG5leHBvcnQgY2xhc3MgQXJxdWltYXhNb25pdG9yIHtcbiAgcHJpdmF0ZSBtZXRyaWNzOiBFbmdpbmVNZXRyaWNzO1xuICBwcml2YXRlIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyO1xuICBwcml2YXRlIHN0YXJ0VGltZTogbnVtYmVyO1xuICBwcml2YXRlIG1vdmVDb3VudDogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RIZWFsdGhDaGVjazogbnVtYmVyO1xuICBwcml2YXRlIGhlYWx0aENoZWNrSW50ZXJ2YWw6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1ldHJpY3MgPSB7XG4gICAgICBtb3Zlc1BlclNlY29uZDogMCxcbiAgICAgIGF2ZXJhZ2VUaGlua2luZ1RpbWU6IDAsXG4gICAgICBjYWNoZUhpdFJhdGU6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMCxcbiAgICAgIGNwdVVzYWdlOiAwXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5tb3ZlQ291bnQgPSAwO1xuICAgIHRoaXMubGFzdEhlYWx0aENoZWNrID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwgPSA1MDAwOyAvLyA1IHNlZ3VuZG9zXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0cmEgdW0gZXZlbnRvIGRvIG1vdG9yIGRlIHhhZHJlei5cbiAgICogXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50byBhIHNlciByZWdpc3RyYWRvXG4gICAqL1xuICBwdWJsaWMgcmVjb3JkRXZlbnQoZXZlbnQ6IEVuZ2luZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZW5naW5lLWV2ZW50JywgZXZlbnQpO1xuICAgIFxuICAgIGlmIChldmVudC50eXBlID09PSAnTU9WRV9NQURFJykge1xuICAgICAgdGhpcy5tb3ZlQ291bnQrKztcbiAgICAgIHRoaXMudXBkYXRlTW92ZXNQZXJTZWNvbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhbGl6YSB2ZXJpZmljYcOnw6NvIGRlIHNhw7pkZSBkbyBzaXN0ZW1hLlxuICAgKiBcbiAgICogQHJldHVybnMgU3RhdHVzIGF0dWFsIGRlIHNhw7pkZSBkbyBzaXN0ZW1hXG4gICAqL1xuICBwdWJsaWMgY2hlY2tIZWFsdGgoKTogSGVhbHRoU3RhdHVzIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIEF0dWFsaXphIG3DqXRyaWNhcyBhcGVuYXMgc2UgcGFzc291IG8gaW50ZXJ2YWxvIGRlZmluaWRvXG4gICAgaWYgKG5vdyAtIHRoaXMubGFzdEhlYWx0aENoZWNrID49IHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy51cGRhdGVNZXRyaWNzKCk7XG4gICAgICB0aGlzLmxhc3RIZWFsdGhDaGVjayA9IG5vdztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiB0aGlzLmV2YWx1YXRlSGVhbHRoKCksXG4gICAgICBtZXRyaWNzOiB0aGlzLm1ldHJpY3MsXG4gICAgICB0aW1lc3RhbXA6IG5vd1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG3DqXRyaWNhcyBhdHVhaXMgZG8gc2lzdGVtYS5cbiAgICogXG4gICAqIEByZXR1cm5zIE3DqXRyaWNhcyBjb2xldGFkYXNcbiAgICovXG4gIHB1YmxpYyBnZXRNZXRyaWNzKCk6IEVuZ2luZU1ldHJpY3Mge1xuICAgIHJldHVybiB7IC4uLnRoaXMubWV0cmljcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdHJhIHVzbyBkZSBjYWNoZS5cbiAgICogXG4gICAqIEBwYXJhbSBoaXQgLSB0cnVlIHNlIGhvdXZlIGhpdCBubyBjYWNoZSwgZmFsc2Ugc2UgaG91dmUgbWlzc1xuICAgKi9cbiAgcHJpdmF0ZSBjYWNoZUhpdHM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY2FjaGVBY2Nlc3NlczogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgcmVjb3JkQ2FjaGVBY2Nlc3MoaGl0OiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZUFjY2Vzc2VzKys7XG4gICAgaWYgKGhpdCkgdGhpcy5jYWNoZUhpdHMrKztcbiAgICB0aGlzLm1ldHJpY3MuY2FjaGVIaXRSYXRlID0gdGhpcy5jYWNoZUhpdHMgLyB0aGlzLmNhY2hlQWNjZXNzZXM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0cmEgdGVtcG8gZGUgcGVuc2FtZW50byBwYXJhIHVtIG1vdmltZW50by5cbiAgICogXG4gICAqIEBwYXJhbSB0aGlua2luZ1RpbWUgLSBUZW1wbyBlbSBtaWxsaXNlZ3VuZG9zXG4gICAqL1xuICBwdWJsaWMgcmVjb3JkVGhpbmtpbmdUaW1lKHRoaW5raW5nVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMubWV0cmljcy5hdmVyYWdlVGhpbmtpbmdUaW1lO1xuICAgIHRoaXMubWV0cmljcy5hdmVyYWdlVGhpbmtpbmdUaW1lID0gXG4gICAgICAoY3VycmVudCAqIHRoaXMubW92ZUNvdW50ICsgdGhpbmtpbmdUaW1lKSAvICh0aGlzLm1vdmVDb3VudCArIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNb3Zlc1BlclNlY29uZCgpOiB2b2lkIHtcbiAgICBjb25zdCBlbGFwc2VkU2Vjb25kcyA9IChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMDtcbiAgICB0aGlzLm1ldHJpY3MubW92ZXNQZXJTZWNvbmQgPSB0aGlzLm1vdmVDb3VudCAvIGVsYXBzZWRTZWNvbmRzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVNZXRyaWNzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEF0dWFsaXphIHVzbyBkZSBtZW3Ds3JpYVxuICAgIGlmIChwcm9jZXNzLm1lbW9yeVVzYWdlKSB7XG4gICAgICBjb25zdCB7IGhlYXBVc2VkIH0gPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICB0aGlzLm1ldHJpY3MubWVtb3J5VXNhZ2UgPSBoZWFwVXNlZCAvIDEwMjQgLyAxMDI0OyAvLyBFbSBNQlxuICAgIH1cblxuICAgIC8vIEF0dWFsaXphIHVzbyBkZSBDUFUgKGltcGxlbWVudGHDp8OjbyBzaW1wbGlmaWNhZGEpXG4gICAgdGhpcy5tZXRyaWNzLmNwdVVzYWdlID0gYXdhaXQgdGhpcy5tZWFzdXJlQ1BVVXNhZ2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgZXZhbHVhdGVIZWFsdGgoKTogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknIHtcbiAgICAvLyBDcml0w6lyaW9zIGRlIHNhw7pkZVxuICAgIGNvbnN0IG1lbW9yeVRocmVzaG9sZCA9IDUxMjsgLy8gTUJcbiAgICBjb25zdCBjcHVUaHJlc2hvbGQgPSA4MDsgLy8gJVxuICAgIGNvbnN0IG1vdmVSYXRlVGhyZXNob2xkID0gMC41OyAvLyBtb3Zlcy9zZWNcblxuICAgIGlmIChcbiAgICAgIHRoaXMubWV0cmljcy5tZW1vcnlVc2FnZSA+IG1lbW9yeVRocmVzaG9sZCB8fFxuICAgICAgdGhpcy5tZXRyaWNzLmNwdVVzYWdlID4gY3B1VGhyZXNob2xkXG4gICAgKSB7XG4gICAgICByZXR1cm4gJ3VuaGVhbHRoeSc7XG4gICAgfVxuXG4gICAgLy8gU2lzdGVtYSByZWPDqW0gaW5pY2lhZG8gZXN0w6Egc2F1ZMOhdmVsIHBvciBwYWRyw6NvXG4gICAgaWYgKHRoaXMubW92ZUNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gJ2hlYWx0aHknO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMubWV0cmljcy5tb3Zlc1BlclNlY29uZCA8IG1vdmVSYXRlVGhyZXNob2xkIHx8XG4gICAgICAodGhpcy5tZXRyaWNzLmNhY2hlSGl0UmF0ZSA8IDAuMyAmJiB0aGlzLm1vdmVDb3VudCA+IDEwKVxuICAgICkge1xuICAgICAgcmV0dXJuICdkZWdyYWRlZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdoZWFsdGh5JztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbWVhc3VyZUNQVVVzYWdlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgLy8gSW1wbGVtZW50YcOnw6NvIHNpbXBsaWZpY2FkYSBkZSBtZWRpw6fDo28gZGUgQ1BVXG4gICAgLy8gRW0gdW1hIGltcGxlbWVudGHDp8OjbyByZWFsLCB1c2Fyw61hbW9zIG3DqXRyaWNhcyBkbyBzaXN0ZW1hIG9wZXJhY2lvbmFsXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gU2ltdWxhIG1lZGnDp8OjbyBkZSBDUFUgZW50cmUgMC0xMDAlXG4gICAgICAgIHJlc29sdmUoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiQXJxdWltYXhNb25pdG9yIiwicmVjb3JkRXZlbnQiLCJldmVudCIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJ0eXBlIiwibW92ZUNvdW50IiwidXBkYXRlTW92ZXNQZXJTZWNvbmQiLCJjaGVja0hlYWx0aCIsIm5vdyIsIkRhdGUiLCJsYXN0SGVhbHRoQ2hlY2siLCJoZWFsdGhDaGVja0ludGVydmFsIiwidXBkYXRlTWV0cmljcyIsInN0YXR1cyIsImV2YWx1YXRlSGVhbHRoIiwibWV0cmljcyIsInRpbWVzdGFtcCIsImdldE1ldHJpY3MiLCJyZWNvcmRDYWNoZUFjY2VzcyIsImhpdCIsImNhY2hlQWNjZXNzZXMiLCJjYWNoZUhpdHMiLCJjYWNoZUhpdFJhdGUiLCJyZWNvcmRUaGlua2luZ1RpbWUiLCJ0aGlua2luZ1RpbWUiLCJjdXJyZW50IiwiYXZlcmFnZVRoaW5raW5nVGltZSIsImVsYXBzZWRTZWNvbmRzIiwic3RhcnRUaW1lIiwibW92ZXNQZXJTZWNvbmQiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJoZWFwVXNlZCIsImNwdVVzYWdlIiwibWVhc3VyZUNQVVVzYWdlIiwibWVtb3J5VGhyZXNob2xkIiwiY3B1VGhyZXNob2xkIiwibW92ZVJhdGVUaHJlc2hvbGQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJNYXRoIiwicmFuZG9tIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shared/engine/monitoring/ArquimaxMonitor.ts\n"));

/***/ })

});