"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/shared/engine/ChessEngineBase.ts":
/*!**********************************************!*\
  !*** ./src/shared/engine/ChessEngineBase.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChessEngineBase\": function() { return /* binding */ ChessEngineBase; }\n/* harmony export */ });\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var _monitoring_ArquimaxMonitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./monitoring/ArquimaxMonitor */ \"./src/shared/engine/monitoring/ArquimaxMonitor.ts\");\n/* harmony import */ var _constants_game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/game */ \"./src/shared/constants/game.ts\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\n * Implementação base do motor de xadrez.\n * \n * Esta classe fornece a funcionalidade central para um motor de xadrez,\n * incluindo gerenciamento de estado do jogo, validação de movimentos,\n * avaliação de posição e eventos do jogo.\n * \n * @implements {ChessEngine}\n */ class ChessEngineBase {\n    // Estado do jogo\n    /**\n   * Obtém a representação atual do tabuleiro.\n   * \n   * @returns Uma matriz 8x8 representando o tabuleiro, onde cada elemento\n   * é uma peça de xadrez ou null para casas vazias.\n   */ getBoard() {\n        const board = this.game.board();\n        return board.map((row)=>row.map((square)=>square ? {\n                    type: square.type,\n                    color: square.color === \"w\" ? \"white\" : \"black\"\n                } : null));\n    }\n    /**\n   * Obtém a posição atual em notação FEN.\n   * \n   * @returns String FEN representando o estado atual do jogo\n   */ getFEN() {\n        return this.game.fen();\n    }\n    /**\n   * Define uma nova posição para o jogo usando notação FEN.\n   * \n   * @param fen - String FEN representando a nova posição\n   * @throws {Error} Se a string FEN for inválida\n   * @emits {POSITION_CHANGED} Quando a posição é alterada com sucesso\n   */ setFEN(fen) {\n        try {\n            // Na nova versão do chess.js, load() já valida o FEN\n            this.game.load(fen);\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen\n            });\n        } catch (e) {\n            throw new Error(\"Invalid FEN string\");\n        }\n    }\n    // Movimentos\n    /**\n   * Obtém todos os movimentos legais possíveis para uma peça em uma determinada posição.\n   * \n   * @param position - Posição da peça no tabuleiro\n   * @returns Lista de movimentos legais possíveis\n   */ getPossibleMoves(position) {\n        try {\n            const square = this.positionToSquare(position);\n            const cacheHit = this.positionCache.has(square);\n            const moves = this.game.moves({\n                square,\n                verbose: true\n            });\n            this.monitor.recordCacheAccess(cacheHit);\n            return moves.map((move)=>({\n                    from: this.squareToPosition(move.from),\n                    to: this.squareToPosition(move.to),\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                }));\n        } catch (e) {\n            // Se houver erro na geração de movimentos, retorna lista vazia\n            return [];\n        }\n    }\n    /**\n   * Executa um movimento no tabuleiro.\n   * \n   * @param from - Posição inicial da peça\n   * @param to - Posição final da peça\n   * @returns true se o movimento foi executado com sucesso, false caso contrário\n   * @emits {MOVE_MADE} Quando um movimento é realizado com sucesso\n   * @emits {CHECK} Quando o movimento resulta em xeque\n   * @emits {GAME_OVER} Quando o movimento resulta em fim de jogo\n   */ makeMove(from, to) {\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\" // Auto-promove para rainha por padrão\n            });\n            if (move) {\n                const chessMove = {\n                    from,\n                    to,\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                };\n                this.emitEvent({\n                    type: \"MOVE_MADE\",\n                    move: chessMove\n                });\n                if (this.isCheck()) {\n                    this.emitEvent({\n                        type: \"CHECK\",\n                        kingPosition: this.findKing(this.getCurrentPlayer())\n                    });\n                }\n                if (this.isGameOver()) {\n                    let result = \"draw\";\n                    if (this.isCheckmate()) {\n                        result = this.getCurrentPlayer() === \"white\" ? \"black\" : \"white\";\n                    }\n                    this.emitEvent({\n                        type: \"GAME_OVER\",\n                        result\n                    });\n                }\n                return true;\n            }\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n   * Desfaz o último movimento realizado.\n   * \n   * @returns true se havia um movimento para desfazer, false caso contrário\n   * @emits {POSITION_CHANGED} Quando o movimento é desfeito com sucesso\n   */ undoLastMove() {\n        const move = this.game.undo();\n        if (move) {\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen: this.getFEN()\n            });\n            return true;\n        }\n        return false;\n    }\n    // Estado do jogo\n    /**\n   * Verifica se o jogador atual está em xeque.\n   * \n   * @returns true se o jogador atual está em xeque, false caso contrário\n   */ isCheck() {\n        return this.game.isCheck();\n    }\n    /**\n   * Verifica se o jogador atual está em xeque-mate.\n   * \n   * @returns true se o jogador atual está em xeque-mate, false caso contrário\n   */ isCheckmate() {\n        return this.game.isCheckmate();\n    }\n    /**\n   * Verifica se o jogo está empatado.\n   * \n   * @returns true se o jogo está empatado, false caso contrário\n   */ isDraw() {\n        return this.game.isDraw();\n    }\n    /**\n   * Verifica se o jogo terminou (xeque-mate ou empate).\n   * \n   * @returns true se o jogo terminou, false caso contrário\n   */ isGameOver() {\n        return this.game.isGameOver();\n    }\n    /**\n   * Obtém o jogador atual.\n   * \n   * @returns 'white' para as brancas, 'black' para as pretas\n   */ getCurrentPlayer() {\n        const turn = this.game.turn();\n        return turn === \"w\" ? \"white\" : \"black\";\n    }\n    // Avaliação e análise\n    /**\n   * Avalia a posição atual do jogo.\n   * \n   * Esta função considera diversos fatores para avaliar a posição:\n   * - Material: Valor das peças presentes no tabuleiro\n   * - Posição: Qualidade do posicionamento das peças\n   * - Mobilidade: Quantidade de movimentos disponíveis\n   * - Segurança do Rei: Avaliação da proteção do rei\n   * - Estrutura de Peões: Qualidade da estrutura de peões\n   * \n   * @returns Um número que representa a avaliação da posição.\n   * Valores positivos favorecem as brancas, negativos favorecem as pretas.\n   */ evaluatePosition() {\n        // Implementação básica de avaliação\n        const weights = this.options.evaluationParameters || {\n            materialWeight: 1,\n            positionWeight: 0.1,\n            mobilityWeight: 0.1,\n            kingSafetyWeight: 0.2,\n            pawnStructureWeight: 0.1\n        };\n        let score = 0;\n        // Material\n        score += this.evaluateMaterial() * weights.materialWeight;\n        // Posição das peças\n        score += this.evaluatePiecePositions() * weights.positionWeight;\n        // Mobilidade\n        score += this.evaluateMobility() * weights.mobilityWeight;\n        // Segurança do rei\n        score += this.evaluateKingSafety() * weights.kingSafetyWeight;\n        // Estrutura de peões\n        score += this.evaluatePawnStructure() * weights.pawnStructureWeight;\n        return score;\n    }\n    evaluatePiecePositions() {\n        // Simple piece-square tables evaluation\n        const pieceSquareValues = {\n            p: [\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50\n                ],\n                [\n                    10,\n                    10,\n                    20,\n                    30,\n                    30,\n                    20,\n                    10,\n                    10\n                ],\n                [\n                    5,\n                    5,\n                    10,\n                    25,\n                    25,\n                    10,\n                    5,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    20,\n                    20,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    5,\n                    -5,\n                    -10,\n                    0,\n                    0,\n                    -10,\n                    -5,\n                    5\n                ],\n                [\n                    5,\n                    10,\n                    10,\n                    -20,\n                    -20,\n                    10,\n                    10,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            n: [\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -30,\n                    0,\n                    10,\n                    15,\n                    15,\n                    10,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    15,\n                    20,\n                    20,\n                    15,\n                    5,\n                    -30\n                ],\n                [\n                    -30,\n                    0,\n                    15,\n                    20,\n                    20,\n                    15,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    10,\n                    15,\n                    15,\n                    10,\n                    5,\n                    -30\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    5,\n                    5,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ]\n            ],\n            b: [\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ],\n                [\n                    -10,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    5,\n                    10,\n                    10,\n                    5,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    5,\n                    10,\n                    10,\n                    5,\n                    5,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    10,\n                    10,\n                    10,\n                    10,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    0,\n                    0,\n                    0,\n                    0,\n                    5,\n                    -10\n                ],\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ]\n            ]\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const pieceTable = pieceSquareValues[piece.type];\n                    if (pieceTable) {\n                        const positionValue = pieceTable[piece.color === \"w\" ? row : 7 - row][col];\n                        score += piece.color === \"w\" ? positionValue : -positionValue;\n                    }\n                }\n            }\n        }\n        return score;\n    }\n    /**\n   * Encontra o melhor movimento possível para o jogador atual.\n   * \n   * @param depth - Profundidade máxima de busca na árvore de movimentos\n   * @returns O melhor movimento encontrado, ou null se nenhum movimento for possível\n   * @todo Implementar algoritmo minimax com poda alpha-beta\n   */ getBestMove(depth) {\n        // TODO: Implementar busca minimax com poda alpha-beta\n        return null;\n    }\n    /**\n   * Obtém o histórico completo de movimentos do jogo.\n   * \n   * @returns Lista de movimentos realizados desde o início do jogo\n   */ getGameHistory() {\n        return this.game.history({\n            verbose: true\n        }).map((move)=>({\n                from: this.squareToPosition(move.from),\n                to: this.squareToPosition(move.to),\n                piece: {\n                    type: move.piece,\n                    color: move.color === \"w\" ? \"white\" : \"black\"\n                },\n                captured: move.captured ? {\n                    type: move.captured,\n                    color: move.color === \"w\" ? \"black\" : \"white\"\n                } : undefined,\n                promotion: move.promotion\n            }));\n    }\n    // Validação\n    /**\n   * Verifica se um movimento é válido sem executá-lo.\n   * \n   * @param from - Posição inicial da peça\n   * @param to - Posição final da peça\n   * @returns true se o movimento é legal, false caso contrário\n   */ isValidMove(from, to) {\n        // Validação básica de posição\n        if (!this.isValidPosition(from) || !this.isValidPosition(to)) {\n            return false;\n        }\n        // Verifica se a peça pertence ao jogador atual\n        const piece = this.game.board()[from.row][from.col];\n        if (!piece || piece.color !== (this.getCurrentPlayer() === \"white\" ? \"w\" : \"b\")) {\n            return false;\n        }\n        // Tenta fazer o movimento no chess.js\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\"\n            });\n            if (move) {\n                // Desfaz o movimento para manter o estado original\n                this.game.undo();\n                return true;\n            }\n        } catch (e) {\n        // Ignora erros do chess.js\n        }\n        return false;\n    }\n    /**\n   * Verifica se uma posição está dentro dos limites do tabuleiro.\n   * \n   * @param position - Posição a ser verificada\n   * @returns true se a posição é válida, false caso contrário\n   */ isValidPosition(position) {\n        return position.row >= 0 && position.row < 8 && position.col >= 0 && position.col < 8;\n    }\n    // Utilidades\n    /**\n   * Reinicia o jogo para a posição inicial.\n   * \n   * @emits {POSITION_CHANGED} Quando o tabuleiro é reiniciado\n   */ reset() {\n        this.game.reset();\n        this.positionCache.clear();\n        this.emitEvent({\n            type: \"POSITION_CHANGED\",\n            fen: this.getFEN()\n        });\n    }\n    /**\n   * Cria uma cópia independente do motor de xadrez atual.\n   * \n   * @returns Uma nova instância do motor com o mesmo estado atual\n   */ clone() {\n        const clonedEngine = new ChessEngineBase(this.options);\n        clonedEngine.setFEN(this.getFEN());\n        return clonedEngine;\n    }\n    // Métodos protegidos auxiliares\n    positionToSquare(position) {\n        const file = String.fromCharCode(\"a\".charCodeAt(0) + position.col);\n        const rank = 8 - position.row;\n        return \"\".concat(file).concat(rank);\n    }\n    squareToPosition(square) {\n        const col = square.charCodeAt(0) - \"a\".charCodeAt(0);\n        const row = 8 - parseInt(square[1]);\n        return {\n            row,\n            col\n        };\n    }\n    findKing(color) {\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece && piece.type === \"k\" && piece.color === (color === \"white\" ? \"w\" : \"b\")) {\n                    return {\n                        row,\n                        col\n                    };\n                }\n            }\n        }\n        throw new Error(\"King not found\");\n    }\n    /**\n   * Verifica o status de saúde do motor.\n   * \n   * @returns Status atual do motor incluindo métricas de desempenho\n   */ checkHealth() {\n        return this.monitor.checkHealth();\n    }\n    /**\n   * Emite um evento do motor.\n   * \n   * @param event - Evento a ser emitido\n   */ emitEvent(event) {\n        this.eventEmitter.emit(\"engine-event\", event);\n        this.monitor.recordEvent(event);\n    }\n    // Métodos de avaliação\n    evaluateMaterial() {\n        const pieceValues = {\n            p: 1,\n            n: 3,\n            b: 3,\n            r: 5,\n            q: 9,\n            k: 0\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const value = pieceValues[piece.type];\n                    score += piece.color === \"w\" ? value : -value;\n                }\n            }\n        }\n        return score;\n    }\n    evaluateMobility() {\n        const whiteMoves = this.game.moves().length;\n        // Clona o jogo para ver os movimentos do oponente\n        const tempGame = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(this.game.fen());\n        tempGame.load(this.game.fen().replace(\" w \", \" b \"));\n        const blackMoves = tempGame.moves().length;\n        return whiteMoves - blackMoves;\n    }\n    evaluateKingSafety() {\n        // TODO: Implementar avaliação de segurança do rei\n        return 0;\n    }\n    evaluatePawnStructure() {\n        // TODO: Implementar avaliação de estrutura de peões\n        return 0;\n    }\n    // Event handlers\n    on(eventName, handler) {\n        this.eventEmitter.on(eventName, handler);\n    }\n    off(eventName, handler) {\n        this.eventEmitter.off(eventName, handler);\n    }\n    /**\n   * Cria uma nova instância do motor de xadrez.\n   * \n   * @param options - Opções de configuração do motor\n   * @param options.startPosition - Posição inicial em notação FEN (opcional)\n   * @param options.evaluationParameters - Parâmetros para avaliação de posição (opcional)\n   */ constructor(options = {}){\n        this.game = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(options.startPosition || _constants_game__WEBPACK_IMPORTED_MODULE_2__.INITIAL_FEN);\n        this.options = options;\n        this.eventEmitter = new events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n        this.positionCache = new Map();\n        this.monitor = new _monitoring_ArquimaxMonitor__WEBPACK_IMPORTED_MODULE_1__.ArquimaxMonitor();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBYzhCO0FBQ2Y7QUFDVjtBQUV0Qzs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1JO0lBOEJYLGlCQUFpQjtJQUNqQjs7Ozs7R0FLQyxHQUNEQyxXQUEyQjtRQUN6QixNQUFNQyxRQUFRLElBQUksQ0FBQ0MsSUFBSSxDQUFDRCxLQUFLO1FBQzdCLE9BQU9BLE1BQU1FLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFDZkEsSUFBSUQsR0FBRyxDQUFDRSxDQUFBQSxTQUNOQSxTQUFTO29CQUNQQyxNQUFNRCxPQUFPQyxJQUFJO29CQUNqQkMsT0FBT0YsT0FBT0UsS0FBSyxLQUFLLE1BQU0sVUFBVSxPQUFPO2dCQUNqRCxJQUFJLElBQUk7SUFHZDtJQUVBOzs7O0dBSUMsR0FDREMsU0FBaUI7UUFDZixPQUFPLElBQUksQ0FBQ04sSUFBSSxDQUFDTyxHQUFHO0lBQ3RCO0lBRUE7Ozs7OztHQU1DLEdBQ0RDLE9BQU9ELEdBQVcsRUFBUTtRQUN4QixJQUFJO1lBQ0YscURBQXFEO1lBQ3JELElBQUksQ0FBQ1AsSUFBSSxDQUFDUyxJQUFJLENBQUNGO1lBQ2YsSUFBSSxDQUFDRyxTQUFTLENBQUM7Z0JBQ2JOLE1BQU07Z0JBQ05HO1lBQ0Y7UUFDRixFQUFFLE9BQU9JLEdBQUc7WUFDVixNQUFNLElBQUlDLE1BQU0sc0JBQXNCO1FBQ3hDO0lBQ0Y7SUFFQSxhQUFhO0lBQ2I7Ozs7O0dBS0MsR0FDREMsaUJBQWlCQyxRQUF1QixFQUFlO1FBQ3JELElBQUk7WUFDRixNQUFNWCxTQUFTLElBQUksQ0FBQ1ksZ0JBQWdCLENBQUNEO1lBQ3JDLE1BQU1FLFdBQVcsSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ2Y7WUFDeEMsTUFBTWdCLFFBQVEsSUFBSSxDQUFDbkIsSUFBSSxDQUFDbUIsS0FBSyxDQUFDO2dCQUM1QmhCO2dCQUNBaUIsU0FBUyxJQUFJO1lBQ2Y7WUFD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b0JBQUs7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBRztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSztvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFHLENBQUM7b0JBQUs7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUUsQ0FBQztvQkFBRyxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7aUJBQUc7YUFDbEM7WUFDREMsR0FBRztnQkFDRDtvQkFBQyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUs7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBSTtvQkFBRztvQkFBSTtvQkFBSztvQkFBSTtvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFJO29CQUFHO29CQUFJO29CQUFLO29CQUFJO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUs7b0JBQUc7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUs7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBRyxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENB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QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHM/ZjI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzcyB9IGZyb20gJ2NoZXNzLmpzJztcbmltcG9ydCB7IFxuICBDaGVzc0VuZ2luZSwgXG4gIEVuZ2luZU9wdGlvbnMsIFxuICBFbmdpbmVBbmFseXNpcyxcbiAgRW5naW5lRXZlbnQsXG4gIEhlYWx0aFN0YXR1c1xufSBmcm9tICcuLi90eXBlcy9lbmdpbmUnO1xuaW1wb3J0IHsgXG4gIENoZXNzUG9zaXRpb24sIFxuICBDaGVzc1BpZWNlLCBcbiAgQ2hlc3NNb3ZlLFxuICBQaWVjZVR5cGVcbn0gZnJvbSAnLi4vdHlwZXMvY2hlc3MnO1xuaW1wb3J0IHsgQXJxdWltYXhNb25pdG9yIH0gZnJvbSAnLi9tb25pdG9yaW5nL0FycXVpbWF4TW9uaXRvcic7XG5pbXBvcnQgeyBJTklUSUFMX0ZFTiB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogSW1wbGVtZW50YcOnw6NvIGJhc2UgZG8gbW90b3IgZGUgeGFkcmV6LlxuICogXG4gKiBFc3RhIGNsYXNzZSBmb3JuZWNlIGEgZnVuY2lvbmFsaWRhZGUgY2VudHJhbCBwYXJhIHVtIG1vdG9yIGRlIHhhZHJleixcbiAqIGluY2x1aW5kbyBnZXJlbmNpYW1lbnRvIGRlIGVzdGFkbyBkbyBqb2dvLCB2YWxpZGHDp8OjbyBkZSBtb3ZpbWVudG9zLFxuICogYXZhbGlhw6fDo28gZGUgcG9zacOnw6NvIGUgZXZlbnRvcyBkbyBqb2dvLlxuICogXG4gKiBAaW1wbGVtZW50cyB7Q2hlc3NFbmdpbmV9XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVzc0VuZ2luZUJhc2UgaW1wbGVtZW50cyBDaGVzc0VuZ2luZSB7XG4gIC8qKiBJbnN0w6JuY2lhIGRvIGNoZXNzLmpzIHF1ZSBnZXJlbmNpYSBhcyByZWdyYXMgZSBlc3RhZG8gZG8gam9nbyAqL1xuICBwcm90ZWN0ZWQgZ2FtZTogQ2hlc3M7XG5cbiAgLyoqIE9ww6fDtWVzIGRlIGNvbmZpZ3VyYcOnw6NvIGRvIG1vdG9yICovXG4gIHByb3RlY3RlZCBvcHRpb25zOiBFbmdpbmVPcHRpb25zO1xuXG4gIC8qKiBFbWlzc29yIGRlIGV2ZW50b3MgcGFyYSBub3RpZmljYXIgbXVkYW7Dp2FzIG5vIGVzdGFkbyBkbyBqb2dvICovXG4gIHByb3RlY3RlZCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuICAvKiogQ2FjaGUgZGUgYW7DoWxpc2VzIGRlIHBvc2nDp8OjbyBwYXJhIG90aW1pemHDp8OjbyAqL1xuICBwcm90ZWN0ZWQgcG9zaXRpb25DYWNoZTogTWFwPHN0cmluZywgRW5naW5lQW5hbHlzaXM+O1xuXG4gIHByaXZhdGUgbW9uaXRvcjogQXJxdWltYXhNb25pdG9yO1xuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBub3ZhIGluc3TDom5jaWEgZG8gbW90b3IgZGUgeGFkcmV6LlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcMOnw7VlcyBkZSBjb25maWd1cmHDp8OjbyBkbyBtb3RvclxuICAgKiBAcGFyYW0gb3B0aW9ucy5zdGFydFBvc2l0aW9uIC0gUG9zacOnw6NvIGluaWNpYWwgZW0gbm90YcOnw6NvIEZFTiAob3BjaW9uYWwpXG4gICAqIEBwYXJhbSBvcHRpb25zLmV2YWx1YXRpb25QYXJhbWV0ZXJzIC0gUGFyw6JtZXRyb3MgcGFyYSBhdmFsaWHDp8OjbyBkZSBwb3Npw6fDo28gKG9wY2lvbmFsKVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRW5naW5lT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5nYW1lID0gbmV3IENoZXNzKG9wdGlvbnMuc3RhcnRQb3NpdGlvbiB8fCBJTklUSUFMX0ZFTik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnBvc2l0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tb25pdG9yID0gbmV3IEFycXVpbWF4TW9uaXRvcigpO1xuICB9XG5cbiAgLy8gRXN0YWRvIGRvIGpvZ29cbiAgLyoqXG4gICAqIE9idMOpbSBhIHJlcHJlc2VudGHDp8OjbyBhdHVhbCBkbyB0YWJ1bGVpcm8uXG4gICAqIFxuICAgKiBAcmV0dXJucyBVbWEgbWF0cml6IDh4OCByZXByZXNlbnRhbmRvIG8gdGFidWxlaXJvLCBvbmRlIGNhZGEgZWxlbWVudG9cbiAgICogw6kgdW1hIHBlw6dhIGRlIHhhZHJleiBvdSBudWxsIHBhcmEgY2FzYXMgdmF6aWFzLlxuICAgKi9cbiAgZ2V0Qm9hcmQoKTogQ2hlc3NQaWVjZVtdW10ge1xuICAgIGNvbnN0IGJvYXJkID0gdGhpcy5nYW1lLmJvYXJkKCk7XG4gICAgcmV0dXJuIGJvYXJkLm1hcChyb3cgPT4gXG4gICAgICByb3cubWFwKHNxdWFyZSA9PiBcbiAgICAgICAgc3F1YXJlID8ge1xuICAgICAgICAgIHR5cGU6IHNxdWFyZS50eXBlIGFzIFBpZWNlVHlwZSxcbiAgICAgICAgICBjb2xvcjogc3F1YXJlLmNvbG9yID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgICB9IDogbnVsbFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIGEgcG9zacOnw6NvIGF0dWFsIGVtIG5vdGHDp8OjbyBGRU4uXG4gICAqIFxuICAgKiBAcmV0dXJucyBTdHJpbmcgRkVOIHJlcHJlc2VudGFuZG8gbyBlc3RhZG8gYXR1YWwgZG8gam9nb1xuICAgKi9cbiAgZ2V0RkVOKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5mZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgdW1hIG5vdmEgcG9zacOnw6NvIHBhcmEgbyBqb2dvIHVzYW5kbyBub3Rhw6fDo28gRkVOLlxuICAgKiBcbiAgICogQHBhcmFtIGZlbiAtIFN0cmluZyBGRU4gcmVwcmVzZW50YW5kbyBhIG5vdmEgcG9zacOnw6NvXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBTZSBhIHN0cmluZyBGRU4gZm9yIGludsOhbGlkYVxuICAgKiBAZW1pdHMge1BPU0lUSU9OX0NIQU5HRUR9IFF1YW5kbyBhIHBvc2nDp8OjbyDDqSBhbHRlcmFkYSBjb20gc3VjZXNzb1xuICAgKi9cbiAgc2V0RkVOKGZlbjogc3RyaW5nKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5hIG5vdmEgdmVyc8OjbyBkbyBjaGVzcy5qcywgbG9hZCgpIGrDoSB2YWxpZGEgbyBGRU5cbiAgICAgIHRoaXMuZ2FtZS5sb2FkKGZlbik7XG4gICAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsIFxuICAgICAgICBmZW4gXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRkVOIHN0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmltZW50b3NcbiAgLyoqXG4gICAqIE9idMOpbSB0b2RvcyBvcyBtb3ZpbWVudG9zIGxlZ2FpcyBwb3Nzw612ZWlzIHBhcmEgdW1hIHBlw6dhIGVtIHVtYSBkZXRlcm1pbmFkYSBwb3Npw6fDo28uXG4gICAqIFxuICAgKiBAcGFyYW0gcG9zaXRpb24gLSBQb3Npw6fDo28gZGEgcGXDp2Egbm8gdGFidWxlaXJvXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIG1vdmltZW50b3MgbGVnYWlzIHBvc3PDrXZlaXNcbiAgICovXG4gIGdldFBvc3NpYmxlTW92ZXMocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBDaGVzc01vdmVbXSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMucG9zaXRpb25Ub1NxdWFyZShwb3NpdGlvbik7XG4gICAgICBjb25zdCBjYWNoZUhpdCA9IHRoaXMucG9zaXRpb25DYWNoZS5oYXMoc3F1YXJlKTtcbiAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5nYW1lLm1vdmVzKHsgXG4gICAgICAgIHNxdWFyZSxcbiAgICAgICAgdmVyYm9zZTogdHJ1ZSBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb25pdG9yLnJlY29yZENhY2hlQWNjZXNzKGNhY2hlSGl0KTtcblxuICAgICAgcmV0dXJuIG1vdmVzLm1hcChtb3ZlID0+ICh7XG4gICAgICAgIGZyb206IHRoaXMuc3F1YXJlVG9Qb3NpdGlvbihtb3ZlLmZyb20pLFxuICAgICAgICB0bzogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUudG8pLFxuICAgICAgICBwaWVjZToge1xuICAgICAgICAgIHR5cGU6IG1vdmUucGllY2UgYXMgUGllY2VUeXBlLFxuICAgICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgICB9LFxuICAgICAgICBjYXB0dXJlZDogbW92ZS5jYXB0dXJlZCA/IHtcbiAgICAgICAgICB0eXBlOiBtb3ZlLmNhcHR1cmVkIGFzIFBpZWNlVHlwZSxcbiAgICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ2JsYWNrJyA6ICd3aGl0ZSdcbiAgICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJvbW90aW9uOiBtb3ZlLnByb21vdGlvbiBhcyBQaWVjZVR5cGUgfCB1bmRlZmluZWQsXG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gU2UgaG91dmVyIGVycm8gbmEgZ2VyYcOnw6NvIGRlIG1vdmltZW50b3MsIHJldG9ybmEgbGlzdGEgdmF6aWFcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0YSB1bSBtb3ZpbWVudG8gbm8gdGFidWxlaXJvLlxuICAgKiBcbiAgICogQHBhcmFtIGZyb20gLSBQb3Npw6fDo28gaW5pY2lhbCBkYSBwZcOnYVxuICAgKiBAcGFyYW0gdG8gLSBQb3Npw6fDo28gZmluYWwgZGEgcGXDp2FcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIG1vdmltZW50byBmb2kgZXhlY3V0YWRvIGNvbSBzdWNlc3NvLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICogQGVtaXRzIHtNT1ZFX01BREV9IFF1YW5kbyB1bSBtb3ZpbWVudG8gw6kgcmVhbGl6YWRvIGNvbSBzdWNlc3NvXG4gICAqIEBlbWl0cyB7Q0hFQ0t9IFF1YW5kbyBvIG1vdmltZW50byByZXN1bHRhIGVtIHhlcXVlXG4gICAqIEBlbWl0cyB7R0FNRV9PVkVSfSBRdWFuZG8gbyBtb3ZpbWVudG8gcmVzdWx0YSBlbSBmaW0gZGUgam9nb1xuICAgKi9cbiAgbWFrZU1vdmUoZnJvbTogQ2hlc3NQb3NpdGlvbiwgdG86IENoZXNzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW92ZSA9IHRoaXMuZ2FtZS5tb3ZlKHtcbiAgICAgICAgZnJvbTogdGhpcy5wb3NpdGlvblRvU3F1YXJlKGZyb20pLFxuICAgICAgICB0bzogdGhpcy5wb3NpdGlvblRvU3F1YXJlKHRvKSxcbiAgICAgICAgcHJvbW90aW9uOiAncScgLy8gQXV0by1wcm9tb3ZlIHBhcmEgcmFpbmhhIHBvciBwYWRyw6NvXG4gICAgICB9KTtcblxuICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgY29uc3QgY2hlc3NNb3ZlOiBDaGVzc01vdmUgPSB7XG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICBwaWVjZToge1xuICAgICAgICAgICAgdHlwZTogbW92ZS5waWVjZSxcbiAgICAgICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZWQ6IG1vdmUuY2FwdHVyZWQgPyB7XG4gICAgICAgICAgICB0eXBlOiBtb3ZlLmNhcHR1cmVkLFxuICAgICAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICdibGFjaycgOiAnd2hpdGUnXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwcm9tb3Rpb246IG1vdmUucHJvbW90aW9uLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHsgdHlwZTogJ01PVkVfTUFERScsIG1vdmU6IGNoZXNzTW92ZSB9KTtcblxuICAgICAgICBpZiAodGhpcy5pc0NoZWNrKCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgICAgICAgdHlwZTogJ0NIRUNLJyxcbiAgICAgICAgICAgIGtpbmdQb3NpdGlvbjogdGhpcy5maW5kS2luZyh0aGlzLmdldEN1cnJlbnRQbGF5ZXIoKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzR2FtZU92ZXIoKSkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSAnZHJhdyc7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXRDdXJyZW50UGxheWVyKCkgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0RXZlbnQoeyB0eXBlOiAnR0FNRV9PVkVSJywgcmVzdWx0IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNmYXogbyDDumx0aW1vIG1vdmltZW50byByZWFsaXphZG8uXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIGhhdmlhIHVtIG1vdmltZW50byBwYXJhIGRlc2ZhemVyLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICogQGVtaXRzIHtQT1NJVElPTl9DSEFOR0VEfSBRdWFuZG8gbyBtb3ZpbWVudG8gw6kgZGVzZmVpdG8gY29tIHN1Y2Vzc29cbiAgICovXG4gIHVuZG9MYXN0TW92ZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBtb3ZlID0gdGhpcy5nYW1lLnVuZG8oKTtcbiAgICBpZiAobW92ZSkge1xuICAgICAgdGhpcy5lbWl0RXZlbnQoeyBcbiAgICAgICAgdHlwZTogJ1BPU0lUSU9OX0NIQU5HRUQnLFxuICAgICAgICBmZW46IHRoaXMuZ2V0RkVOKClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVzdGFkbyBkbyBqb2dvXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIGpvZ2Fkb3IgYXR1YWwgZXN0w6EgZW0geGVxdWUuXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gam9nYWRvciBhdHVhbCBlc3TDoSBlbSB4ZXF1ZSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc0NoZWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdhbWUuaXNDaGVjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gam9nYWRvciBhdHVhbCBlc3TDoSBlbSB4ZXF1ZS1tYXRlLlxuICAgKiBcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIGpvZ2Fkb3IgYXR1YWwgZXN0w6EgZW0geGVxdWUtbWF0ZSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc0NoZWNrbWF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nYW1lLmlzQ2hlY2ttYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyBqb2dvIGVzdMOhIGVtcGF0YWRvLlxuICAgKiBcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIGpvZ28gZXN0w6EgZW1wYXRhZG8sIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNEcmF3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdhbWUuaXNEcmF3KCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyBqb2dvIHRlcm1pbm91ICh4ZXF1ZS1tYXRlIG91IGVtcGF0ZSkuXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gam9nbyB0ZXJtaW5vdSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc0dhbWVPdmVyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdhbWUuaXNHYW1lT3ZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSBvIGpvZ2Fkb3IgYXR1YWwuXG4gICAqIFxuICAgKiBAcmV0dXJucyAnd2hpdGUnIHBhcmEgYXMgYnJhbmNhcywgJ2JsYWNrJyBwYXJhIGFzIHByZXRhc1xuICAgKi9cbiAgZ2V0Q3VycmVudFBsYXllcigpOiAnd2hpdGUnIHwgJ2JsYWNrJyB7XG4gICAgY29uc3QgdHVybiA9IHRoaXMuZ2FtZS50dXJuKCk7XG4gICAgcmV0dXJuIHR1cm4gPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snO1xuICB9XG5cbiAgLy8gQXZhbGlhw6fDo28gZSBhbsOhbGlzZVxuICAvKipcbiAgICogQXZhbGlhIGEgcG9zacOnw6NvIGF0dWFsIGRvIGpvZ28uXG4gICAqIFxuICAgKiBFc3RhIGZ1bsOnw6NvIGNvbnNpZGVyYSBkaXZlcnNvcyBmYXRvcmVzIHBhcmEgYXZhbGlhciBhIHBvc2nDp8OjbzpcbiAgICogLSBNYXRlcmlhbDogVmFsb3IgZGFzIHBlw6dhcyBwcmVzZW50ZXMgbm8gdGFidWxlaXJvXG4gICAqIC0gUG9zacOnw6NvOiBRdWFsaWRhZGUgZG8gcG9zaWNpb25hbWVudG8gZGFzIHBlw6dhc1xuICAgKiAtIE1vYmlsaWRhZGU6IFF1YW50aWRhZGUgZGUgbW92aW1lbnRvcyBkaXNwb27DrXZlaXNcbiAgICogLSBTZWd1cmFuw6dhIGRvIFJlaTogQXZhbGlhw6fDo28gZGEgcHJvdGXDp8OjbyBkbyByZWlcbiAgICogLSBFc3RydXR1cmEgZGUgUGXDtWVzOiBRdWFsaWRhZGUgZGEgZXN0cnV0dXJhIGRlIHBlw7Vlc1xuICAgKiBcbiAgICogQHJldHVybnMgVW0gbsO6bWVybyBxdWUgcmVwcmVzZW50YSBhIGF2YWxpYcOnw6NvIGRhIHBvc2nDp8Ojby5cbiAgICogVmFsb3JlcyBwb3NpdGl2b3MgZmF2b3JlY2VtIGFzIGJyYW5jYXMsIG5lZ2F0aXZvcyBmYXZvcmVjZW0gYXMgcHJldGFzLlxuICAgKi9cbiAgZXZhbHVhdGVQb3NpdGlvbigpOiBudW1iZXIge1xuICAgIC8vIEltcGxlbWVudGHDp8OjbyBiw6FzaWNhIGRlIGF2YWxpYcOnw6NvXG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMub3B0aW9ucy5ldmFsdWF0aW9uUGFyYW1ldGVycyB8fCB7XG4gICAgICBtYXRlcmlhbFdlaWdodDogMSxcbiAgICAgIHBvc2l0aW9uV2VpZ2h0OiAwLjEsXG4gICAgICBtb2JpbGl0eVdlaWdodDogMC4xLFxuICAgICAga2luZ1NhZmV0eVdlaWdodDogMC4yLFxuICAgICAgcGF3blN0cnVjdHVyZVdlaWdodDogMC4xXG4gICAgfTtcblxuICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAvLyBNYXRlcmlhbFxuICAgIHNjb3JlICs9IHRoaXMuZXZhbHVhdGVNYXRlcmlhbCgpICogd2VpZ2h0cy5tYXRlcmlhbFdlaWdodDtcblxuICAgIC8vIFBvc2nDp8OjbyBkYXMgcGXDp2FzXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZVBpZWNlUG9zaXRpb25zKCkgKiB3ZWlnaHRzLnBvc2l0aW9uV2VpZ2h0O1xuXG4gICAgLy8gTW9iaWxpZGFkZVxuICAgIHNjb3JlICs9IHRoaXMuZXZhbHVhdGVNb2JpbGl0eSgpICogd2VpZ2h0cy5tb2JpbGl0eVdlaWdodDtcblxuICAgIC8vIFNlZ3VyYW7Dp2EgZG8gcmVpXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZUtpbmdTYWZldHkoKSAqIHdlaWdodHMua2luZ1NhZmV0eVdlaWdodDtcblxuICAgIC8vIEVzdHJ1dHVyYSBkZSBwZcO1ZXNcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlUGF3blN0cnVjdHVyZSgpICogd2VpZ2h0cy5wYXduU3RydWN0dXJlV2VpZ2h0O1xuXG4gICAgcmV0dXJuIHNjb3JlO1xuICB9XG5cbiAgcHJpdmF0ZSBldmFsdWF0ZVBpZWNlUG9zaXRpb25zKCk6IG51bWJlciB7XG4gICAgLy8gU2ltcGxlIHBpZWNlLXNxdWFyZSB0YWJsZXMgZXZhbHVhdGlvblxuICAgIGNvbnN0IHBpZWNlU3F1YXJlVmFsdWVzID0ge1xuICAgICAgcDogWyAvLyBQYXduc1xuICAgICAgICBbMCwgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDBdLFxuICAgICAgICBbNTAsIDUwLCA1MCwgNTAsIDUwLCA1MCwgNTAsIDUwXSxcbiAgICAgICAgWzEwLCAxMCwgMjAsIDMwLCAzMCwgMjAsIDEwLCAxMF0sXG4gICAgICAgIFs1LCAgNSwgMTAsIDI1LCAyNSwgMTAsICA1LCAgNV0sXG4gICAgICAgIFswLCAgMCwgIDAsIDIwLCAyMCwgIDAsICAwLCAgMF0sXG4gICAgICAgIFs1LCAtNSwtMTAsICAwLCAgMCwtMTAsIC01LCAgNV0sXG4gICAgICAgIFs1LCAxMCwgMTAsLTIwLC0yMCwgMTAsIDEwLCAgNV0sXG4gICAgICAgIFswLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLCAgMF1cbiAgICAgIF0sXG4gICAgICBuOiBbIC8vIEtuaWdodHNcbiAgICAgICAgWy01MCwtNDAsLTMwLC0zMCwtMzAsLTMwLC00MCwtNTBdLFxuICAgICAgICBbLTQwLC0yMCwgIDAsICAwLCAgMCwgIDAsLTIwLC00MF0sXG4gICAgICAgIFstMzAsICAwLCAxMCwgMTUsIDE1LCAxMCwgIDAsLTMwXSxcbiAgICAgICAgWy0zMCwgIDUsIDE1LCAyMCwgMjAsIDE1LCAgNSwtMzBdLFxuICAgICAgICBbLTMwLCAgMCwgMTUsIDIwLCAyMCwgMTUsICAwLC0zMF0sXG4gICAgICAgIFstMzAsICA1LCAxMCwgMTUsIDE1LCAxMCwgIDUsLTMwXSxcbiAgICAgICAgWy00MCwtMjAsICAwLCAgNSwgIDUsICAwLC0yMCwtNDBdLFxuICAgICAgICBbLTUwLC00MCwtMzAsLTMwLC0zMCwtMzAsLTQwLC01MF1cbiAgICAgIF0sXG4gICAgICBiOiBbIC8vIEJpc2hvcHNcbiAgICAgICAgWy0yMCwtMTAsLTEwLC0xMCwtMTAsLTEwLC0xMCwtMjBdLFxuICAgICAgICBbLTEwLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLC0xMF0sXG4gICAgICAgIFstMTAsICAwLCAgNSwgMTAsIDEwLCAgNSwgIDAsLTEwXSxcbiAgICAgICAgWy0xMCwgIDUsICA1LCAxMCwgMTAsICA1LCAgNSwtMTBdLFxuICAgICAgICBbLTEwLCAgMCwgMTAsIDEwLCAxMCwgMTAsICAwLC0xMF0sXG4gICAgICAgIFstMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsLTEwXSxcbiAgICAgICAgWy0xMCwgIDUsICAwLCAgMCwgIDAsICAwLCAgNSwtMTBdLFxuICAgICAgICBbLTIwLC0xMCwtMTAsLTEwLC0xMCwtMTAsLTEwLC0yMF1cbiAgICAgIF1cbiAgICB9O1xuXG4gICAgbGV0IHNjb3JlID0gMDtcbiAgICBjb25zdCBib2FyZCA9IHRoaXMuZ2FtZS5ib2FyZCgpO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDg7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbcm93XVtjb2xdO1xuICAgICAgICBpZiAocGllY2UpIHtcbiAgICAgICAgICBjb25zdCBwaWVjZVRhYmxlID0gcGllY2VTcXVhcmVWYWx1ZXNbcGllY2UudHlwZSBhcyBrZXlvZiB0eXBlb2YgcGllY2VTcXVhcmVWYWx1ZXNdO1xuICAgICAgICAgIGlmIChwaWVjZVRhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvblZhbHVlID0gcGllY2VUYWJsZVtwaWVjZS5jb2xvciA9PT0gJ3cnID8gcm93IDogNyAtIHJvd11bY29sXTtcbiAgICAgICAgICAgIHNjb3JlICs9IHBpZWNlLmNvbG9yID09PSAndycgPyBwb3NpdGlvblZhbHVlIDogLXBvc2l0aW9uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3JlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29udHJhIG8gbWVsaG9yIG1vdmltZW50byBwb3Nzw612ZWwgcGFyYSBvIGpvZ2Fkb3IgYXR1YWwuXG4gICAqIFxuICAgKiBAcGFyYW0gZGVwdGggLSBQcm9mdW5kaWRhZGUgbcOheGltYSBkZSBidXNjYSBuYSDDoXJ2b3JlIGRlIG1vdmltZW50b3NcbiAgICogQHJldHVybnMgTyBtZWxob3IgbW92aW1lbnRvIGVuY29udHJhZG8sIG91IG51bGwgc2UgbmVuaHVtIG1vdmltZW50byBmb3IgcG9zc8OtdmVsXG4gICAqIEB0b2RvIEltcGxlbWVudGFyIGFsZ29yaXRtbyBtaW5pbWF4IGNvbSBwb2RhIGFscGhhLWJldGFcbiAgICovXG4gIGdldEJlc3RNb3ZlKGRlcHRoOiBudW1iZXIpOiBDaGVzc01vdmUgfCBudWxsIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnRhciBidXNjYSBtaW5pbWF4IGNvbSBwb2RhIGFscGhhLWJldGFcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnTDqW0gbyBoaXN0w7NyaWNvIGNvbXBsZXRvIGRlIG1vdmltZW50b3MgZG8gam9nby5cbiAgICogXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIG1vdmltZW50b3MgcmVhbGl6YWRvcyBkZXNkZSBvIGluw61jaW8gZG8gam9nb1xuICAgKi9cbiAgZ2V0R2FtZUhpc3RvcnkoKTogQ2hlc3NNb3ZlW10ge1xuICAgIHJldHVybiB0aGlzLmdhbWUuaGlzdG9yeSh7IHZlcmJvc2U6IHRydWUgfSkubWFwKG1vdmUgPT4gKHtcbiAgICAgIGZyb206IHRoaXMuc3F1YXJlVG9Qb3NpdGlvbihtb3ZlLmZyb20pLFxuICAgICAgdG86IHRoaXMuc3F1YXJlVG9Qb3NpdGlvbihtb3ZlLnRvKSxcbiAgICAgIHBpZWNlOiB7XG4gICAgICAgIHR5cGU6IG1vdmUucGllY2UsXG4gICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgfSxcbiAgICAgIGNhcHR1cmVkOiBtb3ZlLmNhcHR1cmVkID8ge1xuICAgICAgICB0eXBlOiBtb3ZlLmNhcHR1cmVkLFxuICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ2JsYWNrJyA6ICd3aGl0ZSdcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBwcm9tb3Rpb246IG1vdmUucHJvbW90aW9uLFxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIFZhbGlkYcOnw6NvXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSB1bSBtb3ZpbWVudG8gw6kgdsOhbGlkbyBzZW0gZXhlY3V0w6EtbG8uXG4gICAqIFxuICAgKiBAcGFyYW0gZnJvbSAtIFBvc2nDp8OjbyBpbmljaWFsIGRhIHBlw6dhXG4gICAqIEBwYXJhbSB0byAtIFBvc2nDp8OjbyBmaW5hbCBkYSBwZcOnYVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gbW92aW1lbnRvIMOpIGxlZ2FsLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzVmFsaWRNb3ZlKGZyb206IENoZXNzUG9zaXRpb24sIHRvOiBDaGVzc1Bvc2l0aW9uKTogYm9vbGVhbiB7XG4gICAgLy8gVmFsaWRhw6fDo28gYsOhc2ljYSBkZSBwb3Npw6fDo29cbiAgICBpZiAoIXRoaXMuaXNWYWxpZFBvc2l0aW9uKGZyb20pIHx8ICF0aGlzLmlzVmFsaWRQb3NpdGlvbih0bykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZmljYSBzZSBhIHBlw6dhIHBlcnRlbmNlIGFvIGpvZ2Fkb3IgYXR1YWxcbiAgICBjb25zdCBwaWVjZSA9IHRoaXMuZ2FtZS5ib2FyZCgpW2Zyb20ucm93XVtmcm9tLmNvbF07XG4gICAgaWYgKCFwaWVjZSB8fCBwaWVjZS5jb2xvciAhPT0gKHRoaXMuZ2V0Q3VycmVudFBsYXllcigpID09PSAnd2hpdGUnID8gJ3cnIDogJ2InKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRlbnRhIGZhemVyIG8gbW92aW1lbnRvIG5vIGNoZXNzLmpzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLmdhbWUubW92ZSh7XG4gICAgICAgIGZyb206IHRoaXMucG9zaXRpb25Ub1NxdWFyZShmcm9tKSxcbiAgICAgICAgdG86IHRoaXMucG9zaXRpb25Ub1NxdWFyZSh0byksXG4gICAgICAgIHByb21vdGlvbjogJ3EnXG4gICAgICB9KTtcblxuICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgLy8gRGVzZmF6IG8gbW92aW1lbnRvIHBhcmEgbWFudGVyIG8gZXN0YWRvIG9yaWdpbmFsXG4gICAgICAgIHRoaXMuZ2FtZS51bmRvKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElnbm9yYSBlcnJvcyBkbyBjaGVzcy5qc1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSB1bWEgcG9zacOnw6NvIGVzdMOhIGRlbnRybyBkb3MgbGltaXRlcyBkbyB0YWJ1bGVpcm8uXG4gICAqIFxuICAgKiBAcGFyYW0gcG9zaXRpb24gLSBQb3Npw6fDo28gYSBzZXIgdmVyaWZpY2FkYVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIGEgcG9zacOnw6NvIMOpIHbDoWxpZGEsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNWYWxpZFBvc2l0aW9uKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBvc2l0aW9uLnJvdyA+PSAwICYmIHBvc2l0aW9uLnJvdyA8IDggJiZcbiAgICAgICAgICAgcG9zaXRpb24uY29sID49IDAgJiYgcG9zaXRpb24uY29sIDwgODtcbiAgfVxuXG4gIC8vIFV0aWxpZGFkZXNcbiAgLyoqXG4gICAqIFJlaW5pY2lhIG8gam9nbyBwYXJhIGEgcG9zacOnw6NvIGluaWNpYWwuXG4gICAqIFxuICAgKiBAZW1pdHMge1BPU0lUSU9OX0NIQU5HRUR9IFF1YW5kbyBvIHRhYnVsZWlybyDDqSByZWluaWNpYWRvXG4gICAqL1xuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmdhbWUucmVzZXQoKTtcbiAgICB0aGlzLnBvc2l0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgdHlwZTogJ1BPU0lUSU9OX0NIQU5HRUQnLFxuICAgICAgZmVuOiB0aGlzLmdldEZFTigpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JpYSB1bWEgY8OzcGlhIGluZGVwZW5kZW50ZSBkbyBtb3RvciBkZSB4YWRyZXogYXR1YWwuXG4gICAqIFxuICAgKiBAcmV0dXJucyBVbWEgbm92YSBpbnN0w6JuY2lhIGRvIG1vdG9yIGNvbSBvIG1lc21vIGVzdGFkbyBhdHVhbFxuICAgKi9cbiAgY2xvbmUoKTogQ2hlc3NFbmdpbmUge1xuICAgIGNvbnN0IGNsb25lZEVuZ2luZSA9IG5ldyBDaGVzc0VuZ2luZUJhc2UodGhpcy5vcHRpb25zKTtcbiAgICBjbG9uZWRFbmdpbmUuc2V0RkVOKHRoaXMuZ2V0RkVOKCkpO1xuICAgIHJldHVybiBjbG9uZWRFbmdpbmU7XG4gIH1cblxuICAvLyBNw6l0b2RvcyBwcm90ZWdpZG9zIGF1eGlsaWFyZXNcbiAgcHJvdGVjdGVkIHBvc2l0aW9uVG9TcXVhcmUocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBzdHJpbmcge1xuICAgIGNvbnN0IGZpbGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCdhJy5jaGFyQ29kZUF0KDApICsgcG9zaXRpb24uY29sKTtcbiAgICBjb25zdCByYW5rID0gOCAtIHBvc2l0aW9uLnJvdztcbiAgICByZXR1cm4gYCR7ZmlsZX0ke3Jhbmt9YDtcbiAgfVxuXG4gIHByb3RlY3RlZCBzcXVhcmVUb1Bvc2l0aW9uKHNxdWFyZTogc3RyaW5nKTogQ2hlc3NQb3NpdGlvbiB7XG4gICAgY29uc3QgY29sID0gc3F1YXJlLmNoYXJDb2RlQXQoMCkgLSAnYScuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCByb3cgPSA4IC0gcGFyc2VJbnQoc3F1YXJlWzFdKTtcbiAgICByZXR1cm4geyByb3csIGNvbCB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGZpbmRLaW5nKGNvbG9yOiAnd2hpdGUnIHwgJ2JsYWNrJyk6IENoZXNzUG9zaXRpb24ge1xuICAgIGNvbnN0IGJvYXJkID0gdGhpcy5nYW1lLmJvYXJkKCk7XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDg7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbcm93XVtjb2xdO1xuICAgICAgICBpZiAocGllY2UgJiYgXG4gICAgICAgICAgICBwaWVjZS50eXBlID09PSAnaycgJiYgXG4gICAgICAgICAgICBwaWVjZS5jb2xvciA9PT0gKGNvbG9yID09PSAnd2hpdGUnID8gJ3cnIDogJ2InKSkge1xuICAgICAgICAgIHJldHVybiB7IHJvdywgY29sIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLaW5nIG5vdCBmb3VuZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIG8gc3RhdHVzIGRlIHNhw7pkZSBkbyBtb3Rvci5cbiAgICogXG4gICAqIEByZXR1cm5zIFN0YXR1cyBhdHVhbCBkbyBtb3RvciBpbmNsdWluZG8gbcOpdHJpY2FzIGRlIGRlc2VtcGVuaG9cbiAgICovXG4gIHB1YmxpYyBjaGVja0hlYWx0aCgpOiBIZWFsdGhTdGF0dXMge1xuICAgIHJldHVybiB0aGlzLm1vbml0b3IuY2hlY2tIZWFsdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0ZSB1bSBldmVudG8gZG8gbW90b3IuXG4gICAqIFxuICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudG8gYSBzZXIgZW1pdGlkb1xuICAgKi9cbiAgcHJvdGVjdGVkIGVtaXRFdmVudChldmVudDogRW5naW5lRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdlbmdpbmUtZXZlbnQnLCBldmVudCk7XG4gICAgdGhpcy5tb25pdG9yLnJlY29yZEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIC8vIE3DqXRvZG9zIGRlIGF2YWxpYcOnw6NvXG4gIHByaXZhdGUgZXZhbHVhdGVNYXRlcmlhbCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHBpZWNlVmFsdWVzID0ge1xuICAgICAgcDogMSxcbiAgICAgIG46IDMsXG4gICAgICBiOiAzLFxuICAgICAgcjogNSxcbiAgICAgIHE6IDksXG4gICAgICBrOiAwXG4gICAgfTtcblxuICAgIGxldCBzY29yZSA9IDA7XG4gICAgY29uc3QgYm9hcmQgPSB0aGlzLmdhbWUuYm9hcmQoKTtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDg7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA4OyBjb2wrKykge1xuICAgICAgICBjb25zdCBwaWVjZSA9IGJvYXJkW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKHBpZWNlKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwaWVjZVZhbHVlc1twaWVjZS50eXBlIGFzIGtleW9mIHR5cGVvZiBwaWVjZVZhbHVlc107XG4gICAgICAgICAgc2NvcmUgKz0gcGllY2UuY29sb3IgPT09ICd3JyA/IHZhbHVlIDogLXZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3JlO1xuICB9XG5cbiAgcHJpdmF0ZSBldmFsdWF0ZU1vYmlsaXR5KCk6IG51bWJlciB7XG4gICAgY29uc3Qgd2hpdGVNb3ZlcyA9IHRoaXMuZ2FtZS5tb3ZlcygpLmxlbmd0aDtcbiAgICAvLyBDbG9uYSBvIGpvZ28gcGFyYSB2ZXIgb3MgbW92aW1lbnRvcyBkbyBvcG9uZW50ZVxuICAgIGNvbnN0IHRlbXBHYW1lID0gbmV3IENoZXNzKHRoaXMuZ2FtZS5mZW4oKSk7XG4gICAgdGVtcEdhbWUubG9hZCh0aGlzLmdhbWUuZmVuKCkucmVwbGFjZSgnIHcgJywgJyBiICcpKTtcbiAgICBjb25zdCBibGFja01vdmVzID0gdGVtcEdhbWUubW92ZXMoKS5sZW5ndGg7XG4gICAgXG4gICAgcmV0dXJuIHdoaXRlTW92ZXMgLSBibGFja01vdmVzO1xuICB9XG5cbiAgcHJpdmF0ZSBldmFsdWF0ZUtpbmdTYWZldHkoKTogbnVtYmVyIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnRhciBhdmFsaWHDp8OjbyBkZSBzZWd1cmFuw6dhIGRvIHJlaVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcHJpdmF0ZSBldmFsdWF0ZVBhd25TdHJ1Y3R1cmUoKTogbnVtYmVyIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnRhciBhdmFsaWHDp8OjbyBkZSBlc3RydXR1cmEgZGUgcGXDtWVzXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBFdmVudCBoYW5kbGVyc1xuICBvbihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogKGV2ZW50OiBFbmdpbmVFdmVudCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IChldmVudDogRW5naW5lRXZlbnQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNoZXNzIiwiQXJxdWltYXhNb25pdG9yIiwiSU5JVElBTF9GRU4iLCJFdmVudEVtaXR0ZXIiLCJDaGVzc0VuZ2luZUJhc2UiLCJnZXRCb2FyZCIsImJvYXJkIiwiZ2FtZSIsIm1hcCIsInJvdyIsInNxdWFyZSIsInR5cGUiLCJjb2xvciIsImdldEZFTiIsImZlbiIsInNldEZFTiIsImxvYWQiLCJlbWl0RXZlbnQiLCJlIiwiRXJyb3IiLCJnZXRQb3NzaWJsZU1vdmVzIiwicG9zaXRpb24iLCJwb3NpdGlvblRvU3F1YXJlIiwiY2FjaGVIaXQiLCJwb3NpdGlvbkNhY2hlIiwiaGFzIiwibW92ZXMiLCJ2ZXJib3NlIiwibW9uaXRvciIsInJlY29yZENhY2hlQWNjZXNzIiwibW92ZSIsImZyb20iLCJzcXVhcmVUb1Bvc2l0aW9uIiwidG8iLCJwaWVjZSIsImNhcHR1cmVkIiwidW5kZWZpbmVkIiwicHJvbW90aW9uIiwibWFrZU1vdmUiLCJjaGVzc01vdmUiLCJpc0NoZWNrIiwia2luZ1Bvc2l0aW9uIiwiZmluZEtpbmciLCJnZXRDdXJyZW50UGxheWVyIiwiaXNHYW1lT3ZlciIsInJlc3VsdCIsImlzQ2hlY2ttYXRlIiwidW5kb0xhc3RNb3ZlIiwidW5kbyIsImlzRHJhdyIsInR1cm4iLCJldmFsdWF0ZVBvc2l0aW9uIiwid2VpZ2h0cyIsIm9wdGlvbnMiLCJldmFsdWF0aW9uUGFyYW1ldGVycyIsIm1hdGVyaWFsV2VpZ2h0IiwicG9zaXRpb25XZWlnaHQiLCJtb2JpbGl0eVdlaWdodCIsImtpbmdTYWZldHlXZWlnaHQiLCJwYXduU3RydWN0dXJlV2VpZ2h0Iiwic2NvcmUiLCJldmFsdWF0ZU1hdGVyaWFsIiwiZXZhbHVhdGVQaWVjZVBvc2l0aW9ucyIsImV2YWx1YXRlTW9iaWxpdHkiLCJldmFsdWF0ZUtpbmdTYWZldHkiLCJldmFsdWF0ZVBhd25TdHJ1Y3R1cmUiLCJwaWVjZVNxdWFyZVZhbHVlcyIsInAiLCJuIiwiYiIsImNvbCIsInBpZWNlVGFibGUiLCJwb3NpdGlvblZhbHVlIiwiZ2V0QmVzdE1vdmUiLCJkZXB0aCIsImdldEdhbWVIaXN0b3J5IiwiaGlzdG9yeSIsImlzVmFsaWRNb3ZlIiwiaXNWYWxpZFBvc2l0aW9uIiwicmVzZXQiLCJjbGVhciIsImNsb25lIiwiY2xvbmVkRW5naW5lIiwiZmlsZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJyYW5rIiwicGFyc2VJbnQiLCJjaGVja0hlYWx0aCIsImV2ZW50IiwiZXZlbnRFbWl0dGVyIiwiZW1pdCIsInJlY29yZEV2ZW50IiwicGllY2VWYWx1ZXMiLCJyIiwicSIsImsiLCJ2YWx1ZSIsIndoaXRlTW92ZXMiLCJsZW5ndGgiLCJ0ZW1wR2FtZSIsInJlcGxhY2UiLCJibGFja01vdmVzIiwib24iLCJldmVudE5hbWUiLCJoYW5kbGVyIiwib2ZmIiwiY29uc3RydWN0b3IiLCJzdGFydFBvc2l0aW9uIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/shared/engine/ChessEngineBase.ts\n"));

/***/ })

});