/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BISHOP\": function() { return /* binding */ BISHOP; },\n/* harmony export */   \"BLACK\": function() { return /* binding */ BLACK; },\n/* harmony export */   \"Chess\": function() { return /* binding */ Chess; },\n/* harmony export */   \"DEFAULT_POSITION\": function() { return /* binding */ DEFAULT_POSITION; },\n/* harmony export */   \"KING\": function() { return /* binding */ KING; },\n/* harmony export */   \"KNIGHT\": function() { return /* binding */ KNIGHT; },\n/* harmony export */   \"Move\": function() { return /* binding */ Move; },\n/* harmony export */   \"PAWN\": function() { return /* binding */ PAWN; },\n/* harmony export */   \"QUEEN\": function() { return /* binding */ QUEEN; },\n/* harmony export */   \"ROOK\": function() { return /* binding */ ROOK; },\n/* harmony export */   \"SEVEN_TAG_ROSTER\": function() { return /* binding */ SEVEN_TAG_ROSTER; },\n/* harmony export */   \"SQUARES\": function() { return /* binding */ SQUARES; },\n/* harmony export */   \"WHITE\": function() { return /* binding */ WHITE; },\n/* harmony export */   \"validateFen\": function() { return /* binding */ validateFen; },\n/* harmony export */   \"xoroshiro128\": function() { return /* binding */ xoroshiro128; }\n/* harmony export */ });\n// @generated by Peggy 4.2.0.\n//\n// https://peggyjs.org/\n\n\n\n  function rootNode(comment) {\n  \treturn comment !== null ? { comment, variations: [] } : { variations: []}\n  }\n\n  function node(move, suffix, nag, comment, variations) {\n  \tconst node = { move, variations };\n\n    if (suffix) {\n    \tnode.suffix = suffix;\n    }\n\n    if (nag) {\n    \tnode.nag = nag;\n    }\n\n    if (comment !== null) {\n    \tnode.comment = comment;\n    }\n\n    return node\n  }\n\n  function lineToTree(...nodes) {\n  \tconst [root, ...rest] = nodes;\n\n    let parent = root;\n\n    for (const child of rest) {\n    \tif (child !== null) {\n        \tparent.variations = [child, ...child.variations];\n            child.variations = [];\n            parent = child;\n        }\n    }\n\n  \treturn root\n  }\n\n  function pgn(headers, game) {\n  \tif (game.marker && game.marker.comment) {\n    \tlet node = game.root;\n        while (true) {\n        \tconst next = node.variations[0];\n            if (!next) {\n            \tnode.comment = game.marker.comment;\n            \tbreak\n            }\n            node = next;\n        }\n    }\n\n  \treturn {\n    \theaders,\n        root: game.root,\n        result: (game.marker && game.marker.result) ?? undefined\n    }\n  }\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { pgn: peg$parsepgn };\n  var peg$startRuleFunction = peg$parsepgn;\n\n  var peg$c0 = \"[\";\n  var peg$c1 = \"\\\"\";\n  var peg$c2 = \"]\";\n  var peg$c3 = \".\";\n  var peg$c4 = \"O-O-O\";\n  var peg$c5 = \"O-O\";\n  var peg$c6 = \"0-0-0\";\n  var peg$c7 = \"0-0\";\n  var peg$c8 = \"$\";\n  var peg$c9 = \"{\";\n  var peg$c10 = \"}\";\n  var peg$c11 = \";\";\n  var peg$c12 = \"(\";\n  var peg$c13 = \")\";\n  var peg$c14 = \"1-0\";\n  var peg$c15 = \"0-1\";\n  var peg$c16 = \"1/2-1/2\";\n  var peg$c17 = \"*\";\n\n  var peg$r0 = /^[a-zA-Z]/;\n  var peg$r1 = /^[^\"]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[.]/;\n  var peg$r4 = /^[a-zA-Z1-8\\-=]/;\n  var peg$r5 = /^[+#]/;\n  var peg$r6 = /^[!?]/;\n  var peg$r7 = /^[^}]/;\n  var peg$r8 = /^[^\\r\\n]/;\n  var peg$r9 = /^[ \\t\\r\\n]/;\n\n  var peg$e0 = peg$otherExpectation(\"tag pair\");\n  var peg$e1 = peg$literalExpectation(\"[\", false);\n  var peg$e2 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e3 = peg$literalExpectation(\"]\", false);\n  var peg$e4 = peg$otherExpectation(\"tag name\");\n  var peg$e5 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n  var peg$e6 = peg$otherExpectation(\"tag value\");\n  var peg$e7 = peg$classExpectation([\"\\\"\"], true, false);\n  var peg$e8 = peg$otherExpectation(\"move number\");\n  var peg$e9 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e10 = peg$literalExpectation(\".\", false);\n  var peg$e11 = peg$classExpectation([\".\"], false, false);\n  var peg$e12 = peg$otherExpectation(\"standard algebraic notation\");\n  var peg$e13 = peg$literalExpectation(\"O-O-O\", false);\n  var peg$e14 = peg$literalExpectation(\"O-O\", false);\n  var peg$e15 = peg$literalExpectation(\"0-0-0\", false);\n  var peg$e16 = peg$literalExpectation(\"0-0\", false);\n  var peg$e17 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"1\", \"8\"], \"-\", \"=\"], false, false);\n  var peg$e18 = peg$classExpectation([\"+\", \"#\"], false, false);\n  var peg$e19 = peg$otherExpectation(\"suffix annotation\");\n  var peg$e20 = peg$classExpectation([\"!\", \"?\"], false, false);\n  var peg$e21 = peg$otherExpectation(\"NAG\");\n  var peg$e22 = peg$literalExpectation(\"$\", false);\n  var peg$e23 = peg$otherExpectation(\"brace comment\");\n  var peg$e24 = peg$literalExpectation(\"{\", false);\n  var peg$e25 = peg$classExpectation([\"}\"], true, false);\n  var peg$e26 = peg$literalExpectation(\"}\", false);\n  var peg$e27 = peg$otherExpectation(\"rest of line comment\");\n  var peg$e28 = peg$literalExpectation(\";\", false);\n  var peg$e29 = peg$classExpectation([\"\\r\", \"\\n\"], true, false);\n  var peg$e30 = peg$otherExpectation(\"variation\");\n  var peg$e31 = peg$literalExpectation(\"(\", false);\n  var peg$e32 = peg$literalExpectation(\")\", false);\n  var peg$e33 = peg$otherExpectation(\"game termination marker\");\n  var peg$e34 = peg$literalExpectation(\"1-0\", false);\n  var peg$e35 = peg$literalExpectation(\"0-1\", false);\n  var peg$e36 = peg$literalExpectation(\"1/2-1/2\", false);\n  var peg$e37 = peg$literalExpectation(\"*\", false);\n  var peg$e38 = peg$otherExpectation(\"whitespace\");\n  var peg$e39 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function(headers, game) { return pgn(headers, game) };\n  var peg$f1 = function(tagPairs) { return Object.fromEntries(tagPairs) };\n  var peg$f2 = function(tagName, tagValue) { return [tagName, tagValue] };\n  var peg$f3 = function(root, marker) { return { root, marker} };\n  var peg$f4 = function(comment, moves) { return lineToTree(rootNode(comment), ...moves.flat()) };\n  var peg$f5 = function(san, suffix, nag, comment, variations) { return node(san, suffix, nag, comment, variations) };\n  var peg$f6 = function(nag) { return nag };\n  var peg$f7 = function(comment) { return comment.replace(/[\\r\\n]+/g, \" \") };\n  var peg$f8 = function(comment) { return comment.trim() };\n  var peg$f9 = function(line) { return line };\n  var peg$f10 = function(result, comment) { return { result, comment } };\n  var peg$currPos = options.peg$currPos | 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = peg$currPos;\n  var peg$maxFailExpected = options.peg$maxFailExpected || [];\n  var peg$silentFails = options.peg$silentFails | 0;\n\n  var peg$result;\n\n  if (options.startRule) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      if (pos >= peg$posDetailsCache.length) {\n        p = peg$posDetailsCache.length - 1;\n      } else {\n        p = pos;\n        while (!peg$posDetailsCache[--p]) {}\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepgn() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetagPairSection();\n    s2 = peg$parsemoveTextSection();\n    s0 = peg$f0(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsetagPairSection() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetagPair();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsetagPair();\n    }\n    s2 = peg$parse_();\n    s0 = peg$f1(s1);\n\n    return s0;\n  }\n\n  function peg$parsetagPair() {\n    var s0, s2, s4, s6, s7, s8, s10;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s2 = peg$c0;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s2 !== peg$FAILED) {\n      peg$parse_();\n      s4 = peg$parsetagName();\n      if (s4 !== peg$FAILED) {\n        peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s6 = peg$c1;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parsetagValue();\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s8 = peg$c1;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$parse_();\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s10 = peg$c2;\n              peg$currPos++;\n            } else {\n              s10 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s10 !== peg$FAILED) {\n              s0 = peg$f2(s4, s7);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagName() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r0.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = input.charAt(peg$currPos);\n        if (peg$r0.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagValue() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r1.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r1.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e6); }\n\n    return s0;\n  }\n\n  function peg$parsemoveTextSection() {\n    var s0, s1, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseline();\n    peg$parse_();\n    s3 = peg$parsegameTerminationMarker();\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    peg$parse_();\n    s0 = peg$f3(s1, s3);\n\n    return s0;\n  }\n\n  function peg$parseline() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecomment();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = [];\n    s3 = peg$parsemove();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsemove();\n    }\n    s0 = peg$f4(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsemove() {\n    var s0, s4, s5, s6, s7, s8, s9, s10;\n\n    s0 = peg$currPos;\n    peg$parse_();\n    peg$parsemoveNumber();\n    peg$parse_();\n    s4 = peg$parsesan();\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parsesuffixAnnotation();\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      s6 = [];\n      s7 = peg$parsenag();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parsenag();\n      }\n      s7 = peg$parse_();\n      s8 = peg$parsecomment();\n      if (s8 === peg$FAILED) {\n        s8 = null;\n      }\n      s9 = [];\n      s10 = peg$parsevariation();\n      while (s10 !== peg$FAILED) {\n        s9.push(s10);\n        s10 = peg$parsevariation();\n      }\n      s0 = peg$f5(s4, s5, s6, s8, s9);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveNumber() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r2.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r2.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c3;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r3.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = input.charAt(peg$currPos);\n        if (peg$r3.test(s5)) {\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n      }\n      s1 = [s1, s2, s3, s4];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesan() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s2 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c5) {\n        s2 = peg$c5;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c6) {\n          s2 = peg$c6;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e15); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c7) {\n            s2 = peg$c7;\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e16); }\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = input.charAt(peg$currPos);\n            if (peg$r0.test(s3)) {\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e5); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = input.charAt(peg$currPos);\n              if (peg$r4.test(s5)) {\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e17); }\n              }\n              if (s5 !== peg$FAILED) {\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = input.charAt(peg$currPos);\n                  if (peg$r4.test(s5)) {\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e17); }\n                  }\n                }\n              } else {\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = input.charAt(peg$currPos);\n      if (peg$r5.test(s3)) {\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesuffixAnnotation() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r6.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (s1.length >= 2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = input.charAt(peg$currPos);\n        if (peg$r6.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e20); }\n        }\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenag() {\n    var s0, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s2 = peg$c8;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r2.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = input.charAt(peg$currPos);\n          if (peg$r2.test(s5)) {\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e9); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = peg$f6(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0;\n\n    s0 = peg$parsebraceComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parserestOfLineComment();\n    }\n\n    return s0;\n  }\n\n  function peg$parsebraceComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r7.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e25); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r7.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e25); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c10;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n    }\n\n    return s0;\n  }\n\n  function peg$parserestOfLineComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s1 = peg$c11;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r8.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e29); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r8.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      s0 = peg$f8(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariation() {\n    var s0, s2, s3, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c12;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseline();\n      if (s3 !== peg$FAILED) {\n        peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s5 = peg$c13;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e32); }\n        }\n        if (s5 !== peg$FAILED) {\n          s0 = peg$f9(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegameTerminationMarker() {\n    var s0, s1, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c14) {\n      s1 = peg$c14;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c16) {\n          s1 = peg$c16;\n          peg$currPos += 7;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e36); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c17;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e37); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$parse_();\n      s3 = peg$parsecomment();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s0 = peg$f10(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = input.charAt(peg$currPos);\n    if (peg$r9.test(s1)) {\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = input.charAt(peg$currPos);\n      if (peg$r9.test(s1)) {\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e38); }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (options.peg$library) {\n    return /** @type {any} */ ({\n      peg$result,\n      peg$currPos,\n      peg$FAILED,\n      peg$maxFailExpected,\n      peg$maxFailPos\n    });\n  }\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst MASK64 = 0xffffffffffffffffn;\nfunction rotl(x, k) {\n    return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn;\n}\nfunction wrappingMul(x, y) {\n    return (x * y) & MASK64;\n}\n// xoroshiro128**\nfunction xoroshiro128(state) {\n    return function () {\n        let s0 = BigInt(state & MASK64);\n        let s1 = BigInt((state >> 64n) & MASK64);\n        const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n);\n        s1 ^= s0;\n        s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64;\n        s1 = rotl(s1, 37n);\n        state = (s1 << 64n) | s0;\n        return result;\n    };\n}\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en);\nconst PIECE_KEYS = Array.from({ length: 2 }, () => Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())));\nconst EP_KEYS = Array.from({ length: 8 }, () => rand());\nconst CASTLING_KEYS = Array.from({ length: 16 }, () => rand());\nconst SIDE_KEY = rand();\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n    NULL_MOVE: '-',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n    NULL_MOVE: 128,\n};\n/* eslint-disable @typescript-eslint/naming-convention */\n// these are required, according to spec\nconst SEVEN_TAG_ROSTER = {\n    Event: '?',\n    Site: '?',\n    Date: '????.??.??',\n    Round: '?',\n    White: '?',\n    Black: '?',\n    Result: '*',\n};\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS = {\n    WhiteTitle: null,\n    BlackTitle: null,\n    WhiteElo: null,\n    BlackElo: null,\n    WhiteUSCF: null,\n    BlackUSCF: null,\n    WhiteNA: null,\n    BlackNA: null,\n    WhiteType: null,\n    BlackType: null,\n    EventDate: null,\n    EventSponsor: null,\n    Section: null,\n    Stage: null,\n    Board: null,\n    Opening: null,\n    Variation: null,\n    SubVariation: null,\n    ECO: null,\n    NIC: null,\n    Time: null,\n    UTCTime: null,\n    UTCDate: null,\n    TimeControl: null,\n    SetUp: null,\n    FEN: null,\n    Termination: null,\n    Annotator: null,\n    Mode: null,\n    PlyCount: null,\n};\nconst HEADER_TEMPLATE = {\n    ...SEVEN_TAG_ROSTER,\n    ...SUPLEMENTAL_TAGS,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst SAN_NULLMOVE = '--';\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    _hash = 0n;\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = new Map();\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n        this.load(fen, { skipValidation });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE };\n        this._hash = this._computeHash();\n        this._positionCount = new Map();\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        this._header['SetUp'] = null;\n        this._header['FEN'] = null;\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._hash = this._computeHash();\n        this._updateSetup(fen);\n        this._incPositionCount();\n    }\n    fen({ forceEnpassantSquare = false, } = {}) {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            if (forceEnpassantSquare) {\n                epSquare = algebraic(this._epSquare);\n            }\n            else {\n                const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n                const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n                for (const square of squares) {\n                    // is the square off the board?\n                    if (square & 0x88) {\n                        continue;\n                    }\n                    const color = this._turn;\n                    // is there a pawn that can capture the epSquare?\n                    if (this._board[square]?.color === color &&\n                        this._board[square]?.type === PAWN) {\n                        // if the pawn makes an ep capture, does it leave its king in check?\n                        this._makeMove({\n                            color,\n                            from: square,\n                            to: this._epSquare,\n                            piece: PAWN,\n                            captured: PAWN,\n                            flags: BITS.EP_CAPTURE,\n                        });\n                        const isLegal = !this._isKingAttacked(color);\n                        this._undoMove();\n                        // if ep is legal, break and set the ep square in the FEN output\n                        if (isLegal) {\n                            epSquare = algebraic(this._epSquare);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    _pieceKey(i) {\n        if (!this._board[i]) {\n            return 0n;\n        }\n        const { color, type } = this._board[i];\n        const colorIndex = {\n            w: 0,\n            b: 1,\n        }[color];\n        const typeIndex = {\n            p: 0,\n            n: 1,\n            b: 2,\n            r: 3,\n            q: 4,\n            k: 5,\n        }[type];\n        return PIECE_KEYS[colorIndex][typeIndex][i];\n    }\n    _epKey() {\n        return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7];\n    }\n    _castlingKey() {\n        const index = (this._castling.w >> 5) | (this._castling.b >> 3);\n        return CASTLING_KEYS[index];\n    }\n    _computeHash() {\n        let hash = 0n;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            if (this._board[i]) {\n                hash ^= this._pieceKey(i);\n            }\n        }\n        hash ^= this._epKey();\n        hash ^= this._castlingKey();\n        if (this._turn === 'b') {\n            hash ^= SIDE_KEY;\n        }\n        return hash;\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            this._header['SetUp'] = null;\n            this._header['FEN'] = null;\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    findPiece(piece) {\n        const squares = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (!this._board[i] || this._board[i]?.color !== piece.color) {\n                continue;\n            }\n            // check if square contains the requested piece\n            if (this._board[i].color === piece.color &&\n                this._board[i].type === piece.type) {\n                squares.push(algebraic(i));\n            }\n        }\n        return squares;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _set(sq, piece) {\n        this._hash ^= this._pieceKey(sq);\n        this._board[sq] = piece;\n        this._hash ^= this._pieceKey(sq);\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._set(sq, { type: type, color: color });\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    _clear(sq) {\n        this._hash ^= this._pieceKey(sq);\n        delete this._board[sq];\n    }\n    remove(square) {\n        const piece = this.get(square);\n        this._clear(Ox88[square]);\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        this._hash ^= this._castlingKey();\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= -65;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= -33;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= -65;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= -33;\n        }\n        this._hash ^= this._castlingKey();\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._hash ^= this._epKey();\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._hash ^= this._epKey();\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if ((difference > 0 && piece.color === WHITE) ||\n                        (difference <= 0 && piece.color === BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    hash() {\n        return this._hash.toString(16);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this._hash) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (move === null) {\n            moveObj = this._moveFromSan(SAN_NULLMOVE, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        //disallow null moves when in check\n        if (this.isCheck() && moveObj.flags & BITS.NULL_MOVE) {\n            throw new Error('Null move not allowed when in check');\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount();\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _movePiece(from, to) {\n        this._hash ^= this._pieceKey(from);\n        this._board[to] = this._board[from];\n        delete this._board[from];\n        this._hash ^= this._pieceKey(to);\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        if (move.flags & BITS.NULL_MOVE) {\n            if (us === BLACK) {\n                this._moveNumber++;\n            }\n            this._halfMoves++;\n            this._turn = them;\n            this._epSquare = EMPTY;\n            return;\n        }\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        if (move.captured) {\n            this._hash ^= this._pieceKey(move.to);\n        }\n        this._movePiece(move.from, move.to);\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                this._clear(move.to - 16);\n            }\n            else {\n                this._clear(move.to + 16);\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._clear(move.to);\n            this._set(move.to, { type: move.promotion, color: us });\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._movePiece(castlingFrom, castlingTo);\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._movePiece(castlingFrom, castlingTo);\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        this._hash ^= this._castlingKey();\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            let epSquare;\n            if (us === BLACK) {\n                epSquare = move.to - 16;\n            }\n            else {\n                epSquare = move.to + 16;\n            }\n            if ((!((move.to - 1) & 0x88) &&\n                this._board[move.to - 1]?.type === PAWN &&\n                this._board[move.to - 1]?.color === them) ||\n                (!((move.to + 1) & 0x88) &&\n                    this._board[move.to + 1]?.type === PAWN &&\n                    this._board[move.to + 1]?.color === them)) {\n                this._epSquare = epSquare;\n                this._hash ^= this._epKey();\n            }\n            else {\n                this._epSquare = EMPTY;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n        this._hash ^= SIDE_KEY;\n    }\n    undo() {\n        const hash = this._hash;\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(hash);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        this._hash ^= SIDE_KEY;\n        const us = this._turn;\n        const them = swapColor(us);\n        if (move.flags & BITS.NULL_MOVE) {\n            return move;\n        }\n        this._movePiece(move.to, move.from);\n        // to undo any promotions\n        if (move.piece) {\n            this._clear(move.from);\n            this._set(move.from, { type: move.piece, color: us });\n        }\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._set(index, { type: PAWN, color: them });\n            }\n            else {\n                // regular capture\n                this._set(move.to, { type: move.captured, color: them });\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._movePiece(castlingFrom, castlingTo);\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             *\n             * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n             * do have to check for null placeholders, though, and omit them\n             */\n            const headerTag = this._header[i];\n            if (headerTag)\n                result.push(`[${i} \"${this._header[i]}\"]` + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n        moves.push(this._header.Result || '*');\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /**\n     * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    // TODO: value validation per spec\n    setHeader(key, value) {\n        this._header[key] = value ?? SEVEN_TAG_ROSTER[key] ?? null;\n        return this.getHeaders();\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            this._header[key] = SEVEN_TAG_ROSTER[key] || null;\n            return true;\n        }\n        return false;\n    }\n    // return only non-null headers (omit placemarker nulls)\n    getHeaders() {\n        const nonNullHeaders = {};\n        for (const [key, value] of Object.entries(this._header)) {\n            if (value !== null) {\n                nonNullHeaders[key] = value;\n            }\n        }\n        return nonNullHeaders;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        // If newlineChar is not the default, replace all instances with \\n\n        if (newlineChar !== '\\r?\\n') {\n            pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n');\n        }\n        const parsedPgn = peg$parse(pgn);\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsedPgn.headers;\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        let node = parsedPgn.root;\n        while (node) {\n            if (node.move) {\n                const move = this._moveFromSan(node.move, strict);\n                if (move == null) {\n                    throw new Error(`Invalid move in PGN: ${node.move}`);\n                }\n                else {\n                    this._makeMove(move);\n                    this._incPositionCount();\n                }\n            }\n            if (node.comment !== undefined) {\n                this._comments[this.fen()] = node.comment;\n            }\n            node = node.variations[0];\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        const result = parsedPgn.result;\n        if (result &&\n            Object.keys(this._header).length &&\n            this._header['Result'] !== result) {\n            this.setHeader('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else if (move.flags & BITS.NULL_MOVE) {\n            return SAN_NULLMOVE;\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        let cleanMove = strippedSan(move);\n        if (!strict) {\n            if (cleanMove === '0-0') {\n                cleanMove = 'O-O';\n            }\n            else if (cleanMove === '0-0-0') {\n                cleanMove = 'O-O-O';\n            }\n        }\n        //first implementation of null with a dummy move (black king moves from a8 to a8), maybe this can be implemented better\n        if (cleanMove == SAN_NULLMOVE) {\n            const res = {\n                color: this._turn,\n                from: 0,\n                to: 0,\n                piece: 'k',\n                flags: BITS.NULL_MOVE,\n            };\n            return res;\n        }\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    setTurn(color) {\n        if (this._turn == color) {\n            return false;\n        }\n        this.move('--');\n        return true;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. Old positions are removed from the map if their counts are reduced to 0.\n     */\n    _getPositionCount(hash) {\n        return this._positionCount.get(hash) ?? 0;\n    }\n    _incPositionCount() {\n        this._positionCount.set(this._hash, (this._positionCount.get(this._hash) ?? 0) + 1);\n    }\n    _decPositionCount(hash) {\n        const currentCount = this._positionCount.get(hash) ?? 0;\n        if (currentCount === 1) {\n            this._positionCount.delete(hash);\n        }\n        else {\n            this._positionCount.set(hash, currentCount - 1);\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n\n\n//# sourceMappingURL=chess.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSwrQkFBK0IsMEJBQTBCLElBQUk7QUFDN0Q7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcscUJBQXFCLFdBQVcscUJBQXFCLGFBQWE7QUFDN0csNkJBQTZCLFdBQVc7QUFDeEMsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxxQkFBcUIsMENBQTBDLE9BQU87QUFDdEU7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBMkMsT0FBTztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCLElBQUk7QUFDdkUseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBLFlBQVksMEJBQTBCLElBQUk7QUFDMUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBa0QsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0Qyx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDLElBQUk7QUFDOUM7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0MsSUFBSTtBQUM5QztBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsR0FBRyxHQUFHLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxFQUFFLFdBQVcsRUFBRSxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQSw2Q0FBNkMsWUFBWSxFQUFFLE9BQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlDQUF5QyxJQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNKO0FBQ3RKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9kaXN0L2VzbS9jaGVzcy5qcz8zMmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEBnZW5lcmF0ZWQgYnkgUGVnZ3kgNC4yLjAuXG4vL1xuLy8gaHR0cHM6Ly9wZWdneWpzLm9yZy9cblxuXG5cbiAgZnVuY3Rpb24gcm9vdE5vZGUoY29tbWVudCkge1xuICBcdHJldHVybiBjb21tZW50ICE9PSBudWxsID8geyBjb21tZW50LCB2YXJpYXRpb25zOiBbXSB9IDogeyB2YXJpYXRpb25zOiBbXX1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vZGUobW92ZSwgc3VmZml4LCBuYWcsIGNvbW1lbnQsIHZhcmlhdGlvbnMpIHtcbiAgXHRjb25zdCBub2RlID0geyBtb3ZlLCB2YXJpYXRpb25zIH07XG5cbiAgICBpZiAoc3VmZml4KSB7XG4gICAgXHRub2RlLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICB9XG5cbiAgICBpZiAobmFnKSB7XG4gICAgXHRub2RlLm5hZyA9IG5hZztcbiAgICB9XG5cbiAgICBpZiAoY29tbWVudCAhPT0gbnVsbCkge1xuICAgIFx0bm9kZS5jb21tZW50ID0gY29tbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gbGluZVRvVHJlZSguLi5ub2Rlcykge1xuICBcdGNvbnN0IFtyb290LCAuLi5yZXN0XSA9IG5vZGVzO1xuXG4gICAgbGV0IHBhcmVudCA9IHJvb3Q7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJlc3QpIHtcbiAgICBcdGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBcdHBhcmVudC52YXJpYXRpb25zID0gW2NoaWxkLCAuLi5jaGlsZC52YXJpYXRpb25zXTtcbiAgICAgICAgICAgIGNoaWxkLnZhcmlhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHBhcmVudCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgfVxuXG4gIFx0cmV0dXJuIHJvb3RcbiAgfVxuXG4gIGZ1bmN0aW9uIHBnbihoZWFkZXJzLCBnYW1lKSB7XG4gIFx0aWYgKGdhbWUubWFya2VyICYmIGdhbWUubWFya2VyLmNvbW1lbnQpIHtcbiAgICBcdGxldCBub2RlID0gZ2FtZS5yb290O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBcdGNvbnN0IG5leHQgPSBub2RlLnZhcmlhdGlvbnNbMF07XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIFx0bm9kZS5jb21tZW50ID0gZ2FtZS5tYXJrZXIuY29tbWVudDtcbiAgICAgICAgICAgIFx0YnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG4gIFx0cmV0dXJuIHtcbiAgICBcdGhlYWRlcnMsXG4gICAgICAgIHJvb3Q6IGdhbWUucm9vdCxcbiAgICAgICAgcmVzdWx0OiAoZ2FtZS5tYXJrZXIgJiYgZ2FtZS5tYXJrZXIucmVzdWx0KSA/PyB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gQygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIEMucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IEMoKTtcbn1cblxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdmFyIHNlbGYgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBDaGVjayBpcyBhIG5lY2Vzc2FyeSBldmlsIHRvIHN1cHBvcnQgb2xkZXIgZW52aXJvbm1lbnRzXG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc2VsZiwgcGVnJFN5bnRheEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbiAgc2VsZi5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICBzZWxmLmZvdW5kID0gZm91bmQ7XG4gIHNlbGYubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgc2VsZi5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICByZXR1cm4gc2VsZjtcbn1cblxucGVnJHN1YmNsYXNzKHBlZyRTeW50YXhFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBwZWckcGFkRW5kKHN0ciwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgcGFkU3RyaW5nID0gcGFkU3RyaW5nIHx8IFwiIFwiO1xuICBpZiAoc3RyLmxlbmd0aCA+IHRhcmdldExlbmd0aCkgeyByZXR1cm4gc3RyOyB9XG4gIHRhcmdldExlbmd0aCAtPSBzdHIubGVuZ3RoO1xuICBwYWRTdHJpbmcgKz0gcGFkU3RyaW5nLnJlcGVhdCh0YXJnZXRMZW5ndGgpO1xuICByZXR1cm4gc3RyICsgcGFkU3RyaW5nLnNsaWNlKDAsIHRhcmdldExlbmd0aCk7XG59XG5cbnBlZyRTeW50YXhFcnJvci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oc291cmNlcykge1xuICB2YXIgc3RyID0gXCJFcnJvcjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgdmFyIHNyYyA9IG51bGw7XG4gICAgdmFyIGs7XG4gICAgZm9yIChrID0gMDsgayA8IHNvdXJjZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChzb3VyY2VzW2tdLnNvdXJjZSA9PT0gdGhpcy5sb2NhdGlvbi5zb3VyY2UpIHtcbiAgICAgICAgc3JjID0gc291cmNlc1trXS50ZXh0LnNwbGl0KC9cXHJcXG58XFxufFxcci9nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzID0gdGhpcy5sb2NhdGlvbi5zdGFydDtcbiAgICB2YXIgb2Zmc2V0X3MgPSAodGhpcy5sb2NhdGlvbi5zb3VyY2UgJiYgKHR5cGVvZiB0aGlzLmxvY2F0aW9uLnNvdXJjZS5vZmZzZXQgPT09IFwiZnVuY3Rpb25cIikpXG4gICAgICA/IHRoaXMubG9jYXRpb24uc291cmNlLm9mZnNldChzKVxuICAgICAgOiBzO1xuICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uLnNvdXJjZSArIFwiOlwiICsgb2Zmc2V0X3MubGluZSArIFwiOlwiICsgb2Zmc2V0X3MuY29sdW1uO1xuICAgIGlmIChzcmMpIHtcbiAgICAgIHZhciBlID0gdGhpcy5sb2NhdGlvbi5lbmQ7XG4gICAgICB2YXIgZmlsbGVyID0gcGVnJHBhZEVuZChcIlwiLCBvZmZzZXRfcy5saW5lLnRvU3RyaW5nKCkubGVuZ3RoLCAnICcpO1xuICAgICAgdmFyIGxpbmUgPSBzcmNbcy5saW5lIC0gMV07XG4gICAgICB2YXIgbGFzdCA9IHMubGluZSA9PT0gZS5saW5lID8gZS5jb2x1bW4gOiBsaW5lLmxlbmd0aCArIDE7XG4gICAgICB2YXIgaGF0TGVuID0gKGxhc3QgLSBzLmNvbHVtbikgfHwgMTtcbiAgICAgIHN0ciArPSBcIlxcbiAtLT4gXCIgKyBsb2MgKyBcIlxcblwiXG4gICAgICAgICAgKyBmaWxsZXIgKyBcIiB8XFxuXCJcbiAgICAgICAgICArIG9mZnNldF9zLmxpbmUgKyBcIiB8IFwiICsgbGluZSArIFwiXFxuXCJcbiAgICAgICAgICArIGZpbGxlciArIFwiIHwgXCIgKyBwZWckcGFkRW5kKFwiXCIsIHMuY29sdW1uIC0gMSwgJyAnKVxuICAgICAgICAgICsgcGVnJHBhZEVuZChcIlwiLCBoYXRMZW4sIFwiXlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9IFwiXFxuIGF0IFwiICsgbG9jO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxucGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZSA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCkge1xuICB2YXIgREVTQ1JJQkVfRVhQRUNUQVRJT05fRk5TID0ge1xuICAgIGxpdGVyYWw6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgfSxcblxuICAgIGNsYXNzOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgdmFyIGVzY2FwZWRQYXJ0cyA9IGV4cGVjdGF0aW9uLnBhcnRzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnQpXG4gICAgICAgICAgPyBjbGFzc0VzY2FwZShwYXJ0WzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUocGFydFsxXSlcbiAgICAgICAgICA6IGNsYXNzRXNjYXBlKHBhcnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMuam9pbihcIlwiKSArIFwiXVwiO1xuICAgIH0sXG5cbiAgICBhbnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiZW5kIG9mIGlucHV0XCI7XG4gICAgfSxcblxuICAgIG90aGVyOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBoZXgoY2gpIHtcbiAgICByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpdGVyYWxFc2NhcGUocykge1xuICAgIHJldHVybiBzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpXG4gICAgICAucmVwbGFjZSgvXCIvZywgIFwiXFxcXFxcXCJcIilcbiAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpXG4gICAgICAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHgwXCIgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gXCJcXFxceFwiICArIGhleChjaCk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NFc2NhcGUocykge1xuICAgIHJldHVybiBzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpXG4gICAgICAucmVwbGFjZSgvXFxdL2csIFwiXFxcXF1cIilcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgXCJcXFxcXlwiKVxuICAgICAgLnJlcGxhY2UoLy0vZywgIFwiXFxcXC1cIilcbiAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpXG4gICAgICAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHgwXCIgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gXCJcXFxceFwiICArIGhleChjaCk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RhdGlvbikge1xuICAgIHJldHVybiBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlNbZXhwZWN0YXRpb24udHlwZV0oZXhwZWN0YXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkge1xuICAgIHZhciBkZXNjcmlwdGlvbnMgPSBleHBlY3RlZC5tYXAoZGVzY3JpYmVFeHBlY3RhdGlvbik7XG4gICAgdmFyIGksIGo7XG5cbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICArIFwiLCBvciBcIlxuICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kID8gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcblxuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIHBlZyRGQUlMRUQgPSB7fTtcbiAgdmFyIHBlZyRzb3VyY2UgPSBvcHRpb25zLmdyYW1tYXJTb3VyY2U7XG5cbiAgdmFyIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHBnbjogcGVnJHBhcnNlcGduIH07XG4gIHZhciBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckcGFyc2VwZ247XG5cbiAgdmFyIHBlZyRjMCA9IFwiW1wiO1xuICB2YXIgcGVnJGMxID0gXCJcXFwiXCI7XG4gIHZhciBwZWckYzIgPSBcIl1cIjtcbiAgdmFyIHBlZyRjMyA9IFwiLlwiO1xuICB2YXIgcGVnJGM0ID0gXCJPLU8tT1wiO1xuICB2YXIgcGVnJGM1ID0gXCJPLU9cIjtcbiAgdmFyIHBlZyRjNiA9IFwiMC0wLTBcIjtcbiAgdmFyIHBlZyRjNyA9IFwiMC0wXCI7XG4gIHZhciBwZWckYzggPSBcIiRcIjtcbiAgdmFyIHBlZyRjOSA9IFwie1wiO1xuICB2YXIgcGVnJGMxMCA9IFwifVwiO1xuICB2YXIgcGVnJGMxMSA9IFwiO1wiO1xuICB2YXIgcGVnJGMxMiA9IFwiKFwiO1xuICB2YXIgcGVnJGMxMyA9IFwiKVwiO1xuICB2YXIgcGVnJGMxNCA9IFwiMS0wXCI7XG4gIHZhciBwZWckYzE1ID0gXCIwLTFcIjtcbiAgdmFyIHBlZyRjMTYgPSBcIjEvMi0xLzJcIjtcbiAgdmFyIHBlZyRjMTcgPSBcIipcIjtcblxuICB2YXIgcGVnJHIwID0gL15bYS16QS1aXS87XG4gIHZhciBwZWckcjEgPSAvXlteXCJdLztcbiAgdmFyIHBlZyRyMiA9IC9eWzAtOV0vO1xuICB2YXIgcGVnJHIzID0gL15bLl0vO1xuICB2YXIgcGVnJHI0ID0gL15bYS16QS1aMS04XFwtPV0vO1xuICB2YXIgcGVnJHI1ID0gL15bKyNdLztcbiAgdmFyIHBlZyRyNiA9IC9eWyE/XS87XG4gIHZhciBwZWckcjcgPSAvXltefV0vO1xuICB2YXIgcGVnJHI4ID0gL15bXlxcclxcbl0vO1xuICB2YXIgcGVnJHI5ID0gL15bIFxcdFxcclxcbl0vO1xuXG4gIHZhciBwZWckZTAgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInRhZyBwYWlyXCIpO1xuICB2YXIgcGVnJGUxID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIltcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcXCJcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIl1cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGU0ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ0YWcgbmFtZVwiKTtcbiAgdmFyIHBlZyRlNSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl1dLCBmYWxzZSwgZmFsc2UpO1xuICB2YXIgcGVnJGU2ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ0YWcgdmFsdWVcIik7XG4gIHZhciBwZWckZTcgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXFwiXCJdLCB0cnVlLCBmYWxzZSk7XG4gIHZhciBwZWckZTggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIm1vdmUgbnVtYmVyXCIpO1xuICB2YXIgcGVnJGU5ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI5XCJdXSwgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMTAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLlwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTExID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiLlwiXSwgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMTIgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInN0YW5kYXJkIGFsZ2VicmFpYyBub3RhdGlvblwiKTtcbiAgdmFyIHBlZyRlMTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiTy1PLU9cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJPLU9cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxNSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIwLTAtMFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTE2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjAtMFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTE3ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMVwiLCBcIjhcIl0sIFwiLVwiLCBcIj1cIl0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTE4ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiK1wiLCBcIiNcIl0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTE5ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJzdWZmaXggYW5ub3RhdGlvblwiKTtcbiAgdmFyIHBlZyRlMjAgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIhXCIsIFwiP1wiXSwgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMjEgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIk5BR1wiKTtcbiAgdmFyIHBlZyRlMjIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiJFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTIzID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJicmFjZSBjb21tZW50XCIpO1xuICB2YXIgcGVnJGUyNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ7XCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMjUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJ9XCJdLCB0cnVlLCBmYWxzZSk7XG4gIHZhciBwZWckZTI2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIn1cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUyNyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwicmVzdCBvZiBsaW5lIGNvbW1lbnRcIik7XG4gIHZhciBwZWckZTI4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjtcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUyOSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIlxcclwiLCBcIlxcblwiXSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUzMCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidmFyaWF0aW9uXCIpO1xuICB2YXIgcGVnJGUzMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIoXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKVwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTMzID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJnYW1lIHRlcm1pbmF0aW9uIG1hcmtlclwiKTtcbiAgdmFyIHBlZyRlMzQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMS0wXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzUgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMC0xXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMS8yLTEvMlwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTM3ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIipcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzOCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwid2hpdGVzcGFjZVwiKTtcbiAgdmFyIHBlZyRlMzkgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIgXCIsIFwiXFx0XCIsIFwiXFxyXCIsIFwiXFxuXCJdLCBmYWxzZSwgZmFsc2UpO1xuXG4gIHZhciBwZWckZjAgPSBmdW5jdGlvbihoZWFkZXJzLCBnYW1lKSB7IHJldHVybiBwZ24oaGVhZGVycywgZ2FtZSkgfTtcbiAgdmFyIHBlZyRmMSA9IGZ1bmN0aW9uKHRhZ1BhaXJzKSB7IHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGFnUGFpcnMpIH07XG4gIHZhciBwZWckZjIgPSBmdW5jdGlvbih0YWdOYW1lLCB0YWdWYWx1ZSkgeyByZXR1cm4gW3RhZ05hbWUsIHRhZ1ZhbHVlXSB9O1xuICB2YXIgcGVnJGYzID0gZnVuY3Rpb24ocm9vdCwgbWFya2VyKSB7IHJldHVybiB7IHJvb3QsIG1hcmtlcn0gfTtcbiAgdmFyIHBlZyRmNCA9IGZ1bmN0aW9uKGNvbW1lbnQsIG1vdmVzKSB7IHJldHVybiBsaW5lVG9UcmVlKHJvb3ROb2RlKGNvbW1lbnQpLCAuLi5tb3Zlcy5mbGF0KCkpIH07XG4gIHZhciBwZWckZjUgPSBmdW5jdGlvbihzYW4sIHN1ZmZpeCwgbmFnLCBjb21tZW50LCB2YXJpYXRpb25zKSB7IHJldHVybiBub2RlKHNhbiwgc3VmZml4LCBuYWcsIGNvbW1lbnQsIHZhcmlhdGlvbnMpIH07XG4gIHZhciBwZWckZjYgPSBmdW5jdGlvbihuYWcpIHsgcmV0dXJuIG5hZyB9O1xuICB2YXIgcGVnJGY3ID0gZnVuY3Rpb24oY29tbWVudCkgeyByZXR1cm4gY29tbWVudC5yZXBsYWNlKC9bXFxyXFxuXSsvZywgXCIgXCIpIH07XG4gIHZhciBwZWckZjggPSBmdW5jdGlvbihjb21tZW50KSB7IHJldHVybiBjb21tZW50LnRyaW0oKSB9O1xuICB2YXIgcGVnJGY5ID0gZnVuY3Rpb24obGluZSkgeyByZXR1cm4gbGluZSB9O1xuICB2YXIgcGVnJGYxMCA9IGZ1bmN0aW9uKHJlc3VsdCwgY29tbWVudCkgeyByZXR1cm4geyByZXN1bHQsIGNvbW1lbnQgfSB9O1xuICB2YXIgcGVnJGN1cnJQb3MgPSBvcHRpb25zLnBlZyRjdXJyUG9zIHwgMDtcbiAgdmFyIHBlZyRwb3NEZXRhaWxzQ2FjaGUgPSBbeyBsaW5lOiAxLCBjb2x1bW46IDEgfV07XG4gIHZhciBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICB2YXIgcGVnJG1heEZhaWxFeHBlY3RlZCA9IG9wdGlvbnMucGVnJG1heEZhaWxFeHBlY3RlZCB8fCBbXTtcbiAgdmFyIHBlZyRzaWxlbnRGYWlscyA9IG9wdGlvbnMucGVnJHNpbGVudEZhaWxzIHwgMDtcblxuICB2YXIgcGVnJHJlc3VsdDtcblxuICBpZiAob3B0aW9ucy5zdGFydFJ1bGUpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbih0ZXh0LCBpZ25vcmVDYXNlKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRleHQsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjbGFzc0V4cGVjdGF0aW9uKHBhcnRzLCBpbnZlcnRlZCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiY2xhc3NcIiwgcGFydHM6IHBhcnRzLCBpbnZlcnRlZDogaW52ZXJ0ZWQsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRlbmRFeHBlY3RhdGlvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVuZFwiIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgdmFyIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc107XG4gICAgdmFyIHA7XG5cbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwb3MgPj0gcGVnJHBvc0RldGFpbHNDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgcCA9IHBlZyRwb3NEZXRhaWxzQ2FjaGUubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAgPSBwb3M7XG4gICAgICAgIHdoaWxlICghcGVnJHBvc0RldGFpbHNDYWNoZVstLXBdKSB7fVxuICAgICAgfVxuXG4gICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIGxpbmU6IGRldGFpbHMubGluZSxcbiAgICAgICAgY29sdW1uOiBkZXRhaWxzLmNvbHVtblxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHAgPCBwb3MpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocCkgPT09IDEwKSB7XG4gICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgIH1cblxuICAgICAgICBwKys7XG4gICAgICB9XG5cbiAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSA9IGRldGFpbHM7XG5cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcywgb2Zmc2V0KSB7XG4gICAgdmFyIHN0YXJ0UG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhzdGFydFBvcyk7XG4gICAgdmFyIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcblxuICAgIHZhciByZXMgPSB7XG4gICAgICBzb3VyY2U6IHBlZyRzb3VyY2UsXG4gICAgICBzdGFydDoge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0UG9zLFxuICAgICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgY29sdW1uOiBzdGFydFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIG9mZnNldDogZW5kUG9zLFxuICAgICAgICBsaW5lOiBlbmRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZW5kUG9zRGV0YWlscy5jb2x1bW5cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgfVxuXG4gICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBwZWckU3ludGF4RXJyb3IoXG4gICAgICBwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICBleHBlY3RlZCxcbiAgICAgIGZvdW5kLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlcGduKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZXRhZ1BhaXJTZWN0aW9uKCk7XG4gICAgczIgPSBwZWckcGFyc2Vtb3ZlVGV4dFNlY3Rpb24oKTtcbiAgICBzMCA9IHBlZyRmMChzMSwgczIpO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGFnUGFpclNlY3Rpb24oKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBwZWckcGFyc2V0YWdQYWlyKCk7XG4gICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMS5wdXNoKHMyKTtcbiAgICAgIHMyID0gcGVnJHBhcnNldGFnUGFpcigpO1xuICAgIH1cbiAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICBzMCA9IHBlZyRmMShzMSk7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V0YWdQYWlyKCkge1xuICAgIHZhciBzMCwgczIsIHM0LCBzNiwgczcsIHM4LCBzMTA7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICBzMiA9IHBlZyRjMDtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxKTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgIHM0ID0gcGVnJHBhcnNldGFnTmFtZSgpO1xuICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICAgIHM2ID0gcGVnJGMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM3ID0gcGVnJHBhcnNldGFnVmFsdWUoKTtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICBzOCA9IHBlZyRjMTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM4ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgczEwID0gcGVnJGMyO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczEwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGYyKHM0LCBzNyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTApOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGFnTmFtZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgaWYgKHBlZyRyMC50ZXN0KHMyKSkge1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTUpOyB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIGlmIChwZWckcjAudGVzdChzMikpIHtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBpbnB1dC5zdWJzdHJpbmcoczAsIHBlZyRjdXJyUG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBzMTtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V0YWdWYWx1ZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgaWYgKHBlZyRyMS50ZXN0KHMyKSkge1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTcpOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHIxLnRlc3QoczIpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU3KTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBzMCA9IGlucHV0LnN1YnN0cmluZyhzMCwgcGVnJGN1cnJQb3MpO1xuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNik7IH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW1vdmVUZXh0U2VjdGlvbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VsaW5lKCk7XG4gICAgcGVnJHBhcnNlXygpO1xuICAgIHMzID0gcGVnJHBhcnNlZ2FtZVRlcm1pbmF0aW9uTWFya2VyKCk7XG4gICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IG51bGw7XG4gICAgfVxuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBzMCA9IHBlZyRmMyhzMSwgczMpO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbGluZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlY29tbWVudCgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBudWxsO1xuICAgIH1cbiAgICBzMiA9IFtdO1xuICAgIHMzID0gcGVnJHBhcnNlbW92ZSgpO1xuICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIucHVzaChzMyk7XG4gICAgICBzMyA9IHBlZyRwYXJzZW1vdmUoKTtcbiAgICB9XG4gICAgczAgPSBwZWckZjQoczEsIHMyKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW1vdmUoKSB7XG4gICAgdmFyIHMwLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTA7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBwZWckcGFyc2Vtb3ZlTnVtYmVyKCk7XG4gICAgcGVnJHBhcnNlXygpO1xuICAgIHM0ID0gcGVnJHBhcnNlc2FuKCk7XG4gICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzNSA9IHBlZyRwYXJzZXN1ZmZpeEFubm90YXRpb24oKTtcbiAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNSA9IG51bGw7XG4gICAgICB9XG4gICAgICBzNiA9IFtdO1xuICAgICAgczcgPSBwZWckcGFyc2VuYWcoKTtcbiAgICAgIHdoaWxlIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNi5wdXNoKHM3KTtcbiAgICAgICAgczcgPSBwZWckcGFyc2VuYWcoKTtcbiAgICAgIH1cbiAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgczggPSBwZWckcGFyc2Vjb21tZW50KCk7XG4gICAgICBpZiAoczggPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczggPSBudWxsO1xuICAgICAgfVxuICAgICAgczkgPSBbXTtcbiAgICAgIHMxMCA9IHBlZyRwYXJzZXZhcmlhdGlvbigpO1xuICAgICAgd2hpbGUgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzOS5wdXNoKHMxMCk7XG4gICAgICAgIHMxMCA9IHBlZyRwYXJzZXZhcmlhdGlvbigpO1xuICAgICAgfVxuICAgICAgczAgPSBwZWckZjUoczQsIHM1LCBzNiwgczgsIHM5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vtb3ZlTnVtYmVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICBpZiAocGVnJHIyLnRlc3QoczIpKSB7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlOSk7IH1cbiAgICB9XG4gICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMS5wdXNoKHMyKTtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjIudGVzdChzMikpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgIHMyID0gcGVnJGMzO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTEwKTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgczQgPSBbXTtcbiAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjMudGVzdChzNSkpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTExKTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIGlmIChwZWckcjMudGVzdChzNSkpIHtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTEpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHMxID0gW3MxLCBzMiwgczMsIHM0XTtcbiAgICAgIHMwID0gczE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTgpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc2FuKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQpIHtcbiAgICAgIHMyID0gcGVnJGM0O1xuICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTEzKTsgfVxuICAgIH1cbiAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDMpID09PSBwZWckYzUpIHtcbiAgICAgICAgczIgPSBwZWckYzU7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM2KSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE1KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDMpID09PSBwZWckYzcpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGM3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBpZiAocGVnJHIwLnRlc3QoczMpKSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU1KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gW107XG4gICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgaWYgKHBlZyRyNC50ZXN0KHM1KSkge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNyk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRyNC50ZXN0KHM1KSkge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTcpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMyA9IFtzMywgczRdO1xuICAgICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI1LnRlc3QoczMpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxOCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IG51bGw7XG4gICAgICB9XG4gICAgICBzMiA9IFtzMiwgczNdO1xuICAgICAgczEgPSBzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IGlucHV0LnN1YnN0cmluZyhzMCwgcGVnJGN1cnJQb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHMxO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMik7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzdWZmaXhBbm5vdGF0aW9uKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICBpZiAocGVnJHI2LnRlc3QoczIpKSB7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjApOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBpZiAoczEubGVuZ3RoID49IDIpIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHI2LnRlc3QoczIpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIwKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMS5sZW5ndGggPCAxKSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHMxO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxOSk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VuYWcoKSB7XG4gICAgdmFyIHMwLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgcGVnJHBhcnNlXygpO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzYpIHtcbiAgICAgIHMyID0gcGVnJGM4O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIyKTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICBzNCA9IFtdO1xuICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKHBlZyRyMi50ZXN0KHM1KSkge1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlOSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgaWYgKHBlZyRyMi50ZXN0KHM1KSkge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBpbnB1dC5zdWJzdHJpbmcoczMsIHBlZyRjdXJyUG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMzID0gczQ7XG4gICAgICB9XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckZjYoczMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMSk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vjb21tZW50KCkge1xuICAgIHZhciBzMDtcblxuICAgIHMwID0gcGVnJHBhcnNlYnJhY2VDb21tZW50KCk7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZXJlc3RPZkxpbmVDb21tZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlYnJhY2VDb21tZW50KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XG4gICAgICBzMSA9IHBlZyRjOTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNCk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgczMgPSBbXTtcbiAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjcudGVzdChzNCkpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI1KTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIGlmIChwZWckcjcudGVzdChzNCkpIHtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjUpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHMyID0gaW5wdXQuc3Vic3RyaW5nKHMyLCBwZWckY3VyclBvcyk7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNSkge1xuICAgICAgICBzMyA9IHBlZyRjMTA7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRmNyhzMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIzKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXJlc3RPZkxpbmVDb21tZW50KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTkpIHtcbiAgICAgIHMxID0gcGVnJGMxMTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyOCk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgczMgPSBbXTtcbiAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjgudGVzdChzNCkpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI5KTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIGlmIChwZWckcjgudGVzdChzNCkpIHtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjkpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHMyID0gaW5wdXQuc3Vic3RyaW5nKHMyLCBwZWckY3VyclBvcyk7XG4gICAgICBzMCA9IHBlZyRmOChzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI3KTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXZhcmlhdGlvbigpIHtcbiAgICB2YXIgczAsIHMyLCBzMywgczU7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICBzMiA9IHBlZyRjMTI7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzEpOyB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczMgPSBwZWckcGFyc2VsaW5lKCk7XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7XG4gICAgICAgICAgczUgPSBwZWckYzEzO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRmOShzMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzApOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZ2FtZVRlcm1pbmF0aW9uTWFya2VyKCkge1xuICAgIHZhciBzMCwgczEsIHMzO1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGMxNCkge1xuICAgICAgczEgPSBwZWckYzE0O1xuICAgICAgcGVnJGN1cnJQb3MgKz0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM0KTsgfVxuICAgIH1cbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDMpID09PSBwZWckYzE1KSB7XG4gICAgICAgIHMxID0gcGVnJGMxNTtcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM1KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzE2KSB7XG4gICAgICAgICAgczEgPSBwZWckYzE2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzNik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQyKSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMTc7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzcpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHBhcnNlXygpO1xuICAgICAgczMgPSBwZWckcGFyc2Vjb21tZW50KCk7XG4gICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBudWxsO1xuICAgICAgfVxuICAgICAgczAgPSBwZWckZjEwKHMxLCBzMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMzKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZV8oKSB7XG4gICAgdmFyIHMwLCBzMTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gW107XG4gICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgIGlmIChwZWckcjkudGVzdChzMSkpIHtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOSk7IH1cbiAgICB9XG4gICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMC5wdXNoKHMxKTtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjkudGVzdChzMSkpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM5KTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM4KTsgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgcGVnJHJlc3VsdCA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbigpO1xuXG4gIGlmIChvcHRpb25zLnBlZyRsaWJyYXJ5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoe1xuICAgICAgcGVnJHJlc3VsdCxcbiAgICAgIHBlZyRjdXJyUG9zLFxuICAgICAgcGVnJEZBSUxFRCxcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQsXG4gICAgICBwZWckbWF4RmFpbFBvc1xuICAgIH0pO1xuICB9XG4gIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcGVnJGZhaWwocGVnJGVuZEV4cGVjdGF0aW9uKCkpO1xuICAgIH1cblxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQsXG4gICAgICBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwZWckbWF4RmFpbFBvcykgOiBudWxsLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGhcbiAgICAgICAgPyBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcyArIDEpXG4gICAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MpXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUsIEplZmYgSGx5d2EgKGpobHl3YUBnbWFpbC5jb20pXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuY29uc3QgTUFTSzY0ID0gMHhmZmZmZmZmZmZmZmZmZmZmbjtcbmZ1bmN0aW9uIHJvdGwoeCwgaykge1xuICAgIHJldHVybiAoKHggPDwgaykgfCAoeCA+PiAoNjRuIC0gaykpKSAmIDB4ZmZmZmZmZmZmZmZmZmZmZm47XG59XG5mdW5jdGlvbiB3cmFwcGluZ011bCh4LCB5KSB7XG4gICAgcmV0dXJuICh4ICogeSkgJiBNQVNLNjQ7XG59XG4vLyB4b3Jvc2hpcm8xMjgqKlxuZnVuY3Rpb24geG9yb3NoaXJvMTI4KHN0YXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHMwID0gQmlnSW50KHN0YXRlICYgTUFTSzY0KTtcbiAgICAgICAgbGV0IHMxID0gQmlnSW50KChzdGF0ZSA+PiA2NG4pICYgTUFTSzY0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd3JhcHBpbmdNdWwocm90bCh3cmFwcGluZ011bChzMCwgNW4pLCA3biksIDluKTtcbiAgICAgICAgczEgXj0gczA7XG4gICAgICAgIHMwID0gKHJvdGwoczAsIDI0bikgXiBzMSBeIChzMSA8PCAxNm4pKSAmIE1BU0s2NDtcbiAgICAgICAgczEgPSByb3RsKHMxLCAzN24pO1xuICAgICAgICBzdGF0ZSA9IChzMSA8PCA2NG4pIHwgczA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmNvbnN0IHJhbmQgPSB4b3Jvc2hpcm8xMjgoMHhhMTg3ZWIzOWNkY2FlZDhmMzFjNGIzNjViMTAyZTAxZW4pO1xuY29uc3QgUElFQ0VfS0VZUyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDIgfSwgKCkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogNiB9LCAoKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMjggfSwgKCkgPT4gcmFuZCgpKSkpO1xuY29uc3QgRVBfS0VZUyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDggfSwgKCkgPT4gcmFuZCgpKTtcbmNvbnN0IENBU1RMSU5HX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoKSA9PiByYW5kKCkpO1xuY29uc3QgU0lERV9LRVkgPSByYW5kKCk7XG5jb25zdCBXSElURSA9ICd3JztcbmNvbnN0IEJMQUNLID0gJ2InO1xuY29uc3QgUEFXTiA9ICdwJztcbmNvbnN0IEtOSUdIVCA9ICduJztcbmNvbnN0IEJJU0hPUCA9ICdiJztcbmNvbnN0IFJPT0sgPSAncic7XG5jb25zdCBRVUVFTiA9ICdxJztcbmNvbnN0IEtJTkcgPSAnayc7XG5jb25zdCBERUZBVUxUX1BPU0lUSU9OID0gJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxJztcbmNsYXNzIE1vdmUge1xuICAgIGNvbG9yO1xuICAgIGZyb207XG4gICAgdG87XG4gICAgcGllY2U7XG4gICAgY2FwdHVyZWQ7XG4gICAgcHJvbW90aW9uO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmllbGQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMi4wLjAuXG4gICAgICogUGxlYXNlIHVzZSBtb3ZlIGRlc2NyaXB0b3IgZnVuY3Rpb25zIGluc3RlYWQ6IGBpc0NhcHR1cmVgLCBgaXNQcm9tb3Rpb25gLFxuICAgICAqIGBpc0VuUGFzc2FudGAsIGBpc0tpbmdzaWRlQ2FzdGxlYCwgYGlzUXVlZW5zaWRlQ2FzdGxlYCwgYGlzQ2FzdGxlYCwgYW5kXG4gICAgICogYGlzQmlnUGF3bmBcbiAgICAgKi9cbiAgICBmbGFncztcbiAgICBzYW47XG4gICAgbGFuO1xuICAgIGJlZm9yZTtcbiAgICBhZnRlcjtcbiAgICBjb25zdHJ1Y3RvcihjaGVzcywgaW50ZXJuYWwpIHtcbiAgICAgICAgY29uc3QgeyBjb2xvciwgcGllY2UsIGZyb20sIHRvLCBmbGFncywgY2FwdHVyZWQsIHByb21vdGlvbiB9ID0gaW50ZXJuYWw7XG4gICAgICAgIGNvbnN0IGZyb21BbGdlYnJhaWMgPSBhbGdlYnJhaWMoZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvQWxnZWJyYWljID0gYWxnZWJyYWljKHRvKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLnBpZWNlID0gcGllY2U7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb21BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMudG8gPSB0b0FsZ2VicmFpYztcbiAgICAgICAgLypcbiAgICAgICAgICogSEFDSzogVGhlIGNoZXNzWydfbWV0aG9kJ10oKSBjYWxscyBiZWxvdyBpbnZva2UgcHJpdmF0ZSBtZXRob2RzIGluIHRoZVxuICAgICAgICAgKiBDaGVzcyBjbGFzcyB0byBnZW5lcmF0ZSBTQU4gYW5kIEZFTi4gSXQncyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBtYWtlcyB0aGVcbiAgICAgICAgICogY29kZSBjbGVhbmVyIGVsc2V3aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2FuID0gY2hlc3NbJ19tb3ZlVG9TYW4nXShpbnRlcm5hbCwgY2hlc3NbJ19tb3ZlcyddKHsgbGVnYWw6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLmxhbiA9IGZyb21BbGdlYnJhaWMgKyB0b0FsZ2VicmFpYztcbiAgICAgICAgdGhpcy5iZWZvcmUgPSBjaGVzcy5mZW4oKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIEZFTiBmb3IgdGhlICdhZnRlcicga2V5XG4gICAgICAgIGNoZXNzWydfbWFrZU1vdmUnXShpbnRlcm5hbCk7XG4gICAgICAgIHRoaXMuYWZ0ZXIgPSBjaGVzcy5mZW4oKTtcbiAgICAgICAgY2hlc3NbJ191bmRvTW92ZSddKCk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb3ZlIGZsYWdzXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIEJJVFMpIHtcbiAgICAgICAgICAgIGlmIChCSVRTW2ZsYWddICYgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzICs9IEZMQUdTW2ZsYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYXB0dXJlZCkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlZCA9IGNhcHR1cmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tb3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHJvbW90aW9uID0gcHJvbW90aW9uO1xuICAgICAgICAgICAgdGhpcy5sYW4gKz0gcHJvbW90aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ2FwdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc1Byb21vdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snUFJPTU9USU9OJ10pID4gLTE7XG4gICAgfVxuICAgIGlzRW5QYXNzYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydFUF9DQVBUVVJFJ10pID4gLTE7XG4gICAgfVxuICAgIGlzS2luZ3NpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0tTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc1F1ZWVuc2lkZUNhc3RsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snUVNJREVfQ0FTVExFJ10pID4gLTE7XG4gICAgfVxuICAgIGlzQmlnUGF3bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snQklHX1BBV04nXSkgPiAtMTtcbiAgICB9XG59XG5jb25zdCBFTVBUWSA9IC0xO1xuY29uc3QgRkxBR1MgPSB7XG4gICAgTk9STUFMOiAnbicsXG4gICAgQ0FQVFVSRTogJ2MnLFxuICAgIEJJR19QQVdOOiAnYicsXG4gICAgRVBfQ0FQVFVSRTogJ2UnLFxuICAgIFBST01PVElPTjogJ3AnLFxuICAgIEtTSURFX0NBU1RMRTogJ2snLFxuICAgIFFTSURFX0NBU1RMRTogJ3EnLFxuICAgIE5VTExfTU9WRTogJy0nLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU1FVQVJFUyA9IFtcbiAgICAnYTgnLCAnYjgnLCAnYzgnLCAnZDgnLCAnZTgnLCAnZjgnLCAnZzgnLCAnaDgnLFxuICAgICdhNycsICdiNycsICdjNycsICdkNycsICdlNycsICdmNycsICdnNycsICdoNycsXG4gICAgJ2E2JywgJ2I2JywgJ2M2JywgJ2Q2JywgJ2U2JywgJ2Y2JywgJ2c2JywgJ2g2JyxcbiAgICAnYTUnLCAnYjUnLCAnYzUnLCAnZDUnLCAnZTUnLCAnZjUnLCAnZzUnLCAnaDUnLFxuICAgICdhNCcsICdiNCcsICdjNCcsICdkNCcsICdlNCcsICdmNCcsICdnNCcsICdoNCcsXG4gICAgJ2EzJywgJ2IzJywgJ2MzJywgJ2QzJywgJ2UzJywgJ2YzJywgJ2czJywgJ2gzJyxcbiAgICAnYTInLCAnYjInLCAnYzInLCAnZDInLCAnZTInLCAnZjInLCAnZzInLCAnaDInLFxuICAgICdhMScsICdiMScsICdjMScsICdkMScsICdlMScsICdmMScsICdnMScsICdoMSdcbl07XG5jb25zdCBCSVRTID0ge1xuICAgIE5PUk1BTDogMSxcbiAgICBDQVBUVVJFOiAyLFxuICAgIEJJR19QQVdOOiA0LFxuICAgIEVQX0NBUFRVUkU6IDgsXG4gICAgUFJPTU9USU9OOiAxNixcbiAgICBLU0lERV9DQVNUTEU6IDMyLFxuICAgIFFTSURFX0NBU1RMRTogNjQsXG4gICAgTlVMTF9NT1ZFOiAxMjgsXG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4vLyB0aGVzZSBhcmUgcmVxdWlyZWQsIGFjY29yZGluZyB0byBzcGVjXG5jb25zdCBTRVZFTl9UQUdfUk9TVEVSID0ge1xuICAgIEV2ZW50OiAnPycsXG4gICAgU2l0ZTogJz8nLFxuICAgIERhdGU6ICc/Pz8/Lj8/Lj8/JyxcbiAgICBSb3VuZDogJz8nLFxuICAgIFdoaXRlOiAnPycsXG4gICAgQmxhY2s6ICc/JyxcbiAgICBSZXN1bHQ6ICcqJyxcbn07XG4vKipcbiAqIFRoZXNlIG51bGxzIGFyZSBwbGFjZWhvbGRlcnMgdG8gZml4IHRoZSBvcmRlciBvZiB0YWdzIChhcyB0aGV5IGFwcGVhciBpbiBQR04gc3BlYyk7IG51bGwgdmFsdWVzIHdpbGwgYmVcbiAqIGVsaW1pbmF0ZWQgaW4gZ2V0SGVhZGVycygpXG4gKi9cbmNvbnN0IFNVUExFTUVOVEFMX1RBR1MgPSB7XG4gICAgV2hpdGVUaXRsZTogbnVsbCxcbiAgICBCbGFja1RpdGxlOiBudWxsLFxuICAgIFdoaXRlRWxvOiBudWxsLFxuICAgIEJsYWNrRWxvOiBudWxsLFxuICAgIFdoaXRlVVNDRjogbnVsbCxcbiAgICBCbGFja1VTQ0Y6IG51bGwsXG4gICAgV2hpdGVOQTogbnVsbCxcbiAgICBCbGFja05BOiBudWxsLFxuICAgIFdoaXRlVHlwZTogbnVsbCxcbiAgICBCbGFja1R5cGU6IG51bGwsXG4gICAgRXZlbnREYXRlOiBudWxsLFxuICAgIEV2ZW50U3BvbnNvcjogbnVsbCxcbiAgICBTZWN0aW9uOiBudWxsLFxuICAgIFN0YWdlOiBudWxsLFxuICAgIEJvYXJkOiBudWxsLFxuICAgIE9wZW5pbmc6IG51bGwsXG4gICAgVmFyaWF0aW9uOiBudWxsLFxuICAgIFN1YlZhcmlhdGlvbjogbnVsbCxcbiAgICBFQ086IG51bGwsXG4gICAgTklDOiBudWxsLFxuICAgIFRpbWU6IG51bGwsXG4gICAgVVRDVGltZTogbnVsbCxcbiAgICBVVENEYXRlOiBudWxsLFxuICAgIFRpbWVDb250cm9sOiBudWxsLFxuICAgIFNldFVwOiBudWxsLFxuICAgIEZFTjogbnVsbCxcbiAgICBUZXJtaW5hdGlvbjogbnVsbCxcbiAgICBBbm5vdGF0b3I6IG51bGwsXG4gICAgTW9kZTogbnVsbCxcbiAgICBQbHlDb3VudDogbnVsbCxcbn07XG5jb25zdCBIRUFERVJfVEVNUExBVEUgPSB7XG4gICAgLi4uU0VWRU5fVEFHX1JPU1RFUixcbiAgICAuLi5TVVBMRU1FTlRBTF9UQUdTLFxufTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4vKlxuICogTk9URVMgQUJPVVQgMHg4OCBNT1ZFIEdFTkVSQVRJT04gQUxHT1JJVEhNXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGx5d2EvY2hlc3MuanMvaXNzdWVzLzIzMFxuICpcbiAqIEEgbG90IG9mIHBlb3BsZSBhcmUgY29uZnVzZWQgd2hlbiB0aGV5IGZpcnN0IHNlZSB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAqIG9mIGNoZXNzLmpzLiBJdCB1c2VzIHRoZSAweDg4IE1vdmUgR2VuZXJhdGlvbiBBbGdvcml0aG0gd2hpY2ggaW50ZXJuYWxseVxuICogc3RvcmVzIHRoZSBib2FyZCBhcyBhbiA4eDE2IGFycmF5LiBUaGlzIGlzIHB1cmVseSBmb3IgZWZmaWNpZW5jeSBidXQgaGFzIGFcbiAqIGNvdXBsZSBvZiBpbnRlcmVzdGluZyBiZW5lZml0czpcbiAqXG4gKiAxLiAweDg4IG9mZmVycyBhIHZlcnkgaW5leHBlbnNpdmUgXCJvZmYgdGhlIGJvYXJkXCIgY2hlY2suIEJpdHdpc2UgQU5EICgmKSBhbnlcbiAqICAgIHNxdWFyZSB3aXRoIDB4ODgsIGlmIHRoZSByZXN1bHQgaXMgbm9uLXplcm8gdGhlbiB0aGUgc3F1YXJlIGlzIG9mZiB0aGVcbiAqICAgIGJvYXJkLiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSBrbmlnaHQgc3F1YXJlIEE4ICgwIGluIDB4ODggbm90YXRpb24pLFxuICogICAgdGhlcmUgYXJlIDggcG9zc2libGUgZGlyZWN0aW9ucyBpbiB3aGljaCB0aGUga25pZ2h0IGNhbiBtb3ZlLiBUaGVzZVxuICogICAgZGlyZWN0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhlIDh4MTYgYm9hcmQgYW5kIGFyZSBzdG9yZWQgaW4gdGhlXG4gKiAgICBQSUVDRV9PRkZTRVRTIG1hcC4gT25lIHBvc3NpYmxlIG1vdmUgaXMgQTggLSAxOCAodXAgb25lIHNxdWFyZSwgYW5kIHR3b1xuICogICAgc3F1YXJlcyB0byB0aGUgbGVmdCAtIHdoaWNoIGlzIG9mZiB0aGUgYm9hcmQpLiAwIC0gMTggPSAtMTggJiAweDg4ID0gMHg4OFxuICogICAgKGJlY2F1c2Ugb2YgdHdvLWNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gb2YgLTE4KS4gVGhlIG5vbi16ZXJvIHJlc3VsdFxuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvZmYgdGhlIGJvYXJkIGFuZCB0aGUgbW92ZSBpcyBpbGxlZ2FsLiBUYWtlIHRoZVxuICogICAgb3Bwb3NpdGUgbW92ZSAoZnJvbSBBOCB0byBDNyksIDAgKyAxOCA9IDE4ICYgMHg4OCA9IDAuIEEgcmVzdWx0IG9mIHplcm9cbiAqICAgIG1lYW5zIHRoZSBzcXVhcmUgaXMgb24gdGhlIGJvYXJkLlxuICpcbiAqIDIuIFRoZSByZWxhdGl2ZSBkaXN0YW5jZSAob3IgZGlmZmVyZW5jZSkgYmV0d2VlbiB0d28gc3F1YXJlcyBvbiBhIDh4MTYgYm9hcmRcbiAqICAgIGlzIHVuaXF1ZSBhbmQgY2FuIGJlIHVzZWQgdG8gaW5leHBlbnNpdmVseSBkZXRlcm1pbmUgaWYgYSBwaWVjZSBvbiBhXG4gKiAgICBzcXVhcmUgY2FuIGF0dGFjayBhbnkgb3RoZXIgYXJiaXRyYXJ5IHNxdWFyZS4gRm9yIGV4YW1wbGUsIGxldCdzIHNlZSBpZiBhXG4gKiAgICBwYXduIG9uIEU3IGNhbiBhdHRhY2sgRTIuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gRTcgKDIwKSAtIEUyICgxMDApIGlzXG4gKiAgICAtODAuIFdlIGFkZCAxMTkgdG8gbWFrZSB0aGUgQVRUQUNLUyBhcnJheSBpbmRleCBub24tbmVnYXRpdmUgKGJlY2F1c2UgdGhlXG4gKiAgICB3b3JzdCBjYXNlIGRpZmZlcmVuY2UgaXMgQTggLSBIMSA9IC0xMTkpLiBUaGUgQVRUQUNLUyBhcnJheSBjb250YWlucyBhXG4gKiAgICBiaXRtYXNrIG9mIHBpZWNlcyB0aGF0IGNhbiBhdHRhY2sgZnJvbSB0aGF0IGRpc3RhbmNlIGFuZCBkaXJlY3Rpb24uXG4gKiAgICBBVFRBQ0tTWy04MCArIDExOT0zOV0gZ2l2ZXMgdXMgMjQgb3IgMGIxMTAwMCBpbiBiaW5hcnkuIExvb2sgYXQgdGhlXG4gKiAgICBQSUVDRV9NQVNLUyBtYXAgdG8gZGV0ZXJtaW5lIHRoZSBtYXNrIGZvciBhIGdpdmVuIHBpZWNlIHR5cGUuIEluIG91ciBwYXduXG4gKiAgICBleGFtcGxlLCB3ZSB3b3VsZCBjaGVjayB0byBzZWUgaWYgMjQgJiAweDEgaXMgbm9uLXplcm8sIHdoaWNoIGl0IGlzXG4gKiAgICBub3QuIFNvLCBuYXR1cmFsbHksIGEgcGF3biBvbiBFNyBjYW4ndCBhdHRhY2sgYSBwaWVjZSBvbiBFMi4gSG93ZXZlciwgYVxuICogICAgcm9vayBjYW4gc2luY2UgMjQgJiAweDggaXMgbm9uLXplcm8uIFRoZSBvbmx5IHRoaW5nIGxlZnQgdG8gY2hlY2sgaXMgdGhhdFxuICogICAgdGhlcmUgYXJlIG5vIGJsb2NraW5nIHBpZWNlcyBiZXR3ZWVuIEU3IGFuZCBFMi4gVGhhdCdzIHdoZXJlIHRoZSBSQVlTXG4gKiAgICBhcnJheSBjb21lcyBpbi4gSXQgcHJvdmlkZXMgYW4gb2Zmc2V0IChpbiB0aGlzIGNhc2UgMTYpIHRvIGFkZCB0byBFNyAoMjApXG4gKiAgICB0byBjaGVjayBmb3IgYmxvY2tpbmcgcGllY2VzLiBFNyAoMjApICsgMTYgPSBFNiAoMzYpICsgMTYgPSBFNSAoNTIpIGV0Yy5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IE94ODggPSB7XG4gICAgYTg6IDAsIGI4OiAxLCBjODogMiwgZDg6IDMsIGU4OiA0LCBmODogNSwgZzg6IDYsIGg4OiA3LFxuICAgIGE3OiAxNiwgYjc6IDE3LCBjNzogMTgsIGQ3OiAxOSwgZTc6IDIwLCBmNzogMjEsIGc3OiAyMiwgaDc6IDIzLFxuICAgIGE2OiAzMiwgYjY6IDMzLCBjNjogMzQsIGQ2OiAzNSwgZTY6IDM2LCBmNjogMzcsIGc2OiAzOCwgaDY6IDM5LFxuICAgIGE1OiA0OCwgYjU6IDQ5LCBjNTogNTAsIGQ1OiA1MSwgZTU6IDUyLCBmNTogNTMsIGc1OiA1NCwgaDU6IDU1LFxuICAgIGE0OiA2NCwgYjQ6IDY1LCBjNDogNjYsIGQ0OiA2NywgZTQ6IDY4LCBmNDogNjksIGc0OiA3MCwgaDQ6IDcxLFxuICAgIGEzOiA4MCwgYjM6IDgxLCBjMzogODIsIGQzOiA4MywgZTM6IDg0LCBmMzogODUsIGczOiA4NiwgaDM6IDg3LFxuICAgIGEyOiA5NiwgYjI6IDk3LCBjMjogOTgsIGQyOiA5OSwgZTI6IDEwMCwgZjI6IDEwMSwgZzI6IDEwMiwgaDI6IDEwMyxcbiAgICBhMTogMTEyLCBiMTogMTEzLCBjMTogMTE0LCBkMTogMTE1LCBlMTogMTE2LCBmMTogMTE3LCBnMTogMTE4LCBoMTogMTE5XG59O1xuY29uc3QgUEFXTl9PRkZTRVRTID0ge1xuICAgIGI6IFsxNiwgMzIsIDE3LCAxNV0sXG4gICAgdzogWy0xNiwgLTMyLCAtMTcsIC0xNV0sXG59O1xuY29uc3QgUElFQ0VfT0ZGU0VUUyA9IHtcbiAgICBuOiBbLTE4LCAtMzMsIC0zMSwgLTE0LCAxOCwgMzMsIDMxLCAxNF0sXG4gICAgYjogWy0xNywgLTE1LCAxNywgMTVdLFxuICAgIHI6IFstMTYsIDEsIDE2LCAtMV0sXG4gICAgcTogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcbiAgICBrOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQVRUQUNLUyA9IFtcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLFxuICAgIDAsIDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsXG4gICAgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAyNCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMjAsIDIsIDI0LCAyLCAyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDU2LCAwLCA1NiwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwXG5dO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBSQVlTID0gW1xuICAgIDE3LCAwLCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsXG4gICAgMCwgMTcsIDAsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAwLCAxNSwgMCwgMCxcbiAgICAwLCAwLCAxNywgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDE3LCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMTcsIDAsIDAsIDE2LCAwLCAwLCAxNSwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAxNywgMCwgMTYsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDE3LCAxNiwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgLTE1LCAtMTYsIC0xNywgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAtMTUsIDAsIC0xNiwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIC0xNSwgMCwgMCwgLTE2LCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgLTE1LCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAtMTUsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLFxuICAgIDAsIC0xNSwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAtMTcsIDAsIDAsXG4gICAgLTE1LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIDAsIC0xN1xuXTtcbmNvbnN0IFBJRUNFX01BU0tTID0geyBwOiAweDEsIG46IDB4MiwgYjogMHg0LCByOiAweDgsIHE6IDB4MTAsIGs6IDB4MjAgfTtcbmNvbnN0IFNZTUJPTFMgPSAncG5icnFrUE5CUlFLJztcbmNvbnN0IFBST01PVElPTlMgPSBbS05JR0hULCBCSVNIT1AsIFJPT0ssIFFVRUVOXTtcbmNvbnN0IFJBTktfMSA9IDc7XG5jb25zdCBSQU5LXzIgPSA2O1xuLypcbiAqIGNvbnN0IFJBTktfMyA9IDVcbiAqIGNvbnN0IFJBTktfNCA9IDRcbiAqIGNvbnN0IFJBTktfNSA9IDNcbiAqIGNvbnN0IFJBTktfNiA9IDJcbiAqL1xuY29uc3QgUkFOS183ID0gMTtcbmNvbnN0IFJBTktfOCA9IDA7XG5jb25zdCBTSURFUyA9IHtcbiAgICBbS0lOR106IEJJVFMuS1NJREVfQ0FTVExFLFxuICAgIFtRVUVFTl06IEJJVFMuUVNJREVfQ0FTVExFLFxufTtcbmNvbnN0IFJPT0tTID0ge1xuICAgIHc6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTEsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG4gICAgYjogW1xuICAgICAgICB7IHNxdWFyZTogT3g4OC5hOCwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICAgICAgeyBzcXVhcmU6IE94ODguaDgsIGZsYWc6IEJJVFMuS1NJREVfQ0FTVExFIH0sXG4gICAgXSxcbn07XG5jb25zdCBTRUNPTkRfUkFOSyA9IHsgYjogUkFOS183LCB3OiBSQU5LXzIgfTtcbmNvbnN0IFNBTl9OVUxMTU9WRSA9ICctLSc7XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCByYW5rIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gcmFuayhzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlID4+IDQ7XG59XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCBmaWxlIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gZmlsZShzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlICYgMHhmO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjKSB7XG4gICAgcmV0dXJuICcwMTIzNDU2Nzg5Jy5pbmRleE9mKGMpICE9PSAtMTtcbn1cbi8vIENvbnZlcnRzIGEgMHg4OCBzcXVhcmUgdG8gYWxnZWJyYWljIG5vdGF0aW9uLlxuZnVuY3Rpb24gYWxnZWJyYWljKHNxdWFyZSkge1xuICAgIGNvbnN0IGYgPSBmaWxlKHNxdWFyZSk7XG4gICAgY29uc3QgciA9IHJhbmsoc3F1YXJlKTtcbiAgICByZXR1cm4gKCdhYmNkZWZnaCcuc3Vic3RyaW5nKGYsIGYgKyAxKSArXG4gICAgICAgICc4NzY1NDMyMScuc3Vic3RyaW5nKHIsIHIgKyAxKSk7XG59XG5mdW5jdGlvbiBzd2FwQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IgPT09IFdISVRFID8gQkxBQ0sgOiBXSElURTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRmVuKGZlbikge1xuICAgIC8vIDFzdCBjcml0ZXJpb246IDYgc3BhY2Utc2VwZXJhdGVkIGZpZWxkcz9cbiAgICBjb25zdCB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCAhPT0gNikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogbXVzdCBjb250YWluIHNpeCBzcGFjZS1kZWxpbWl0ZWQgZmllbGRzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gMm5kIGNyaXRlcmlvbjogbW92ZSBudW1iZXIgZmllbGQgaXMgYSBpbnRlZ2VyIHZhbHVlID4gMD9cbiAgICBjb25zdCBtb3ZlTnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMCk7XG4gICAgaWYgKGlzTmFOKG1vdmVOdW1iZXIpIHx8IG1vdmVOdW1iZXIgPD0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogbW92ZSBudW1iZXIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAzcmQgY3JpdGVyaW9uOiBoYWxmIG1vdmUgY291bnRlciBpcyBhbiBpbnRlZ2VyID49IDA/XG4gICAgY29uc3QgaGFsZk1vdmVzID0gcGFyc2VJbnQodG9rZW5zWzRdLCAxMCk7XG4gICAgaWYgKGlzTmFOKGhhbGZNb3ZlcykgfHwgaGFsZk1vdmVzIDwgMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogaGFsZiBtb3ZlIGNvdW50ZXIgbnVtYmVyIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDR0aCBjcml0ZXJpb246IDR0aCBmaWVsZCBpcyBhIHZhbGlkIGUucC4tc3RyaW5nP1xuICAgIGlmICghL14oLXxbYWJjZGVmZ2hdWzM2XSkkLy50ZXN0KHRva2Vuc1szXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBlbi1wYXNzYW50IHNxdWFyZSBpcyBpbnZhbGlkJyB9O1xuICAgIH1cbiAgICAvLyA1dGggY3JpdGVyaW9uOiAzdGggZmllbGQgaXMgYSB2YWxpZCBjYXN0bGUtc3RyaW5nP1xuICAgIGlmICgvW15rS3FRLV0vLnRlc3QodG9rZW5zWzJdKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IGNhc3RsaW5nIGF2YWlsYWJpbGl0eSBpcyBpbnZhbGlkJyB9O1xuICAgIH1cbiAgICAvLyA2dGggY3JpdGVyaW9uOiAybmQgZmllbGQgaXMgXCJ3XCIgKHdoaXRlKSBvciBcImJcIiAoYmxhY2spP1xuICAgIGlmICghL14od3xiKSQvLnRlc3QodG9rZW5zWzFdKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IHNpZGUtdG8tbW92ZSBpcyBpbnZhbGlkJyB9O1xuICAgIH1cbiAgICAvLyA3dGggY3JpdGVyaW9uOiAxc3QgZmllbGQgY29udGFpbnMgOCByb3dzP1xuICAgIGNvbnN0IHJvd3MgPSB0b2tlbnNbMF0uc3BsaXQoJy8nKTtcbiAgICBpZiAocm93cy5sZW5ndGggIT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGRvZXMgbm90IGNvbnRhaW4gOCAnLyctZGVsaW1pdGVkIHJvd3NcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gOHRoIGNyaXRlcmlvbjogZXZlcnkgcm93IGlzIHZhbGlkP1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBjaGVjayBmb3IgcmlnaHQgc3VtIG9mIGZpZWxkcyBBTkQgbm90IHR3byBudW1iZXJzIGluIHN1Y2Nlc3Npb25cbiAgICAgICAgbGV0IHN1bUZpZWxkcyA9IDA7XG4gICAgICAgIGxldCBwcmV2aW91c1dhc051bWJlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvd3NbaV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzV2FzTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGNvbnNlY3V0aXZlIG51bWJlciknLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW1GaWVsZHMgKz0gcGFyc2VJbnQocm93c1tpXVtrXSwgMTApO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzV2FzTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghL15bcHJuYnFrUFJOQlFLXSQvLnRlc3Qocm93c1tpXVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAoaW52YWxpZCBwaWVjZSknLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW1GaWVsZHMgKz0gMTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdW1GaWVsZHMgIT09IDgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAodG9vIG1hbnkgc3F1YXJlcyBpbiByYW5rKScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDl0aCBjcml0ZXJpb246IGlzIGVuLXBhc3NhbnQgc3F1YXJlIGxlZ2FsP1xuICAgIGlmICgodG9rZW5zWzNdWzFdID09ICczJyAmJiB0b2tlbnNbMV0gPT0gJ3cnKSB8fFxuICAgICAgICAodG9rZW5zWzNdWzFdID09ICc2JyAmJiB0b2tlbnNbMV0gPT0gJ2InKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IGlsbGVnYWwgZW4tcGFzc2FudCBzcXVhcmUnIH07XG4gICAgfVxuICAgIC8vIDEwdGggY3JpdGVyaW9uOiBkb2VzIGNoZXNzIHBvc2l0aW9uIGNvbnRhaW4gZXhhY3QgdHdvIGtpbmdzP1xuICAgIGNvbnN0IGtpbmdzID0gW1xuICAgICAgICB7IGNvbG9yOiAnd2hpdGUnLCByZWdleDogL0svZyB9LFxuICAgICAgICB7IGNvbG9yOiAnYmxhY2snLCByZWdleDogL2svZyB9LFxuICAgIF07XG4gICAgZm9yIChjb25zdCB7IGNvbG9yLCByZWdleCB9IG9mIGtpbmdzKSB7XG4gICAgICAgIGlmICghcmVnZXgudGVzdCh0b2tlbnNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IG1pc3NpbmcgJHtjb2xvcn0ga2luZ2AgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRva2Vuc1swXS5tYXRjaChyZWdleCkgfHwgW10pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGBJbnZhbGlkIEZFTjogdG9vIG1hbnkgJHtjb2xvcn0ga2luZ3NgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMTF0aCBjcml0ZXJpb246IGFyZSBhbnkgcGF3bnMgb24gdGhlIGZpcnN0IG9yIGVpZ2h0aCByb3dzP1xuICAgIGlmIChBcnJheS5mcm9tKHJvd3NbMF0gKyByb3dzWzddKS5zb21lKChjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkgPT09ICdQJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHNvbWUgcGF3bnMgYXJlIG9uIHRoZSBlZGdlIHJvd3MnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xufVxuLy8gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFtYmlndW91cyBtb3Zlc1xuZnVuY3Rpb24gZ2V0RGlzYW1iaWd1YXRvcihtb3ZlLCBtb3Zlcykge1xuICAgIGNvbnN0IGZyb20gPSBtb3ZlLmZyb207XG4gICAgY29uc3QgdG8gPSBtb3ZlLnRvO1xuICAgIGNvbnN0IHBpZWNlID0gbW92ZS5waWVjZTtcbiAgICBsZXQgYW1iaWd1aXRpZXMgPSAwO1xuICAgIGxldCBzYW1lUmFuayA9IDA7XG4gICAgbGV0IHNhbWVGaWxlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW1iaWdGcm9tID0gbW92ZXNbaV0uZnJvbTtcbiAgICAgICAgY29uc3QgYW1iaWdUbyA9IG1vdmVzW2ldLnRvO1xuICAgICAgICBjb25zdCBhbWJpZ1BpZWNlID0gbW92ZXNbaV0ucGllY2U7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGlmIGEgbW92ZSBvZiB0aGUgc2FtZSBwaWVjZSB0eXBlIGVuZHMgb24gdGhlIHNhbWUgdG8gc3F1YXJlLCB3ZSdsbCBuZWVkXG4gICAgICAgICAqIHRvIGFkZCBhIGRpc2FtYmlndWF0b3IgdG8gdGhlIGFsZ2VicmFpYyBub3RhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHBpZWNlID09PSBhbWJpZ1BpZWNlICYmIGZyb20gIT09IGFtYmlnRnJvbSAmJiB0byA9PT0gYW1iaWdUbykge1xuICAgICAgICAgICAgYW1iaWd1aXRpZXMrKztcbiAgICAgICAgICAgIGlmIChyYW5rKGZyb20pID09PSByYW5rKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lUmFuaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGUoZnJvbSkgPT09IGZpbGUoYW1iaWdGcm9tKSkge1xuICAgICAgICAgICAgICAgIHNhbWVGaWxlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFtYmlndWl0aWVzID4gMCkge1xuICAgICAgICBpZiAoc2FtZVJhbmsgPiAwICYmIHNhbWVGaWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZXJlIGV4aXN0cyBhIHNpbWlsYXIgbW92aW5nIHBpZWNlIG9uIHRoZSBzYW1lIHJhbmsgYW5kIGZpbGUgYXNcbiAgICAgICAgICAgICAqIHRoZSBtb3ZlIGluIHF1ZXN0aW9uLCB1c2UgdGhlIHNxdWFyZSBhcyB0aGUgZGlzYW1iaWd1YXRvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNhbWVGaWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZSBtb3ZpbmcgcGllY2UgcmVzdHMgb24gdGhlIHNhbWUgZmlsZSwgdXNlIHRoZSByYW5rIHN5bWJvbCBhcyB0aGVcbiAgICAgICAgICAgICAqIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKS5jaGFyQXQoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlIHVzZSB0aGUgZmlsZSBzeW1ib2xcbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGFkZE1vdmUobW92ZXMsIGNvbG9yLCBmcm9tLCB0bywgcGllY2UsIGNhcHR1cmVkID0gdW5kZWZpbmVkLCBmbGFncyA9IEJJVFMuTk9STUFMKSB7XG4gICAgY29uc3QgciA9IHJhbmsodG8pO1xuICAgIGlmIChwaWVjZSA9PT0gUEFXTiAmJiAociA9PT0gUkFOS18xIHx8IHIgPT09IFJBTktfOCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9NT1RJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tb3Rpb24gPSBQUk9NT1RJT05TW2ldO1xuICAgICAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24sXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzIHwgQklUUy5QUk9NT1RJT04sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHBpZWNlLFxuICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICBmbGFncyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5mZXJQaWVjZVR5cGUoc2FuKSB7XG4gICAgbGV0IHBpZWNlVHlwZSA9IHNhbi5jaGFyQXQoMCk7XG4gICAgaWYgKHBpZWNlVHlwZSA+PSAnYScgJiYgcGllY2VUeXBlIDw9ICdoJykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gc2FuLm1hdGNoKC9bYS1oXVxcZC4qW2EtaF1cXGQvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBV047XG4gICAgfVxuICAgIHBpZWNlVHlwZSA9IHBpZWNlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwaWVjZVR5cGUgPT09ICdvJykge1xuICAgICAgICByZXR1cm4gS0lORztcbiAgICB9XG4gICAgcmV0dXJuIHBpZWNlVHlwZTtcbn1cbi8vIHBhcnNlcyBhbGwgb2YgdGhlIGRlY29yYXRvcnMgb3V0IG9mIGEgU0FOIHN0cmluZ1xuZnVuY3Rpb24gc3RyaXBwZWRTYW4obW92ZSkge1xuICAgIHJldHVybiBtb3ZlLnJlcGxhY2UoLz0vLCAnJykucmVwbGFjZSgvWysjXT9bPyFdKiQvLCAnJyk7XG59XG5jbGFzcyBDaGVzcyB7XG4gICAgX2JvYXJkID0gbmV3IEFycmF5KDEyOCk7XG4gICAgX3R1cm4gPSBXSElURTtcbiAgICBfaGVhZGVyID0ge307XG4gICAgX2tpbmdzID0geyB3OiBFTVBUWSwgYjogRU1QVFkgfTtcbiAgICBfZXBTcXVhcmUgPSAtMTtcbiAgICBfaGFsZk1vdmVzID0gMDtcbiAgICBfbW92ZU51bWJlciA9IDA7XG4gICAgX2hpc3RvcnkgPSBbXTtcbiAgICBfY29tbWVudHMgPSB7fTtcbiAgICBfY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICBfaGFzaCA9IDBuO1xuICAgIC8vIHRyYWNrcyBudW1iZXIgb2YgdGltZXMgYSBwb3NpdGlvbiBoYXMgYmVlbiBzZWVuIGZvciByZXBldGl0aW9uIGNoZWNraW5nXG4gICAgX3Bvc2l0aW9uQ291bnQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3RydWN0b3IoZmVuID0gREVGQVVMVF9QT1NJVElPTiwgeyBza2lwVmFsaWRhdGlvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uIH0pO1xuICAgIH1cbiAgICBjbGVhcih7IHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgICAgICB0aGlzLl9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgICAgIHRoaXMuX3R1cm4gPSBXSElURTtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IDE7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5faGVhZGVyID0gcHJlc2VydmVIZWFkZXJzID8gdGhpcy5faGVhZGVyIDogeyAuLi5IRUFERVJfVEVNUExBVEUgfTtcbiAgICAgICAgdGhpcy5faGFzaCA9IHRoaXMuX2NvbXB1dGVIYXNoKCk7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIERlbGV0ZSB0aGUgU2V0VXAgYW5kIEZFTiBoZWFkZXJzIChpZiBwcmVzZXJ2ZWQpLCB0aGUgYm9hcmQgaXMgZW1wdHkgYW5kXG4gICAgICAgICAqIHRoZXNlIGhlYWRlcnMgZG9uJ3QgbWFrZSBzZW5zZSBpbiB0aGlzIHN0YXRlLiBUaGV5J2xsIGdldCBhZGRlZCBsYXRlclxuICAgICAgICAgKiB2aWEgLmxvYWQoKSBvciAucHV0KClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBudWxsO1xuICAgIH1cbiAgICBsb2FkKGZlbiwgeyBza2lwVmFsaWRhdGlvbiA9IGZhbHNlLCBwcmVzZXJ2ZUhlYWRlcnMgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgbGV0IHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAvLyBhcHBlbmQgY29tbW9ubHkgb21pdHRlZCBmZW4gdG9rZW5zXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID49IDIgJiYgdG9rZW5zLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnRzID0gWyctJywgJy0nLCAnMCcsICcxJ107XG4gICAgICAgICAgICBmZW4gPSB0b2tlbnMuY29uY2F0KGFkanVzdG1lbnRzLnNsaWNlKC0oNiAtIHRva2Vucy5sZW5ndGgpKSkuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9rLCBlcnJvciB9ID0gdmFsaWRhdGVGZW4oZmVuKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdG9rZW5zWzBdO1xuICAgICAgICBsZXQgc3F1YXJlID0gMDtcbiAgICAgICAgdGhpcy5jbGVhcih7IHByZXNlcnZlSGVhZGVycyB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGllY2UgPSBwb3NpdGlvbi5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHNxdWFyZSArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEaWdpdChwaWVjZSkpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUgKz0gcGFyc2VJbnQocGllY2UsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcGllY2UgPCAnYScgPyBXSElURSA6IEJMQUNLO1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1dCh7IHR5cGU6IHBpZWNlLnRvTG93ZXJDYXNlKCksIGNvbG9yIH0sIGFsZ2VicmFpYyhzcXVhcmUpKTtcbiAgICAgICAgICAgICAgICBzcXVhcmUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90dXJuID0gdG9rZW5zWzFdO1xuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ0snKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53IHw9IEJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignUScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgfD0gQklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdrJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiB8PSBCSVRTLktTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ3EnKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iIHw9IEJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gdG9rZW5zWzNdID09PSAnLScgPyBFTVBUWSA6IE94ODhbdG9rZW5zWzNdXTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gcGFyc2VJbnQodG9rZW5zWzRdLCAxMCk7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSBwYXJzZUludCh0b2tlbnNbNV0sIDEwKTtcbiAgICAgICAgdGhpcy5faGFzaCA9IHRoaXMuX2NvbXB1dGVIYXNoKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKGZlbik7XG4gICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQoKTtcbiAgICB9XG4gICAgZmVuKHsgZm9yY2VFbnBhc3NhbnRTcXVhcmUgPSBmYWxzZSwgfSA9IHt9KSB7XG4gICAgICAgIGxldCBlbXB0eSA9IDA7XG4gICAgICAgIGxldCBmZW4gPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSBlbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbG9yLCB0eXBlOiBwaWVjZSB9ID0gdGhpcy5fYm9hcmRbaV07XG4gICAgICAgICAgICAgICAgZmVuICs9IGNvbG9yID09PSBXSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1wdHkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9IGVtcHR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gT3g4OC5oMSkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbXB0eSA9IDA7XG4gICAgICAgICAgICAgICAgaSArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjYXN0bGluZyA9ICcnO1xuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbV0hJVEVdICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIGNhc3RsaW5nICs9ICdLJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbV0hJVEVdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIGNhc3RsaW5nICs9ICdRJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbQkxBQ0tdICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIGNhc3RsaW5nICs9ICdrJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbQkxBQ0tdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIGNhc3RsaW5nICs9ICdxJztcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyB3ZSBoYXZlIGFuIGVtcHR5IGNhc3RsaW5nIGZsYWc/XG4gICAgICAgIGNhc3RsaW5nID0gY2FzdGxpbmcgfHwgJy0nO1xuICAgICAgICBsZXQgZXBTcXVhcmUgPSAnLSc7XG4gICAgICAgIC8qXG4gICAgICAgICAqIG9ubHkgcHJpbnQgdGhlIGVwIHNxdWFyZSBpZiBlbiBwYXNzYW50IGlzIGEgdmFsaWQgbW92ZSAocGF3biBpcyBwcmVzZW50XG4gICAgICAgICAqIGFuZCBlcCBjYXB0dXJlIGlzIG5vdCBwaW5uZWQpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fZXBTcXVhcmUgIT09IEVNUFRZKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VFbnBhc3NhbnRTcXVhcmUpIHtcbiAgICAgICAgICAgICAgICBlcFNxdWFyZSA9IGFsZ2VicmFpYyh0aGlzLl9lcFNxdWFyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWdQYXduU3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gV0hJVEUgPyAxNiA6IC0xNik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlcyA9IFtiaWdQYXduU3F1YXJlICsgMSwgYmlnUGF3blNxdWFyZSAtIDFdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlIHNxdWFyZSBvZmYgdGhlIGJvYXJkP1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3F1YXJlICYgMHg4OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl90dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIHBhd24gdGhhdCBjYW4gY2FwdHVyZSB0aGUgZXBTcXVhcmU/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtzcXVhcmVdPy5jb2xvciA9PT0gY29sb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LnR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXduIG1ha2VzIGFuIGVwIGNhcHR1cmUsIGRvZXMgaXQgbGVhdmUgaXRzIGtpbmcgaW4gY2hlY2s/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogc3F1YXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWVjZTogUEFXTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlZDogUEFXTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogQklUUy5FUF9DQVBUVVJFLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xlZ2FsID0gIXRoaXMuX2lzS2luZ0F0dGFja2VkKGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBlcCBpcyBsZWdhbCwgYnJlYWsgYW5kIHNldCB0aGUgZXAgc3F1YXJlIGluIHRoZSBGRU4gb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWdhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gYWxnZWJyYWljKHRoaXMuX2VwU3F1YXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmVuLFxuICAgICAgICAgICAgdGhpcy5fdHVybixcbiAgICAgICAgICAgIGNhc3RsaW5nLFxuICAgICAgICAgICAgZXBTcXVhcmUsXG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMsXG4gICAgICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyLFxuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgX3BpZWNlS2V5KGkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIDBuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGUgfSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICBjb25zdCBjb2xvckluZGV4ID0ge1xuICAgICAgICAgICAgdzogMCxcbiAgICAgICAgICAgIGI6IDEsXG4gICAgICAgIH1bY29sb3JdO1xuICAgICAgICBjb25zdCB0eXBlSW5kZXggPSB7XG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICAgICAgbjogMSxcbiAgICAgICAgICAgIGI6IDIsXG4gICAgICAgICAgICByOiAzLFxuICAgICAgICAgICAgcTogNCxcbiAgICAgICAgICAgIGs6IDUsXG4gICAgICAgIH1bdHlwZV07XG4gICAgICAgIHJldHVybiBQSUVDRV9LRVlTW2NvbG9ySW5kZXhdW3R5cGVJbmRleF1baV07XG4gICAgfVxuICAgIF9lcEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VwU3F1YXJlID09PSBFTVBUWSA/IDBuIDogRVBfS0VZU1t0aGlzLl9lcFNxdWFyZSAmIDddO1xuICAgIH1cbiAgICBfY2FzdGxpbmdLZXkoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKHRoaXMuX2Nhc3RsaW5nLncgPj4gNSkgfCAodGhpcy5fY2FzdGxpbmcuYiA+PiAzKTtcbiAgICAgICAgcmV0dXJuIENBU1RMSU5HX0tFWVNbaW5kZXhdO1xuICAgIH1cbiAgICBfY29tcHV0ZUhhc2goKSB7XG4gICAgICAgIGxldCBoYXNoID0gMG47XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGhhc2ggXj0gdGhpcy5fcGllY2VLZXkoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICBoYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIGlmICh0aGlzLl90dXJuID09PSAnYicpIHtcbiAgICAgICAgICAgIGhhc2ggXj0gU0lERV9LRVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIC8qXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGluaXRpYWwgYm9hcmQgc2V0dXAgaXMgY2hhbmdlZCB3aXRoIHB1dCgpIG9yIHJlbW92ZSgpLlxuICAgICAqIG1vZGlmaWVzIHRoZSBTZXRVcCBhbmQgRkVOIHByb3BlcnRpZXMgb2YgdGhlIGhlYWRlciBvYmplY3QuIElmIHRoZSBGRU5cbiAgICAgKiBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCBwb3NpdGlvbiwgdGhlIFNldFVwIGFuZCBGRU4gYXJlIGRlbGV0ZWQgdGhlIHNldHVwXG4gICAgICogaXMgb25seSB1cGRhdGVkIGlmIGhpc3RvcnkubGVuZ3RoIGlzIHplcm8sIGllIG1vdmVzIGhhdmVuJ3QgYmVlbiBtYWRlLlxuICAgICAqL1xuICAgIF91cGRhdGVTZXR1cChmZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGZlbiAhPT0gREVGQVVMVF9QT1NJVElPTikge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydTZXRVcCddID0gJzEnO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydGRU4nXSA9IGZlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJbJ0ZFTiddID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5sb2FkKERFRkFVTFRfUE9TSVRJT04pO1xuICAgIH1cbiAgICBnZXQoc3F1YXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2FyZFtPeDg4W3NxdWFyZV1dO1xuICAgIH1cbiAgICBmaW5kUGllY2UocGllY2UpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkXG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3JcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbaV0gfHwgdGhpcy5fYm9hcmRbaV0/LmNvbG9yICE9PSBwaWVjZS5jb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgc3F1YXJlIGNvbnRhaW5zIHRoZSByZXF1ZXN0ZWQgcGllY2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXS5jb2xvciA9PT0gcGllY2UuY29sb3IgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtpXS50eXBlID09PSBwaWVjZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlcy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNxdWFyZXM7XG4gICAgfVxuICAgIHB1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkge1xuICAgICAgICBpZiAodGhpcy5fcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSgpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2V0dXAodGhpcy5mZW4oKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9zZXQoc3EsIHBpZWNlKSB7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkoc3EpO1xuICAgICAgICB0aGlzLl9ib2FyZFtzcV0gPSBwaWVjZTtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShzcSk7XG4gICAgfVxuICAgIF9wdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHBpZWNlXG4gICAgICAgIGlmIChTWU1CT0xTLmluZGV4T2YodHlwZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgdmFsaWQgc3F1YXJlXG4gICAgICAgIGlmICghKHNxdWFyZSBpbiBPeDg4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNxID0gT3g4OFtzcXVhcmVdO1xuICAgICAgICAvLyBkb24ndCBsZXQgdGhlIHVzZXIgcGxhY2UgbW9yZSB0aGFuIG9uZSBraW5nXG4gICAgICAgIGlmICh0eXBlID09IEtJTkcgJiZcbiAgICAgICAgICAgICEodGhpcy5fa2luZ3NbY29sb3JdID09IEVNUFRZIHx8IHRoaXMuX2tpbmdzW2NvbG9yXSA9PSBzcSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50UGllY2VPblNxdWFyZSA9IHRoaXMuX2JvYXJkW3NxXTtcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBraW5ncyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBwaWVjZSBmcm9tIGFyZ3MsIHNldCB0aGUgYF9raW5nc2AgcmVzcGVjdGl2ZSBlbnRyeSB0byBgRU1QVFlgXG4gICAgICAgIGlmIChjdXJyZW50UGllY2VPblNxdWFyZSAmJiBjdXJyZW50UGllY2VPblNxdWFyZS50eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1tjdXJyZW50UGllY2VPblNxdWFyZS5jb2xvcl0gPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXQoc3EsIHsgdHlwZTogdHlwZSwgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICBpZiAodHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbY29sb3JdID0gc3E7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9jbGVhcihzcSkge1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX3BpZWNlS2V5KHNxKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW3NxXTtcbiAgICB9XG4gICAgcmVtb3ZlKHNxdWFyZSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuZ2V0KHNxdWFyZSk7XG4gICAgICAgIHRoaXMuX2NsZWFyKE94ODhbc3F1YXJlXSk7XG4gICAgICAgIGlmIChwaWVjZSAmJiBwaWVjZS50eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1twaWVjZS5jb2xvcl0gPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICB0aGlzLl91cGRhdGVFblBhc3NhbnRTcXVhcmUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2V0dXAodGhpcy5mZW4oKSk7XG4gICAgICAgIHJldHVybiBwaWVjZTtcbiAgICB9XG4gICAgX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCkge1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIGNvbnN0IHdoaXRlS2luZ0luUGxhY2UgPSB0aGlzLl9ib2FyZFtPeDg4LmUxXT8udHlwZSA9PT0gS0lORyAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5lMV0/LmNvbG9yID09PSBXSElURTtcbiAgICAgICAgY29uc3QgYmxhY2tLaW5nSW5QbGFjZSA9IHRoaXMuX2JvYXJkW094ODguZThdPy50eXBlID09PSBLSU5HICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmU4XT8uY29sb3IgPT09IEJMQUNLO1xuICAgICAgICBpZiAoIXdoaXRlS2luZ0luUGxhY2UgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYTFdPy50eXBlICE9PSBST09LIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmExXT8uY29sb3IgIT09IFdISVRFKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53ICY9IC02NTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdoaXRlS2luZ0luUGxhY2UgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDFdPy50eXBlICE9PSBST09LIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmgxXT8uY29sb3IgIT09IFdISVRFKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53ICY9IC0zMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJsYWNrS2luZ0luUGxhY2UgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYThdPy50eXBlICE9PSBST09LIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmE4XT8uY29sb3IgIT09IEJMQUNLKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iICY9IC02NTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJsYWNrS2luZ0luUGxhY2UgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDhdPy50eXBlICE9PSBST09LIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8uY29sb3IgIT09IEJMQUNLKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iICY9IC0zMztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgfVxuICAgIF91cGRhdGVFblBhc3NhbnRTcXVhcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSA9PT0gRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gLTE2IDogMTYpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gV0hJVEUgPyAxNiA6IC0xNik7XG4gICAgICAgIGNvbnN0IGF0dGFja2VycyA9IFtjdXJyZW50U3F1YXJlICsgMSwgY3VycmVudFNxdWFyZSAtIDFdO1xuICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3RhcnRTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFt0aGlzLl9lcFNxdWFyZV0gIT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW2N1cnJlbnRTcXVhcmVdPy5jb2xvciAhPT0gc3dhcENvbG9yKHRoaXMuX3R1cm4pIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8udHlwZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5DYXB0dXJlID0gKHNxdWFyZSkgPT4gIShzcXVhcmUgJiAweDg4KSAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IHRoaXMuX3R1cm4gJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LnR5cGUgPT09IFBBV047XG4gICAgICAgIGlmICghYXR0YWNrZXJzLnNvbWUoY2FuQ2FwdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGFja2VkKGNvbG9yLCBzcXVhcmUsIHZlcmJvc2UpIHtcbiAgICAgICAgY29uc3QgYXR0YWNrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGVtcHR5IHNxdWFyZSBvciB3cm9uZyBjb2xvclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09PSB1bmRlZmluZWQgfHwgdGhpcy5fYm9hcmRbaV0uY29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IGkgLSBzcXVhcmU7XG4gICAgICAgICAgICAvLyBza2lwIC0gdG8vZnJvbSBzcXVhcmUgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5O1xuICAgICAgICAgICAgaWYgKEFUVEFDS1NbaW5kZXhdICYgUElFQ0VfTUFTS1NbcGllY2UudHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZlcmVuY2UgPiAwICYmIHBpZWNlLmNvbG9yID09PSBXSElURSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmZXJlbmNlIDw9IDAgJiYgcGllY2UuY29sb3IgPT09IEJMQUNLKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGllY2UgaXMgYSBrbmlnaHQgb3IgYSBraW5nXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBSQVlTW2luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiAhPT0gc3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtqXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGogKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFja2VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2tlcnMoc3F1YXJlLCBhdHRhY2tlZEJ5KSB7XG4gICAgICAgIGlmICghYXR0YWNrZWRCeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKHRoaXMuX3R1cm4sIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNLaW5nQXR0YWNrZWQoY29sb3IpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gdGhpcy5fa2luZ3NbY29sb3JdO1xuICAgICAgICByZXR1cm4gc3F1YXJlID09PSAtMSA/IGZhbHNlIDogdGhpcy5fYXR0YWNrZWQoc3dhcENvbG9yKGNvbG9yKSwgc3F1YXJlKTtcbiAgICB9XG4gICAgaGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBpc0F0dGFja2VkKHNxdWFyZSwgYXR0YWNrZWRCeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdKTtcbiAgICB9XG4gICAgaXNDaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzS2luZ0F0dGFja2VkKHRoaXMuX3R1cm4pO1xuICAgIH1cbiAgICBpbkNoZWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrKCk7XG4gICAgfVxuICAgIGlzQ2hlY2ttYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrKCkgJiYgdGhpcy5fbW92ZXMoKS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGlzU3RhbGVtYXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc0luc3VmZmljaWVudE1hdGVyaWFsKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBrLmIuIHZzIGsuYi4gKG9mIG9wcG9zaXRlIGNvbG9ycykgd2l0aCBtYXRlIGluIDE6XG4gICAgICAgICAqIDgvOC84LzgvMWI2LzgvQjFrNS9LNyBiIC0gLSAwIDFcbiAgICAgICAgICpcbiAgICAgICAgICogay5iLiB2cyBrLm4uIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFuNi84L0I3L0sxazUgYiAtIC0gMiAxXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwaWVjZXMgPSB7XG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgbjogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICBxOiAwLFxuICAgICAgICAgICAgazogMCxcbiAgICAgICAgICAgIHA6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpc2hvcHMgPSBbXTtcbiAgICAgICAgbGV0IG51bVBpZWNlcyA9IDA7XG4gICAgICAgIGxldCBzcXVhcmVDb2xvciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgc3F1YXJlQ29sb3IgPSAoc3F1YXJlQ29sb3IgKyAxKSAlIDI7XG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgaWYgKHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgcGllY2VzW3BpZWNlLnR5cGVdID0gcGllY2UudHlwZSBpbiBwaWVjZXMgPyBwaWVjZXNbcGllY2UudHlwZV0gKyAxIDogMTtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gQklTSE9QKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpc2hvcHMucHVzaChzcXVhcmVDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bVBpZWNlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGsgdnMuIGtcbiAgICAgICAgaWYgKG51bVBpZWNlcyA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIGsgdnMuIGtuIC4uLi4gb3IgLi4uLiBrIHZzLiBrYlxuICAgICAgICBudW1QaWVjZXMgPT09IDMgJiZcbiAgICAgICAgICAgIChwaWVjZXNbQklTSE9QXSA9PT0gMSB8fCBwaWVjZXNbS05JR0hUXSA9PT0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bVBpZWNlcyA9PT0gcGllY2VzW0JJU0hPUF0gKyAyKSB7XG4gICAgICAgICAgICAvLyBrYiB2cy4ga2Igd2hlcmUgYW55IG51bWJlciBvZiBiaXNob3BzIGFyZSBhbGwgb24gdGhlIHNhbWUgY29sb3JcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYmlzaG9wcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGJpc2hvcHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VtID09PSAwIHx8IHN1bSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1RocmVlZm9sZFJlcGV0aXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkNvdW50KHRoaXMuX2hhc2gpID49IDM7XG4gICAgfVxuICAgIGlzRHJhd0J5RmlmdHlNb3ZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbGZNb3ZlcyA+PSAxMDA7IC8vIDUwIG1vdmVzIHBlciBzaWRlID0gMTAwIGhhbGYgbW92ZXNcbiAgICB9XG4gICAgaXNEcmF3KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNEcmF3QnlGaWZ0eU1vdmVzKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNTdGFsZW1hdGUoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0luc3VmZmljaWVudE1hdGVyaWFsKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkpO1xuICAgIH1cbiAgICBpc0dhbWVPdmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrbWF0ZSgpIHx8IHRoaXMuaXNEcmF3KCk7XG4gICAgfVxuICAgIG1vdmVzKHsgdmVyYm9zZSA9IGZhbHNlLCBzcXVhcmUgPSB1bmRlZmluZWQsIHBpZWNlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IHNxdWFyZSwgcGllY2UgfSk7XG4gICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXMubWFwKChtb3ZlKSA9PiBuZXcgTW92ZSh0aGlzLCBtb3ZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXMubWFwKChtb3ZlKSA9PiB0aGlzLl9tb3ZlVG9TYW4obW92ZSwgbW92ZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbW92ZXMoeyBsZWdhbCA9IHRydWUsIHBpZWNlID0gdW5kZWZpbmVkLCBzcXVhcmUgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBmb3JTcXVhcmUgPSBzcXVhcmUgPyBzcXVhcmUudG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZm9yUGllY2UgPSBwaWVjZT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbW92ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcbiAgICAgICAgbGV0IGZpcnN0U3F1YXJlID0gT3g4OC5hODtcbiAgICAgICAgbGV0IGxhc3RTcXVhcmUgPSBPeDg4LmgxO1xuICAgICAgICBsZXQgc2luZ2xlU3F1YXJlID0gZmFsc2U7XG4gICAgICAgIC8vIGFyZSB3ZSBnZW5lcmF0aW5nIG1vdmVzIGZvciBhIHNpbmdsZSBzcXVhcmU/XG4gICAgICAgIGlmIChmb3JTcXVhcmUpIHtcbiAgICAgICAgICAgIC8vIGlsbGVnYWwgc3F1YXJlLCByZXR1cm4gZW1wdHkgbW92ZXNcbiAgICAgICAgICAgIGlmICghKGZvclNxdWFyZSBpbiBPeDg4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0U3F1YXJlID0gbGFzdFNxdWFyZSA9IE94ODhbZm9yU3F1YXJlXTtcbiAgICAgICAgICAgICAgICBzaW5nbGVTcXVhcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGZyb20gPSBmaXJzdFNxdWFyZTsgZnJvbSA8PSBsYXN0U3F1YXJlOyBmcm9tKyspIHtcbiAgICAgICAgICAgIC8vIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkXG4gICAgICAgICAgICBpZiAoZnJvbSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBmcm9tICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbXB0eSBzcXVhcmUgb3Igb3Bwb25lbnQsIHNraXBcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbZnJvbV0gfHwgdGhpcy5fYm9hcmRbZnJvbV0uY29sb3IgPT09IHRoZW0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gdGhpcy5fYm9hcmRbZnJvbV07XG4gICAgICAgICAgICBsZXQgdG87XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGlmIChmb3JQaWVjZSAmJiBmb3JQaWVjZSAhPT0gdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIHNxdWFyZSwgbm9uLWNhcHR1cmluZ1xuICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bMF07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFt0b10pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG91YmxlIHNxdWFyZVxuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoU0VDT05EX1JBTktbdXNdID09PSByYW5rKGZyb20pICYmICF0aGlzLl9ib2FyZFt0b10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTiwgdW5kZWZpbmVkLCBCSVRTLkJJR19QQVdOKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwYXduIGNhcHR1cmVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvICYgMHg4OClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbdG9dPy5jb2xvciA9PT0gdGhlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCB0aGlzLl9ib2FyZFt0b10udHlwZSwgQklUUy5DQVBUVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gdGhpcy5fZXBTcXVhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTiwgUEFXTiwgQklUUy5FUF9DQVBUVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmb3JQaWVjZSAmJiBmb3JQaWVjZSAhPT0gdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxlbiA9IFBJRUNFX09GRlNFVFNbdHlwZV0ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gUElFQ0VfT0ZGU0VUU1t0eXBlXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvICYgMHg4OClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG93biBjb2xvciwgc3RvcCBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3RvXS5jb2xvciA9PT0gdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgdHlwZSwgdGhpcy5fYm9hcmRbdG9dLnR5cGUsIEJJVFMuQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBicmVhaywgaWYga25pZ2h0IG9yIGtpbmcgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBLTklHSFQgfHwgdHlwZSA9PT0gS0lORylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBjaGVjayBmb3IgY2FzdGxpbmcgaWYgd2UncmU6XG4gICAgICAgICAqICAgYSkgZ2VuZXJhdGluZyBhbGwgbW92ZXMsIG9yXG4gICAgICAgICAqICAgYikgZG9pbmcgc2luZ2xlIHNxdWFyZSBtb3ZlIGdlbmVyYXRpb24gb24gdGhlIGtpbmcncyBzcXVhcmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChmb3JQaWVjZSA9PT0gdW5kZWZpbmVkIHx8IGZvclBpZWNlID09PSBLSU5HKSB7XG4gICAgICAgICAgICBpZiAoIXNpbmdsZVNxdWFyZSB8fCBsYXN0U3F1YXJlID09PSB0aGlzLl9raW5nc1t1c10pIHtcbiAgICAgICAgICAgICAgICAvLyBraW5nLXNpZGUgY2FzdGxpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbdXNdICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gdGhpcy5fa2luZ3NbdXNdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gY2FzdGxpbmdGcm9tICsgMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gKyAxXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nVG9dICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgdGhpcy5fa2luZ3NbdXNdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nRnJvbSArIDEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdUbykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCB0aGlzLl9raW5nc1t1c10sIGNhc3RsaW5nVG8sIEtJTkcsIHVuZGVmaW5lZCwgQklUUy5LU0lERV9DQVNUTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHF1ZWVuLXNpZGUgY2FzdGxpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbdXNdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gdGhpcy5fa2luZ3NbdXNdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gY2FzdGxpbmdGcm9tIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAxXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDJdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gM10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdGcm9tIC0gMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ1RvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgS0lORywgdW5kZWZpbmVkLCBCSVRTLlFTSURFX0NBU1RMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogcmV0dXJuIGFsbCBwc2V1ZG8tbGVnYWwgbW92ZXMgKHRoaXMgaW5jbHVkZXMgbW92ZXMgdGhhdCBhbGxvdyB0aGUga2luZ1xuICAgICAgICAgKiB0byBiZSBjYXB0dXJlZClcbiAgICAgICAgICovXG4gICAgICAgIGlmICghbGVnYWwgfHwgdGhpcy5fa2luZ3NbdXNdID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBvdXQgaWxsZWdhbCBtb3Zlc1xuICAgICAgICBjb25zdCBsZWdhbE1vdmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0tpbmdBdHRhY2tlZCh1cykpIHtcbiAgICAgICAgICAgICAgICBsZWdhbE1vdmVzLnB1c2gobW92ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVnYWxNb3ZlcztcbiAgICB9XG4gICAgbW92ZShtb3ZlLCB7IHN0cmljdCA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgbW92ZSBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHdpdGggaW4gdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAubW92ZSgnTnhiNycpICAgICAgIDwtIGFyZ3VtZW50IGlzIGEgY2FzZS1zZW5zaXRpdmUgU0FOIHN0cmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiAubW92ZSh7IGZyb206ICdoNycsIDwtIGFyZ3VtZW50IGlzIGEgbW92ZSBvYmplY3RcbiAgICAgICAgICogICAgICAgICB0byA6J2g4JyxcbiAgICAgICAgICogICAgICAgICBwcm9tb3Rpb246ICdxJyB9KVxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbiBvcHRpb25hbCBzdHJpY3QgYXJndW1lbnQgbWF5IGJlIHN1cHBsaWVkIHRvIHRlbGwgY2hlc3MuanMgdG9cbiAgICAgICAgICogc3RyaWN0bHkgZm9sbG93IHRoZSBTQU4gc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBtb3ZlT2JqID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBtb3ZlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbW92ZU9iaiA9IHRoaXMuX21vdmVGcm9tU2FuKG1vdmUsIHN0cmljdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW92ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbW92ZU9iaiA9IHRoaXMuX21vdmVGcm9tU2FuKFNBTl9OVUxMTU9WRSwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHByZXR0eSBtb3ZlIG9iamVjdCB0byBhbiB1Z2x5IG1vdmUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW92ZS50byA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAoISgncHJvbW90aW9uJyBpbiBtb3Zlc1tpXSkgfHwgbW92ZS5wcm9tb3Rpb24gPT09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9iaiA9IG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbGVkIHRvIGZpbmQgbW92ZVxuICAgICAgICBpZiAoIW1vdmVPYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHttb3ZlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7SlNPTi5zdHJpbmdpZnkobW92ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9kaXNhbGxvdyBudWxsIG1vdmVzIHdoZW4gaW4gY2hlY2tcbiAgICAgICAgaWYgKHRoaXMuaXNDaGVjaygpICYmIG1vdmVPYmouZmxhZ3MgJiBCSVRTLk5VTExfTU9WRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIG1vdmUgbm90IGFsbG93ZWQgd2hlbiBpbiBjaGVjaycpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIG5lZWQgdG8gbWFrZSBhIGNvcHkgb2YgbW92ZSBiZWNhdXNlIHdlIGNhbid0IGdlbmVyYXRlIFNBTiBhZnRlciB0aGUgbW92ZVxuICAgICAgICAgKiBpcyBtYWRlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcmV0dHlNb3ZlID0gbmV3IE1vdmUodGhpcywgbW92ZU9iaik7XG4gICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVPYmopO1xuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KCk7XG4gICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgIH1cbiAgICBfcHVzaChtb3ZlKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBtb3ZlLFxuICAgICAgICAgICAga2luZ3M6IHsgYjogdGhpcy5fa2luZ3MuYiwgdzogdGhpcy5fa2luZ3MudyB9LFxuICAgICAgICAgICAgdHVybjogdGhpcy5fdHVybixcbiAgICAgICAgICAgIGNhc3RsaW5nOiB7IGI6IHRoaXMuX2Nhc3RsaW5nLmIsIHc6IHRoaXMuX2Nhc3RsaW5nLncgfSxcbiAgICAgICAgICAgIGVwU3F1YXJlOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgIGhhbGZNb3ZlczogdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgbW92ZU51bWJlcjogdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tb3ZlUGllY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShmcm9tKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbdG9dID0gdGhpcy5fYm9hcmRbZnJvbV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtmcm9tXTtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleSh0byk7XG4gICAgfVxuICAgIF9tYWtlTW92ZShtb3ZlKSB7XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIHRoaXMuX3B1c2gobW92ZSk7XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5OVUxMX01PVkUpIHtcbiAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMrKztcbiAgICAgICAgICAgIHRoaXMuX3R1cm4gPSB0aGVtO1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fY2FzdGxpbmdLZXkoKTtcbiAgICAgICAgaWYgKG1vdmUuY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkobW92ZS50byk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW92ZVBpZWNlKG1vdmUuZnJvbSwgbW92ZS50byk7XG4gICAgICAgIC8vIGlmIGVwIGNhcHR1cmUsIHJlbW92ZSB0aGUgY2FwdHVyZWQgcGF3blxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R1cm4gPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXIobW92ZS50byAtIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyKG1vdmUudG8gKyAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcGF3biBwcm9tb3Rpb24sIHJlcGxhY2Ugd2l0aCBuZXcgcGllY2VcbiAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhcihtb3ZlLnRvKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLnRvLCB7IHR5cGU6IG1vdmUucHJvbW90aW9uLCBjb2xvcjogdXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgbW92ZWQgdGhlIGtpbmdcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW21vdmUudG9dLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW3VzXSA9IG1vdmUudG87XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYXN0bGVkLCBtb3ZlIHRoZSByb29rIG5leHQgdG8gdGhlIGtpbmdcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVBpZWNlKGNhc3RsaW5nRnJvbSwgY2FzdGxpbmdUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byAtIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVBpZWNlKGNhc3RsaW5nRnJvbSwgY2FzdGxpbmdUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0dXJuIG9mZiBjYXN0bGluZ1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0dXJuIG9mZiBjYXN0bGluZyBpZiB3ZSBtb3ZlIGEgcm9va1xuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbdXNdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdXNdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUuZnJvbSA9PT0gUk9PS1NbdXNdW2ldLnNxdWFyZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t1c10gJiBST09LU1t1c11baV0uZmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t1c10gXj0gUk9PS1NbdXNdW2ldLmZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0dXJuIG9mZiBjYXN0bGluZyBpZiB3ZSBjYXB0dXJlIGEgcm9va1xuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbdGhlbV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBST09LU1t0aGVtXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLnRvID09PSBST09LU1t0aGVtXVtpXS5zcXVhcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdGhlbV0gJiBST09LU1t0aGVtXVtpXS5mbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3RoZW1dIF49IFJPT0tTW3RoZW1dW2ldLmZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIC8vIGlmIGJpZyBwYXduIG1vdmUsIHVwZGF0ZSB0aGUgZW4gcGFzc2FudCBzcXVhcmVcbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkJJR19QQVdOKSB7XG4gICAgICAgICAgICBsZXQgZXBTcXVhcmU7XG4gICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcFNxdWFyZSA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoISgobW92ZS50byAtIDEpICYgMHg4OCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLnRvIC0gMV0/LnR5cGUgPT09IFBBV04gJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLnRvIC0gMV0/LmNvbG9yID09PSB0aGVtKSB8fFxuICAgICAgICAgICAgICAgICghKChtb3ZlLnRvICsgMSkgJiAweDg4KSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLnRvICsgMV0/LnR5cGUgPT09IFBBV04gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byArIDFdPy5jb2xvciA9PT0gdGhlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IGVwU3F1YXJlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSA1MCBtb3ZlIGNvdW50ZXIgaWYgYSBwYXduIGlzIG1vdmVkIG9yIGEgcGllY2UgaXMgY2FwdHVyZWRcbiAgICAgICAgaWYgKG1vdmUucGllY2UgPT09IFBBV04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIChCSVRTLkNBUFRVUkUgfCBCSVRTLkVQX0NBUFRVUkUpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzID09PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R1cm4gPSB0aGVtO1xuICAgICAgICB0aGlzLl9oYXNoIF49IFNJREVfS0VZO1xuICAgIH1cbiAgICB1bmRvKCkge1xuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaDtcbiAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV0dHlNb3ZlID0gbmV3IE1vdmUodGhpcywgbW92ZSk7XG4gICAgICAgICAgICB0aGlzLl9kZWNQb3NpdGlvbkNvdW50KGhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXR0eU1vdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF91bmRvTW92ZSgpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5faGlzdG9yeS5wb3AoKTtcbiAgICAgICAgaWYgKG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fY2FzdGxpbmdLZXkoKTtcbiAgICAgICAgY29uc3QgbW92ZSA9IG9sZC5tb3ZlO1xuICAgICAgICB0aGlzLl9raW5ncyA9IG9sZC5raW5ncztcbiAgICAgICAgdGhpcy5fdHVybiA9IG9sZC50dXJuO1xuICAgICAgICB0aGlzLl9jYXN0bGluZyA9IG9sZC5jYXN0bGluZztcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBvbGQuZXBTcXVhcmU7XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IG9sZC5oYWxmTW92ZXM7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSBvbGQubW92ZU51bWJlcjtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gU0lERV9LRVk7XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5OVUxMX01PVkUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vdmVQaWVjZShtb3ZlLnRvLCBtb3ZlLmZyb20pO1xuICAgICAgICAvLyB0byB1bmRvIGFueSBwcm9tb3Rpb25zXG4gICAgICAgIGlmIChtb3ZlLnBpZWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhcihtb3ZlLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5fc2V0KG1vdmUuZnJvbSwgeyB0eXBlOiBtb3ZlLnBpZWNlLCBjb2xvcjogdXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUuY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICAgICAgICAgICAgLy8gZW4gcGFzc2FudCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0KGluZGV4LCB7IHR5cGU6IFBBV04sIGNvbG9yOiB0aGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVndWxhciBjYXB0dXJlXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0KG1vdmUudG8sIHsgdHlwZTogbW92ZS5jYXB0dXJlZCwgY29sb3I6IHRoZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5LU0lERV9DQVNUTEUgfCBCSVRTLlFTSURFX0NBU1RMRSkpIHtcbiAgICAgICAgICAgIGxldCBjYXN0bGluZ1RvLCBjYXN0bGluZ0Zyb207XG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW92ZVBpZWNlKGNhc3RsaW5nRnJvbSwgY2FzdGxpbmdUbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmU7XG4gICAgfVxuICAgIHBnbih7IG5ld2xpbmUgPSAnXFxuJywgbWF4V2lkdGggPSAwLCB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogdXNpbmcgdGhlIHNwZWNpZmljYXRpb24gZnJvbSBodHRwOi8vd3d3LmNoZXNzY2x1Yi5jb20vaGVscC9QR04tc3BlY1xuICAgICAgICAgKiBleGFtcGxlIGZvciBodG1sIHVzYWdlOiAucGduKHsgbWF4X3dpZHRoOiA3MiwgbmV3bGluZV9jaGFyOiBcIjxiciAvPlwiIH0pXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGhlYWRlckV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAvKiBhZGQgdGhlIFBHTiBoZWFkZXIgaW5mb3JtYXRpb24gKi9cbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRPRE86IG9yZGVyIG9mIGVudW1lcmF0ZWQgcHJvcGVydGllcyBpbiBoZWFkZXIgb2JqZWN0IGlzIG5vdFxuICAgICAgICAgICAgICogZ3VhcmFudGVlZCwgc2VlIEVDTUEtMjYyIHNwZWMgKHNlY3Rpb24gMTIuNi40KVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEJ5IHVzaW5nIEhFQURFUl9URU1QTEFURSwgdGhlIG9yZGVyIG9mIHRhZ3Mgc2hvdWxkIGJlIHByZXNlcnZlZDsgd2VcbiAgICAgICAgICAgICAqIGRvIGhhdmUgdG8gY2hlY2sgZm9yIG51bGwgcGxhY2Vob2xkZXJzLCB0aG91Z2gsIGFuZCBvbWl0IHRoZW1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyVGFnID0gdGhpcy5faGVhZGVyW2ldO1xuICAgICAgICAgICAgaWYgKGhlYWRlclRhZylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgWyR7aX0gXCIke3RoaXMuX2hlYWRlcltpXX1cIl1gICsgbmV3bGluZSk7XG4gICAgICAgICAgICBoZWFkZXJFeGlzdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJFeGlzdHMgJiYgdGhpcy5faGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGVuZENvbW1lbnQgPSAobW92ZVN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlciA9IG1vdmVTdHJpbmcubGVuZ3RoID4gMCA/ICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBgJHttb3ZlU3RyaW5nfSR7ZGVsaW1pdGVyfXske2NvbW1lbnR9fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW92ZVN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcG9wIGFsbCBvZiBoaXN0b3J5IG9udG8gcmV2ZXJzZWRfaGlzdG9yeVxuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZXMgPSBbXTtcbiAgICAgICAgbGV0IG1vdmVTdHJpbmcgPSAnJztcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIG9mIGEgY29tbWVudGVkIHN0YXJ0aW5nIHBvc2l0aW9uIHdpdGggbm8gbW92ZXNcbiAgICAgICAgaWYgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goYXBwZW5kQ29tbWVudCgnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBsaXN0IG9mIG1vdmVzLiAgYSBtb3ZlX3N0cmluZyBsb29rcyBsaWtlOiBcIjMuIGUzIGU2XCJcbiAgICAgICAgd2hpbGUgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtb3ZlU3RyaW5nID0gYXBwZW5kQ29tbWVudChtb3ZlU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICAvLyBtYWtlIFR5cGVTY3JpcHQgc3RvcCBjb21wbGFpbmluZyBhYm91dCBtb3ZlIGJlaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9zaXRpb24gc3RhcnRlZCB3aXRoIGJsYWNrIHRvIG1vdmUsIHN0YXJ0IFBHTiB3aXRoICMuIC4uLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oaXN0b3J5Lmxlbmd0aCAmJiBtb3ZlLmNvbG9yID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBgJHt0aGlzLl9tb3ZlTnVtYmVyfS4gLi4uYDtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIGNvbW1lbnQgcHJlY2VkaW5nIHRoZSBmaXJzdCBtb3ZlP1xuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBtb3ZlU3RyaW5nID8gYCR7bW92ZVN0cmluZ30gJHtwcmVmaXh9YCA6IHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vdmUuY29sb3IgPT09ICd3Jykge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBnZW5lcmF0ZWQgbW92ZV9zdHJpbmcgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgICAgICBpZiAobW92ZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZXMucHVzaChtb3ZlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyA9IHRoaXMuX21vdmVOdW1iZXIgKyAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3ZlU3RyaW5nID1cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nICsgJyAnICsgdGhpcy5fbW92ZVRvU2FuKG1vdmUsIHRoaXMuX21vdmVzKHsgbGVnYWw6IHRydWUgfSkpO1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBvdGhlciBsZWZ0b3ZlciBtb3Zlcz9cbiAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQobW92ZVN0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzIHRoZXJlIGEgcmVzdWx0PyAodGhlcmUgQUxXQVlTIGhhcyB0byBiZSBhIHJlc3VsdCBhY2NvcmRpbmcgdG8gc3BlYzsgc2VlIFNldmVuIFRhZyBSb3N0ZXIpXG4gICAgICAgIG1vdmVzLnB1c2godGhpcy5faGVhZGVyLlJlc3VsdCB8fCAnKicpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBoaXN0b3J5IHNob3VsZCBiZSBiYWNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBzdGFydGVkIGdlbmVyYXRpbmcgUEdOLFxuICAgICAgICAgKiBzbyBqb2luIHRvZ2V0aGVyIG1vdmVzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobWF4V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJykgKyBtb3Zlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAoamFoKTogaHVoP1xuICAgICAgICBjb25zdCBzdHJpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5COiB0aGlzIGRvZXMgbm90IHByZXNlcnZlIGNvbW1lbnQgd2hpdGVzcGFjZS5cbiAgICAgICAgY29uc3Qgd3JhcENvbW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIG1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbW92ZS5zcGxpdCgnICcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoICsgdG9rZW4ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaXAoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdyYXAgdGhlIFBHTiBvdXRwdXQgYXQgbWF4X3dpZHRoXG4gICAgICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZXNbaV0uaW5jbHVkZXMoJ3snKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSB3cmFwQ29tbWVudChjdXJyZW50V2lkdGgsIG1vdmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbW92ZSB3aWxsIHB1c2ggcGFzdCBtYXhfd2lkdGhcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCAmJiBpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHRoZSBsaW5lIHdpdGggd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICBjdXJyZW50V2lkdGggKz0gbW92ZXNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgc2V0SGVhZGVyYCBhbmQgYGdldEhlYWRlcnNgIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIG51bGwgaGVhZGVyIHRhZ3MgKHdoaWNoIGlzIG5vdCB3aGF0IHlvdSB3YW50KVxuICAgICAqL1xuICAgIGhlYWRlciguLi5hcmdzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnc1tpICsgMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyW2FyZ3NbaV1dID0gYXJnc1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgLy8gVE9ETzogdmFsdWUgdmFsaWRhdGlvbiBwZXIgc3BlY1xuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gdmFsdWUgPz8gU0VWRU5fVEFHX1JPU1RFUltrZXldID8/IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlcnMoKTtcbiAgICB9XG4gICAgcmVtb3ZlSGVhZGVyKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyW2tleV0gPSBTRVZFTl9UQUdfUk9TVEVSW2tleV0gfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIG9ubHkgbm9uLW51bGwgaGVhZGVycyAob21pdCBwbGFjZW1hcmtlciBudWxscylcbiAgICBnZXRIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBub25OdWxsSGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9oZWFkZXIpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub25OdWxsSGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vbk51bGxIZWFkZXJzO1xuICAgIH1cbiAgICBsb2FkUGduKHBnbiwgeyBzdHJpY3QgPSBmYWxzZSwgbmV3bGluZUNoYXIgPSAnXFxyP1xcbicsIH0gPSB7fSkge1xuICAgICAgICAvLyBJZiBuZXdsaW5lQ2hhciBpcyBub3QgdGhlIGRlZmF1bHQsIHJlcGxhY2UgYWxsIGluc3RhbmNlcyB3aXRoIFxcblxuICAgICAgICBpZiAobmV3bGluZUNoYXIgIT09ICdcXHI/XFxuJykge1xuICAgICAgICAgICAgcGduID0gcGduLnJlcGxhY2UobmV3IFJlZ0V4cChuZXdsaW5lQ2hhciwgJ2cnKSwgJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBnbiA9IHBlZyRwYXJzZShwZ24pO1xuICAgICAgICAvLyBQdXQgdGhlIGJvYXJkIGluIHRoZSBzdGFydGluZyBwb3NpdGlvblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIC8vIHBhcnNlIFBHTiBoZWFkZXJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHBhcnNlZFBnbi5oZWFkZXJzO1xuICAgICAgICBsZXQgZmVuID0gJyc7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSB1c2VyIGlzIGluY2x1ZGluZyBmZW4gKHBvc3NpYmx5IHdpdGggd3JvbmcgdGFnIGNhc2UpXG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdmZW4nKSB7XG4gICAgICAgICAgICAgICAgZmVuID0gaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIHRoZSBwZXJtaXNzaXZlIHBhcnNlciBzaG91bGQgYXR0ZW1wdCB0byBsb2FkIGEgZmVuIHRhZywgZXZlbiBpZiBpdCdzIHRoZVxuICAgICAgICAgKiB3cm9uZyBjYXNlIGFuZCBkb2Vzbid0IGluY2x1ZGUgYSBjb3JyZXNwb25kaW5nIFtTZXRVcCBcIjFcIl0gdGFnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZlbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChmZW4sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHN0cmljdCBwYXJzZXIgLSBsb2FkIHRoZSBzdGFydGluZyBwb3NpdGlvbiBpbmRpY2F0ZWQgYnkgW1NldHVwICcxJ11cbiAgICAgICAgICAgICAqIGFuZCBbRkVOIHBvc2l0aW9uXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snU2V0VXAnXSA9PT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoJ0ZFTicgaW4gaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBHTjogRkVOIHRhZyBtdXN0IGJlIHN1cHBsaWVkIHdpdGggU2V0VXAgdGFnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNsZWFyIHRoZSBoZWFkZXJzIHdoZW4gbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChoZWFkZXJzWydGRU4nXSwgeyBwcmVzZXJ2ZUhlYWRlcnM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBwYXJzZWRQZ24ucm9vdDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm1vdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3ZlID0gdGhpcy5fbW92ZUZyb21TYW4obm9kZS5tb3ZlLCBzdHJpY3QpO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmUgaW4gUEdOOiAke25vZGUubW92ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV0gPSBub2RlLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS52YXJpYXRpb25zWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIFBlciBzZWN0aW9uIDguMi42IG9mIHRoZSBQR04gc3BlYywgdGhlIFJlc3VsdCB0YWcgcGFpciBtdXN0IG1hdGNoIG1hdGNoXG4gICAgICAgICAqIHRoZSB0ZXJtaW5hdGlvbiBtYXJrZXIuIE9ubHkgZG8gdGhpcyB3aGVuIGhlYWRlcnMgYXJlIHByZXNlbnQsIGJ1dCB0aGVcbiAgICAgICAgICogcmVzdWx0IHRhZyBpcyBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZWRQZ24ucmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0ICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9oZWFkZXIpLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydSZXN1bHQnXSAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlcignUmVzdWx0JywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAqIENvbnZlcnQgYSBtb3ZlIGZyb20gMHg4OCBjb29yZGluYXRlcyB0byBTdGFuZGFyZCBBbGdlYnJhaWMgTm90YXRpb25cbiAgICAgKiAoU0FOKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdHJpY3QgVXNlIHRoZSBzdHJpY3QgU0FOIHBhcnNlci4gSXQgd2lsbCB0aHJvdyBlcnJvcnNcbiAgICAgKiBvbiBvdmVybHkgZGlzYW1iaWd1YXRlZCBtb3ZlcyAoc2VlIGJlbG93KTpcbiAgICAgKlxuICAgICAqIHIxYnFrYm5yL3BwcDJwcHAvMm41LzFCMXBQMy80UDMvOC9QUFBQMlBQL1JOQlFLMU5SIGIgS1FrcSAtIDIgNFxuICAgICAqIDQuIC4uLiBOZ2U3IGlzIG92ZXJseSBkaXNhbWJpZ3VhdGVkIGJlY2F1c2UgdGhlIGtuaWdodCBvbiBjNiBpcyBwaW5uZWRcbiAgICAgKiA0LiAuLi4gTmU3IGlzIHRlY2huaWNhbGx5IHRoZSB2YWxpZCBTQU5cbiAgICAgKi9cbiAgICBfbW92ZVRvU2FuKG1vdmUsIG1vdmVzKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gJ08tTyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnTy1PLU8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLk5VTExfTU9WRSkge1xuICAgICAgICAgICAgcmV0dXJuIFNBTl9OVUxMTU9WRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb3ZlLnBpZWNlICE9PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYW1iaWd1YXRvciA9IGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBtb3ZlLnBpZWNlLnRvVXBwZXJDYXNlKCkgKyBkaXNhbWJpZ3VhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBhbGdlYnJhaWMobW92ZS5mcm9tKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICd4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCArPSBhbGdlYnJhaWMobW92ZS50byk7XG4gICAgICAgICAgICBpZiAobW92ZS5wcm9tb3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJz0nICsgbW92ZS5wcm9tb3Rpb24udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDaGVjaygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NoZWNrbWF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcjJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnKyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLy8gY29udmVydCBhIG1vdmUgZnJvbSBTdGFuZGFyZCBBbGdlYnJhaWMgTm90YXRpb24gKFNBTikgdG8gMHg4OCBjb29yZGluYXRlc1xuICAgIF9tb3ZlRnJvbVNhbihtb3ZlLCBzdHJpY3QgPSBmYWxzZSkge1xuICAgICAgICAvLyBzdHJpcCBvZmYgYW55IG1vdmUgZGVjb3JhdGlvbnM6IGUuZyBOZjMrPyEgYmVjb21lcyBOZjNcbiAgICAgICAgbGV0IGNsZWFuTW92ZSA9IHN0cmlwcGVkU2FuKG1vdmUpO1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT0gJzAtMCcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbk1vdmUgPSAnTy1PJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFuTW92ZSA9PT0gJzAtMC0wJykge1xuICAgICAgICAgICAgICAgIGNsZWFuTW92ZSA9ICdPLU8tTyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9maXJzdCBpbXBsZW1lbnRhdGlvbiBvZiBudWxsIHdpdGggYSBkdW1teSBtb3ZlIChibGFjayBraW5nIG1vdmVzIGZyb20gYTggdG8gYTgpLCBtYXliZSB0aGlzIGNhbiBiZSBpbXBsZW1lbnRlZCBiZXR0ZXJcbiAgICAgICAgaWYgKGNsZWFuTW92ZSA9PSBTQU5fTlVMTE1PVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fdHVybixcbiAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgIHRvOiAwLFxuICAgICAgICAgICAgICAgIHBpZWNlOiAnaycsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IEJJVFMuTlVMTF9NT1ZFLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBpZWNlVHlwZSA9IGluZmVyUGllY2VUeXBlKGNsZWFuTW92ZSk7XG4gICAgICAgIGxldCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgbGVnYWw6IHRydWUsIHBpZWNlOiBwaWVjZVR5cGUgfSk7XG4gICAgICAgIC8vIHN0cmljdCBwYXJzZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2xlYW5Nb3ZlID09PSBzdHJpcHBlZFNhbih0aGlzLl9tb3ZlVG9TYW4obW92ZXNbaV0sIG1vdmVzKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHN0cmljdCBwYXJzZXIgZmFpbGVkXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwaWVjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwcm9tb3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHBlcm1pc3NpdmUgKG5vbi1zdHJpY3QpIHBhcnNlciBhbGxvd3MgdGhlIHVzZXIgdG8gcGFyc2VcbiAgICAgICAgICogbm9uLXN0YW5kYXJkIGNoZXNzIG5vdGF0aW9ucy4gVGhpcyBwYXJzZXIgaXMgb25seSBydW4gYWZ0ZXIgdGhlIHN0cmljdFxuICAgICAgICAgKiBTdGFuZGFyZCBBbGdlYnJhaWMgTm90YXRpb24gKFNBTikgcGFyc2VyIGhhcyBmYWlsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gcnVubmluZyB0aGUgcGVybWlzc2l2ZSBwYXJzZXIsIHdlJ2xsIHJ1biBhIHJlZ2V4IHRvIGdyYWIgdGhlIHBpZWNlLCB0aGVcbiAgICAgICAgICogdG8vZnJvbSBzcXVhcmUsIGFuZCBhbiBvcHRpb25hbCBwcm9tb3Rpb24gcGllY2UuIFRoaXMgcmVnZXggd2lsbFxuICAgICAgICAgKiBwYXJzZSBjb21tb24gbm9uLXN0YW5kYXJkIG5vdGF0aW9uIGxpa2U6IFBlMi1lNCwgUmMxYzQsIFFmM3hmNyxcbiAgICAgICAgICogZjdmOHEsIGIxYzNcbiAgICAgICAgICpcbiAgICAgICAgICogTk9URTogU29tZSBwb3NpdGlvbnMgYW5kIG1vdmVzIG1heSBiZSBhbWJpZ3VvdXMgd2hlbiB1c2luZyB0aGUgcGVybWlzc2l2ZVxuICAgICAgICAgKiBwYXJzZXIuIEZvciBleGFtcGxlLCBpbiB0aGlzIHBvc2l0aW9uOiA2azEvOC84L0I3LzgvOC84L0JONEsxIHcgLSAtIDAgMSxcbiAgICAgICAgICogdGhlIG1vdmUgYjFjMyBtYXkgYmUgaW50ZXJwcmV0ZWQgYXMgTmMzIG9yIEIxYzMgKGEgZGlzYW1iaWd1YXRlZCBiaXNob3BcbiAgICAgICAgICogbW92ZSkuIEluIHRoZXNlIGNhc2VzLCB0aGUgcGVybWlzc2l2ZSBwYXJzZXIgd2lsbCBkZWZhdWx0IHRvIHRoZSBtb3N0XG4gICAgICAgICAqIGJhc2ljIGludGVycHJldGF0aW9uICh3aGljaCBpcyBiMWMzIHBhcnNpbmcgdG8gTmMzKS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBvdmVybHlEaXNhbWJpZ3VhdGVkID0gZmFsc2U7XG4gICAgICAgIG1hdGNoZXMgPSBjbGVhbk1vdmUubWF0Y2goLyhbcG5icnFrUE5CUlFLXSk/KFthLWhdWzEtOF0peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHBpZWNlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgdG8gPSBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgcHJvbW90aW9uID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIFthLWhdP1sxLThdPyBwb3J0aW9uIG9mIHRoZSByZWdleCBiZWxvdyBoYW5kbGVzIG1vdmVzIHRoYXQgbWF5IGJlXG4gICAgICAgICAgICAgKiBvdmVybHkgZGlzYW1iaWd1YXRlZCAoZS5nLiBOZ2U3IGlzIHVubmVjZXNzYXJ5IGFuZCBub24tc3RhbmRhcmQgd2hlblxuICAgICAgICAgICAgICogdGhlcmUgaXMgb25lIGxlZ2FsIGtuaWdodCBtb3ZlIHRvIGU3KS4gSW4gdGhpcyBjYXNlLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgICAgICAqICdmcm9tJyB2YXJpYWJsZSB3aWxsIGJlIGEgcmFuayBvciBmaWxlLCBub3QgYSBzcXVhcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1hdGNoZXMgPSBjbGVhbk1vdmUubWF0Y2goLyhbcG5icnFrUE5CUlFLXSk/KFthLWhdP1sxLThdPyl4Py0/KFthLWhdWzEtOF0pKFtxcmJuUVJCTl0pPy8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBwaWVjZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICAgICAgZnJvbSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICAgICAgdG8gPSBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgICAgIHByb21vdGlvbiA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBpZWNlVHlwZSA9IGluZmVyUGllY2VUeXBlKGNsZWFuTW92ZSk7XG4gICAgICAgIG1vdmVzID0gdGhpcy5fbW92ZXMoe1xuICAgICAgICAgICAgbGVnYWw6IHRydWUsXG4gICAgICAgICAgICBwaWVjZTogcGllY2UgPyBwaWVjZSA6IHBpZWNlVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZnJvbSBzcXVhcmUsIGl0IGNvdWxkIGJlIGp1c3QgJ3gnIG1pc3NpbmcgZnJvbSBhIGNhcHR1cmVcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5Nb3ZlID09PVxuICAgICAgICAgICAgICAgICAgICBzdHJpcHBlZFNhbih0aGlzLl9tb3ZlVG9TYW4obW92ZXNbaV0sIG1vdmVzKSkucmVwbGFjZSgneCcsICcnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhhbmQtY29tcGFyZSBtb3ZlIHByb3BlcnRpZXMgd2l0aCB0aGUgcmVzdWx0cyBmcm9tIG91ciBwZXJtaXNzaXZlIHJlZ2V4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIXBpZWNlIHx8IHBpZWNlLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucGllY2UpICYmXG4gICAgICAgICAgICAgICAgT3g4OFtmcm9tXSA9PSBtb3Zlc1tpXS5mcm9tICYmXG4gICAgICAgICAgICAgICAgT3g4OFt0b10gPT0gbW92ZXNbaV0udG8gJiZcbiAgICAgICAgICAgICAgICAoIXByb21vdGlvbiB8fCBwcm9tb3Rpb24udG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3Zlcmx5RGlzYW1iaWd1YXRlZCkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU1BFQ0lBTCBDQVNFOiB3ZSBwYXJzZWQgYSBtb3ZlIHN0cmluZyB0aGF0IG1heSBoYXZlIGFuIHVubmVlZGVkXG4gICAgICAgICAgICAgICAgICogcmFuay9maWxlIGRpc2FtYmlndWF0b3IgKGUuZy4gTmdlNykuICBUaGUgJ2Zyb20nIHZhcmlhYmxlIHdpbGxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBzcXVhcmUgPSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgT3g4OFt0b10gPT0gbW92ZXNbaV0udG8gJiZcbiAgICAgICAgICAgICAgICAgICAgKGZyb20gPT0gc3F1YXJlWzBdIHx8IGZyb20gPT0gc3F1YXJlWzFdKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXByb21vdGlvbiB8fCBwcm9tb3Rpb24udG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzY2lpKCkge1xuICAgICAgICBsZXQgcyA9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbic7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlzcGxheSB0aGUgcmFua1xuICAgICAgICAgICAgaWYgKGZpbGUoaSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJyArICc4NzY1NDMyMSdbcmFuayhpKV0gKyAnIHwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXS50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fYm9hcmRbaV0uY29sb3I7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gY29sb3IgPT09IFdISVRFID8gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcyArPSAnICcgKyBzeW1ib2wgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgLiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgcyArPSAnfFxcbic7XG4gICAgICAgICAgICAgICAgaSArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHMgKz0gJyAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXFxuJztcbiAgICAgICAgcyArPSAnICAgICBhICBiICBjICBkICBlICBmICBnICBoJztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHBlcmZ0KGRlcHRoKSB7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBsZWdhbDogZmFsc2UgfSk7XG4gICAgICAgIGxldCBub2RlcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3Zlc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzS2luZ0F0dGFja2VkKGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCAtIDEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzICs9IHRoaXMucGVyZnQoZGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHNldFR1cm4oY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R1cm4gPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmUoJy0tJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHVybjtcbiAgICB9XG4gICAgYm9hcmQoKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBsZXQgcm93ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlOiBhbGdlYnJhaWMoaSksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuX2JvYXJkW2ldLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLl9ib2FyZFtpXS5jb2xvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgcm93ID0gW107XG4gICAgICAgICAgICAgICAgaSArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHNxdWFyZUNvbG9yKHNxdWFyZSkge1xuICAgICAgICBpZiAoc3F1YXJlIGluIE94ODgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNxID0gT3g4OFtzcXVhcmVdO1xuICAgICAgICAgICAgcmV0dXJuIChyYW5rKHNxKSArIGZpbGUoc3EpKSAlIDIgPT09IDAgPyAnbGlnaHQnIDogJ2RhcmsnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBoaXN0b3J5KHsgdmVyYm9zZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgbW92ZUhpc3RvcnkgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICBpZiAoIW1vdmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaChuZXcgTW92ZSh0aGlzLCBtb3ZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3ZlSGlzdG9yeS5wdXNoKHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3ZlcygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW92ZUhpc3Rvcnk7XG4gICAgfVxuICAgIC8qXG4gICAgICogS2VlcHMgdHJhY2sgb2YgcG9zaXRpb24gb2NjdXJyZW5jZSBjb3VudHMgZm9yIHRoZSBwdXJwb3NlIG9mIHJlcGV0aXRpb25cbiAgICAgKiBjaGVja2luZy4gT2xkIHBvc2l0aW9ucyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgaWYgdGhlaXIgY291bnRzIGFyZSByZWR1Y2VkIHRvIDAuXG4gICAgICovXG4gICAgX2dldFBvc2l0aW9uQ291bnQoaGFzaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25Db3VudC5nZXQoaGFzaCkgPz8gMDtcbiAgICB9XG4gICAgX2luY1Bvc2l0aW9uQ291bnQoKSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQuc2V0KHRoaXMuX2hhc2gsICh0aGlzLl9wb3NpdGlvbkNvdW50LmdldCh0aGlzLl9oYXNoKSA/PyAwKSArIDEpO1xuICAgIH1cbiAgICBfZGVjUG9zaXRpb25Db3VudChoYXNoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IHRoaXMuX3Bvc2l0aW9uQ291bnQuZ2V0KGhhc2gpID8/IDA7XG4gICAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQuZGVsZXRlKGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudC5zZXQoaGFzaCwgY3VycmVudENvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3BydW5lQ29tbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkSGlzdG9yeSA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50Q29tbWVudHMgPSB7fTtcbiAgICAgICAgY29uc3QgY29weUNvbW1lbnQgPSAoZmVuKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmVuIGluIHRoaXMuX2NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbW1lbnRzW2Zlbl0gPSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAodGhpcy5faGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXZlcnNlZEhpc3RvcnkucHVzaCh0aGlzLl91bmRvTW92ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5Q29tbWVudCh0aGlzLmZlbigpKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICBpZiAoIW1vdmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSBjdXJyZW50Q29tbWVudHM7XG4gICAgfVxuICAgIGdldENvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICB9XG4gICAgc2V0Q29tbWVudChjb21tZW50KSB7XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldID0gY29tbWVudC5yZXBsYWNlKCd7JywgJ1snKS5yZXBsYWNlKCd9JywgJ10nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudGAgZm9yIGNvbnNpc3RlbmN5XG4gICAgICovXG4gICAgZGVsZXRlQ29tbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ29tbWVudCgpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50KCkge1xuICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIGdldENvbW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9wcnVuZUNvbW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGZlbjogZmVuLCBjb21tZW50OiB0aGlzLl9jb21tZW50c1tmZW5dIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBSZW5hbWVkIHRvIGByZW1vdmVDb21tZW50c2AgZm9yIGNvbnNpc3RlbmN5XG4gICAgICovXG4gICAgZGVsZXRlQ29tbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnRzKCk7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9wcnVuZUNvbW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1lbnRzW2Zlbl07XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogY29tbWVudCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0Q2FzdGxpbmdSaWdodHMoY29sb3IsIHJpZ2h0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHNpZGUgb2YgW0tJTkcsIFFVRUVOXSkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0c1tzaWRlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0c1tzaWRlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1tjb2xvcl0gfD0gU0lERVNbc2lkZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJj0gflNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldENhc3RsaW5nUmlnaHRzKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuICgocmlnaHRzW0tJTkddID09PSB1bmRlZmluZWQgfHwgcmlnaHRzW0tJTkddID09PSByZXN1bHRbS0lOR10pICYmXG4gICAgICAgICAgICAocmlnaHRzW1FVRUVOXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tRVUVFTl0gPT09IHJlc3VsdFtRVUVFTl0pKTtcbiAgICB9XG4gICAgZ2V0Q2FzdGxpbmdSaWdodHMoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtLSU5HXTogKHRoaXMuX2Nhc3RsaW5nW2NvbG9yXSAmIFNJREVTW0tJTkddKSAhPT0gMCxcbiAgICAgICAgICAgIFtRVUVFTl06ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tRVUVFTl0pICE9PSAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtb3ZlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW92ZU51bWJlcjtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJJU0hPUCwgQkxBQ0ssIENoZXNzLCBERUZBVUxUX1BPU0lUSU9OLCBLSU5HLCBLTklHSFQsIE1vdmUsIFBBV04sIFFVRUVOLCBST09LLCBTRVZFTl9UQUdfUk9TVEVSLCBTUVVBUkVTLCBXSElURSwgdmFsaWRhdGVGZW4sIHhvcm9zaGlybzEyOCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlc3MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chess.js/dist/esm/chess.js\n"));

/***/ }),

/***/ "./node_modules/client-only/index.js":
/*!*******************************************!*\
  !*** ./node_modules/client-only/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fjx%2FWORKSPACE%2FPROJECTS%2FCHESS%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fjx%2FWORKSPACE%2FPROJECTS%2FCHESS%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmp4JTJGV09SS1NQQUNFJTJGUFJPSkVDVFMlMkZDSEVTUyUyRnNyYyUyRnBhZ2VzJTJGaW5kZXgudHN4JnBhZ2U9JTJGIS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG9EQUF1QjtBQUM5QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/MDU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vc3JjL3BhZ2VzL2luZGV4LnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fjx%2FWORKSPACE%2FPROJECTS%2FCHESS%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"./node_modules/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node =  true && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if ( true && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || \"object\" === \"undefined\") {\n            var sheet =  true ? this.getSheet() : 0;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (true) {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {}\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (false) {}\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (false) {}\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if ( true && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState(function() {\n        return rootRegistry || configuredRegistry || createStyleRegistry();\n    }), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"vgRS4YV7PcSMQCYHzGaNuBIBcZQ=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry =  true ? createStyleRegistry() : 0;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (false) {}\n    useInsertionEffect(function() {\n        registry.add(props);\n        return function() {\n            registry.remove(props);\n        };\n    // props.children can be string[], will be striped since id is identical\n    }, [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L2luZGV4L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUFBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFcEIsU0FBU0Usc0JBQXVCQyxDQUFDLEVBQUU7SUFBRSxPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUUsV0FBV0E7SUFBRSxDQUFDO0FBQUU7QUFFakgsSUFBSUMsaUJBQWlCLFdBQVcsR0FBRUYsc0JBQXNCRDs7QUFFeEQ7OztBQUdBLEdBQUcsU0FBU0ksa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtJQUN6QyxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFJO1FBQ2pDLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUN6QkUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUksS0FBSztRQUN0REQsV0FBV0UsWUFBWSxHQUFHLElBQUk7UUFDOUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUcsSUFBSTtRQUNyREMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRSSxXQUFXTSxHQUFHLEVBQUVOO0lBQ2xEO0FBQ0o7QUFDQSxTQUFTTyxhQUFhQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFO0lBQ3hELElBQUlELFlBQVlkLGtCQUFrQmEsWUFBWUcsU0FBUyxFQUFFRjtJQUN6RCxJQUFJQyxhQUFhZixrQkFBa0JhLGFBQWFFO0lBQ2hELE9BQU9GO0FBQ1g7QUFDQSxJQUFJSSxTQUFTLE9BQU9DLE9BQU9BLEtBQUssZUFBZUEsT0FBT0EsQ0FBQ0MsR0FBRyxJQUFJRCxrQkFBeUI7QUFDdkYsSUFBSUUsV0FBVyxTQUFTQyxDQUFDLEVBQUU7SUFDdkIsT0FBT1osT0FBT08sU0FBUyxDQUFDTSxRQUFRLENBQUNDLElBQUksQ0FBQ0YsT0FBTztBQUNqRDtB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LFdBQVdTLGtCQUFrQkEsa0JBQWtCSCxrQkFBa0I7SUFDckUsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ04sVUFBVTtRQUNYLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxJQUFJLEtBQTZCLEVBQUUsRUFHbEM7SUFDRE8sbUJBQW1CLFdBQVc7UUFDMUJQLFNBQVMvQixHQUFHLENBQUN6SDtRQUNiLE9BQU8sV0FBVztZQUNkd0osU0FBU3BCLE1BQU0sQ0FBQ3BJO1FBQ3BCO0lBQ0osd0VBQXdFO0lBQ3hFLEdBQUc7UUFDQ0EsTUFBTXdHLEVBQUU7UUFDUkYsT0FBT3RHLE1BQU02SSxPQUFPO0tBQ3ZCO0lBQ0QsT0FBTyxJQUFJO0FBQ2Y7SUFyQlNxQjs7UUFDOENKO1FBU25EQzs7O01BVktHO0FBc0JUQSxTQUFTckIsT0FBTyxHQUFHLFNBQVNzQixJQUFJLEVBQUU7SUFDOUIsT0FBT0EsS0FBS3ZGLEdBQUcsQ0FBQyxTQUFTd0YsT0FBTyxFQUFFO1FBQzlCLElBQUloRSxTQUFTZ0UsT0FBTyxDQUFDLEVBQUU7UUFDdkIsSUFBSXBLLFFBQVFvSyxPQUFPLENBQUMsRUFBRTtRQUN0QixPQUFPakUsVUFBVUMsUUFBUXBHO0lBQzdCLEdBQUcwSSxJQUFJLENBQUM7QUFDWjtBQUVBMkIscUJBQXFCLEdBQUdmO0FBQ3hCZSwyQkFBMkIsR0FBR2hCO0FBQzlCZ0IsYUFBYSxHQUFHSDtBQUNoQkcsd0JBQXdCLEdBQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanM/YjAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdjbGllbnQtb25seScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xuXG4vKlxuQmFzZWQgb24gR2xhbW9yJ3Mgc2hlZXRcbmh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZXBvaW50b25lL2dsYW1vci9ibG9iLzY2N2I0ODBkMzFiMzcyMWE5MDUwMjFiMjZlMTI5MGNlOTJjYTI4Nzkvc3JjL3NoZWV0LmpzXG4qLyBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbnZhciBpc1Byb2QgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn07XG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldChwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9uYW1lID0gcmVmLm5hbWUsIG5hbWUgPSBfbmFtZSA9PT0gdm9pZCAwID8gXCJzdHlsZXNoZWV0XCIgOiBfbmFtZSwgX29wdGltaXplRm9yU3BlZWQgPSByZWYub3B0aW1pemVGb3JTcGVlZCwgb3B0aW1pemVGb3JTcGVlZCA9IF9vcHRpbWl6ZUZvclNwZWVkID09PSB2b2lkIDAgPyBpc1Byb2QgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcobmFtZSksIFwiYG5hbWVgIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID0gXCIjXCIgKyBuYW1lICsgXCItZGVsZXRlZC1ydWxlX19fX3t9XCI7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIiwgXCJgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBvcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICAgICAgdGhpcy5fbm9uY2UgPSBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gc2V0T3B0aW1pemVGb3JTcGVlZChib29sKSB7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIiwgXCJgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW5cIik7XG4gICAgICAgIGludmFyaWFudCQxKHRoaXMuX3J1bGVzQ291bnQgPT09IDAsIFwib3B0aW1pemVGb3JTcGVlZCBjYW5ub3QgYmUgd2hlbiBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZFwiKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gYm9vbDtcbiAgICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc09wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBpc09wdGltaXplRm9yU3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkO1xuICAgIH07XG4gICAgX3Byb3RvLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaW52YXJpYW50JDEoIXRoaXMuX2luamVjdGVkLCBcInNoZWV0IGFscmVhZHkgaW5qZWN0ZWRcIik7XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFnc1swXSA9IHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IFwiaW5zZXJ0UnVsZVwiIGluIHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IG9wdGltaXplRm9yU3BlZWQgbW9kZSBub3Qgc3VwcG9ydGVkIGZhbGxpbmcgYmFjayB0byBzdGFuZGFyZCBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHtcbiAgICAgICAgICAgIGNzc1J1bGVzOiBbXSxcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IGZ1bmN0aW9uKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVSdWxlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gZ2V0U2hlZXRGb3JUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXQgPSBmdW5jdGlvbiBnZXRTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hlZXRGb3JUYWcodGhpcy5fdGFnc1t0aGlzLl90YWdzLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhydWxlKSwgXCJgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3NcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDAwNzk5Mi9jaHJvbWUtc3VkZGVubHktc3RvcHBlZC1hY2NlcHRpbmctaW5zZXJ0cnVsZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLl90YWdzLnB1c2godGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSwgcnVsZSwgaW5zZXJ0aW9uUG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoaW5kZXgsIHJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuICAgICAgICAgICAgaWYgKCFydWxlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGVldC5jc3NSdWxlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBAVEJEIFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuXCIgKyBydWxlICsgXCJcXG5cXG5TZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMDA3OTkyIGZvciBtb3JlIGluZm9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBpbmRpY2VzIHdlIGluc2VydCBhIGRlbGV0ZVJ1bGVQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUodGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICAgICAgaW52YXJpYW50JDEodGFnLCBcIm9sZCBydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy50ZXh0Q29udGVudCA9IHJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUnVsZShpbmRleCwgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwicnVsZSBhdCBpbmRleCBgXCIgKyBpbmRleCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgdGhpcy5fdGFnc1tpbmRleF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZyAmJiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaW1wbGVyIG9uIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3MucmVkdWNlKGZ1bmN0aW9uKHJ1bGVzLCB0YWcpIHtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoX3RoaXMuZ2V0U2hlZXRGb3JUYWcodGFnKS5jc3NSdWxlcywgZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciA/IG51bGwgOiBydWxlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgX3Byb3RvLm1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyhuYW1lLCBjc3NTdHJpbmcsIHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcoY3NzU3RyaW5nKSwgXCJtYWtlU3R5bGVUYWcgYWNjZXB0cyBvbmx5IHN0cmluZ3MgYXMgc2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fbm9uY2UpIHRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLl9ub25jZSk7XG4gICAgICAgIHRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsIFwiXCIpO1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRhZywgcmVsYXRpdmVUb1RhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5mdW5jdGlvbiBpbnZhcmlhbnQkMShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0OiBcIiArIG1lc3NhZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIHZhciBfJGhhc2ggPSA1MzgxLCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKXtcbiAgICAgICAgXyRoYXNoID0gXyRoYXNoICogMzMgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqLyByZXR1cm4gXyRoYXNoID4+PiAwO1xufVxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG52YXIgc2FuaXRpemUgPSBmdW5jdGlvbihydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUucmVwbGFjZSgvXFwvc3R5bGUvZ2ksIFwiXFxcXC9zdHlsZVwiKTtcbn07XG52YXIgY2FjaGUgPSB7fTtcbi8qKlxuICogY29tcHV0ZUlkXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBhIGpzeCBpZCBmcm9tIGEgYmFzZWRJZCBhbmQgb3B0aW9uYWxseSBwcm9wcy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFwianN4LVwiICsgYmFzZUlkO1xuICAgIH1cbiAgICB2YXIgcHJvcHNUb1N0cmluZyA9IFN0cmluZyhwcm9wcyk7XG4gICAgdmFyIGtleSA9IGJhc2VJZCArIHByb3BzVG9TdHJpbmc7XG4gICAgaWYgKCFjYWNoZVtrZXldKSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSBcImpzeC1cIiArIHN0cmluZ0hhc2goYmFzZUlkICsgXCItXCIgKyBwcm9wc1RvU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG59XG4vKipcbiAqIGNvbXB1dGVTZWxlY3RvclxuICpcbiAqIENvbXB1dGUgYW5kIG1lbW9pemUgZHluYW1pYyBzZWxlY3RvcnMuXG4gKi8gZnVuY3Rpb24gY29tcHV0ZVNlbGVjdG9yKGlkLCBjc3MpIHtcbiAgICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gL19fanN4LXN0eWxlLWR5bmFtaWMtc2VsZWN0b3IvZztcbiAgICAvLyBTYW5pdGl6ZSBTU1ItZWQgQ1NTLlxuICAgIC8vIENsaWVudCBzaWRlIGNvZGUgZG9lc24ndCBuZWVkIHRvIGJlIHNhbml0aXplZCBzaW5jZSB3ZSB1c2VcbiAgICAvLyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSAoZGV2KSBhbmQgdGhlIENTU09NIGFwaSBzaGVldC5pbnNlcnRSdWxlIChwcm9kKS5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgPSBzYW5pdGl6ZShjc3MpO1xuICAgIH1cbiAgICB2YXIgaWRjc3MgPSBpZCArIGNzcztcbiAgICBpZiAoIWNhY2hlW2lkY3NzXSkge1xuICAgICAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2lkY3NzXTtcbn1cblxuZnVuY3Rpb24gbWFwUnVsZXNUb1N0eWxlKGNzc1J1bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBjc3NSdWxlcy5tYXAoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY3NzID0gYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7XG4gICAgICAgICAgICBpZDogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICAvLyBBdm9pZCB3YXJuaW5ncyB1cG9uIHJlbmRlciB3aXRoIGEga2V5XG4gICAgICAgICAgICBrZXk6IFwiX19cIiArIGlkLFxuICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IGNzc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBTdHlsZVNoZWV0UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXRSZWdpc3RyeShwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9zdHlsZVNoZWV0ID0gcmVmLnN0eWxlU2hlZXQsIHN0eWxlU2hlZXQgPSBfc3R5bGVTaGVldCA9PT0gdm9pZCAwID8gbnVsbCA6IF9zdHlsZVNoZWV0LCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgU3R5bGVTaGVldCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0eWxlZC1qc3hcIixcbiAgICAgICAgICAgIG9wdGltaXplRm9yU3BlZWQ6IG9wdGltaXplRm9yU3BlZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICBpZiAoc3R5bGVTaGVldCAmJiB0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQob3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRSZWdpc3RyeS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKHRoaXMuX29wdGltaXplRm9yU3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdGhpcy5zZWxlY3RGcm9tU2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW3RhZ05hbWVdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLCBzdHlsZUlkID0gcmVmLnN0eWxlSWQsIHJ1bGVzID0gcmVmLnJ1bGVzO1xuICAgICAgICAvLyBEZWR1cGluZzoganVzdCBpbmNyZWFzZSB0aGUgaW5zdGFuY2VzIGNvdW50LlxuICAgICAgICBpZiAoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgfSkvLyBGaWx0ZXIgb3V0IGludmFsaWQgcnVsZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0gPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPSAxO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVJZCA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcykuc3R5bGVJZDtcbiAgICAgICAgaW52YXJpYW50KHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzLCBcInN0eWxlSWQ6IGBcIiArIHN0eWxlSWQgKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0YWdGcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciAmJiB0aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdO1xuICAgICAgICAgICAgaWYgKHRhZ0Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0YWdGcm9tU2VydmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnRnJvbVNlcnZlcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0uZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3NoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuYWRkKG5leHRQcm9wcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKHByb3BzKTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9zaGVldC5pbmplY3QoKTtcbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jc3NSdWxlcyA9IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJvbVNlcnZlciA9IHRoaXMuX2Zyb21TZXJ2ZXIgPyBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuICAgICAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoT2JqZWN0LmtleXModGhpcy5faW5kaWNlcykubWFwKGZ1bmN0aW9uKHN0eWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzc1J1bGVzW2luZGV4XS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oX3RoaXMuX29wdGltaXplRm9yU3BlZWQgPyBcIlwiIDogXCJcXG5cIilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLy8gZmlsdGVyIG91dCBlbXB0eSBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJ1bGVbMV0pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1hcFJ1bGVzVG9TdHlsZSh0aGlzLmNzc1J1bGVzKCksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkQW5kUnVsZXMgPSBmdW5jdGlvbiBnZXRJZEFuZFJ1bGVzKHByb3BzKSB7XG4gICAgICAgIHZhciBjc3MgPSBwcm9wcy5jaGlsZHJlbiwgZHluYW1pYyA9IHByb3BzLmR5bmFtaWMsIGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IGNvbXB1dGVJZChpZCwgZHluYW1pYyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZVNlbGVjdG9yKHN0eWxlSWQsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIH0pIDogW1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgY3NzKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlSWQ6IGNvbXB1dGVJZChpZCksXG4gICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzIDogW1xuICAgICAgICAgICAgICAgIGNzc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAqIHNlbGVjdEZyb21TZXJ2ZXJcbiAgICpcbiAgICogQ29sbGVjdHMgc3R5bGUgdGFncyBmcm9tIHRoZSBkb2N1bWVudCB3aXRoIGlkIF9fanN4LVhYWFxuICAgKi8gX3Byb3RvLnNlbGVjdEZyb21TZXJ2ZXIgPSBmdW5jdGlvbiBzZWxlY3RGcm9tU2VydmVyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWRePVwiX19qc3gtXCJdJykpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudC5pZC5zbGljZSgyKTtcbiAgICAgICAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXRSZWdpc3RyeTtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0UmVnaXN0cnk6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG52YXIgU3R5bGVTaGVldENvbnRleHQgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5TdHlsZVNoZWV0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiU3R5bGVTaGVldENvbnRleHRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0UmVnaXN0cnkoKTtcbn1cbmZ1bmN0aW9uIFN0eWxlUmVnaXN0cnkocGFyYW0pIHtcbiAgICB2YXIgY29uZmlndXJlZFJlZ2lzdHJ5ID0gcGFyYW0ucmVnaXN0cnksIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW47XG4gICAgdmFyIHJvb3RSZWdpc3RyeSA9IFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RSZWdpc3RyeSB8fCBjb25maWd1cmVkUmVnaXN0cnkgfHwgY3JlYXRlU3R5bGVSZWdpc3RyeSgpO1xuICAgIH0pLCByZWdpc3RyeSA9IHJlZlswXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcmVnaXN0cnlcbiAgICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1c2VTdHlsZVJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFN0eWxlU2hlZXRDb250ZXh0KTtcbn1cblxuLy8gT3B0LWludG8gdGhlIG5ldyBgdXNlSW5zZXJ0aW9uRWZmZWN0YCBBUEkgaW4gUmVhY3QgMTgsIGZhbGxiYWNrIHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTEwXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZUluc2VydGlvbkVmZmVjdCB8fCBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlTGF5b3V0RWZmZWN0O1xudmFyIGRlZmF1bHRSZWdpc3RyeSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBKU1hTdHlsZShwcm9wcykge1xuICAgIHZhciByZWdpc3RyeSA9IGRlZmF1bHRSZWdpc3RyeSA/IGRlZmF1bHRSZWdpc3RyeSA6IHVzZVN0eWxlUmVnaXN0cnkoKTtcbiAgICAvLyBJZiBgcmVnaXN0cnlgIGRvZXMgbm90IGV4aXN0LCB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVnaXN0cnkucmVtb3ZlKHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAvLyBwcm9wcy5jaGlsZHJlbiBjYW4gYmUgc3RyaW5nW10sIHdpbGwgYmUgc3RyaXBlZCBzaW5jZSBpZCBpcyBpZGVudGljYWxcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLmlkLFxuICAgICAgICBTdHJpbmcocHJvcHMuZHluYW1pYylcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbkpTWFN0eWxlLmR5bmFtaWMgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ubWFwKGZ1bmN0aW9uKHRhZ0luZm8pIHtcbiAgICAgICAgdmFyIGJhc2VJZCA9IHRhZ0luZm9bMF07XG4gICAgICAgIHZhciBwcm9wcyA9IHRhZ0luZm9bMV07XG4gICAgICAgIHJldHVybiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcyk7XG4gICAgfSkuam9pbihcIiBcIik7XG59O1xuXG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gY3JlYXRlU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMuc3R5bGUgPSBKU1hTdHlsZTtcbmV4cG9ydHMudXNlU3R5bGVSZWdpc3RyeSA9IHVzZVN0eWxlUmVnaXN0cnk7XG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIlJlYWN0IiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIlJlYWN0X19kZWZhdWx0IiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImlzUHJvZCIsInByb2Nlc3MiLCJlbnYiLCJpc1N0cmluZyIsIm8iLCJ0b1N0cmluZyIsImNhbGwiLCJTdHlsZVNoZWV0IiwicGFyYW0iLCJyZWYiLCJfbmFtZSIsIm5hbWUiLCJfb3B0aW1pemVGb3JTcGVlZCIsIm9wdGltaXplRm9yU3BlZWQiLCJpbnZhcmlhbnQkMSIsIl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyIiwiX3NlcnZlclNoZWV0IiwidW5kZWZpbmVkIiwiX3RhZ3MiLCJfaW5qZWN0ZWQiLCJfcnVsZXNDb3VudCIsIm5vZGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJfbm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJfcHJvdG8iLCJzZXRPcHRpbWl6ZUZvclNwZWVkIiwiYm9vbCIsImZsdXNoIiwiaW5qZWN0IiwiaXNPcHRpbWl6ZUZvclNwZWVkIiwiX3RoaXMiLCJtYWtlU3R5bGVUYWciLCJnZXRTaGVldCIsImNvbnNvbGUiLCJ3YXJuIiwiY3NzUnVsZXMiLCJpbnNlcnRSdWxlIiwicnVsZSIsImluZGV4IiwiY3NzVGV4dCIsInB1c2giLCJkZWxldGVSdWxlIiwiZ2V0U2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwiZXJyb3IiLCJpbnNlcnRpb25Qb2ludCIsInJlcGxhY2VSdWxlIiwidHJpbSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZm9yRWFjaCIsInJlZHVjZSIsInJ1bGVzIiwiY29uY2F0IiwiQXJyYXkiLCJtYXAiLCJjc3NTdHJpbmciLCJyZWxhdGl2ZVRvVGFnIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInR5cGUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaGFzaCIsInN0ciIsIl8kaGFzaCIsImNoYXJDb2RlQXQiLCJzdHJpbmdIYXNoIiwic2FuaXRpemUiLCJyZXBsYWNlIiwiY2FjaGUiLCJjb21wdXRlSWQiLCJiYXNlSWQiLCJwcm9wc1RvU3RyaW5nIiwiU3RyaW5nIiwiY29tcHV0ZVNlbGVjdG9yIiwiaWQiLCJjc3MiLCJzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAiLCJpZGNzcyIsIm1hcFJ1bGVzVG9TdHlsZSIsIm9wdGlvbnMiLCJhcmdzIiwibm9uY2UiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIlN0eWxlU2hlZXRSZWdpc3RyeSIsIl9zdHlsZVNoZWV0Iiwic3R5bGVTaGVldCIsIl9zaGVldCIsIl9mcm9tU2VydmVyIiwiX2luZGljZXMiLCJfaW5zdGFuY2VzQ291bnRzIiwiYWRkIiwiaXNBcnJheSIsImNoaWxkcmVuIiwic2VsZWN0RnJvbVNlcnZlciIsImtleXMiLCJhY2MiLCJ0YWdOYW1lIiwiZ2V0SWRBbmRSdWxlcyIsInN0eWxlSWQiLCJpbmRpY2VzIiwiZmlsdGVyIiwicmVtb3ZlIiwiaW52YXJpYW50IiwidGFnRnJvbVNlcnZlciIsInVwZGF0ZSIsIm5leHRQcm9wcyIsImZyb21TZXJ2ZXIiLCJqb2luIiwiQm9vbGVhbiIsInN0eWxlcyIsImR5bmFtaWMiLCJlbGVtZW50cyIsInNsaWNlIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW1lbnQiLCJTdHlsZVNoZWV0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImNyZWF0ZVN0eWxlUmVnaXN0cnkiLCJTdHlsZVJlZ2lzdHJ5IiwiY29uZmlndXJlZFJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJyb290UmVnaXN0cnkiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU3R5bGVSZWdpc3RyeSIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImRlZmF1bHRSZWdpc3RyeSIsIkpTWFN0eWxlIiwiaW5mbyIsInRhZ0luZm8iLCJleHBvcnRzIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLCtHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcz8zNzBiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4Jykuc3R5bGVcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInN0eWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/styled-jsx/style.js\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _web_components_board_ChessBoard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../web/components/board/ChessBoard */ \"./src/web/components/board/ChessBoard.tsx\");\n/* harmony import */ var _web_components_controls_GameControls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../web/components/controls/GameControls */ \"./src/web/components/controls/GameControls.tsx\");\n/* harmony import */ var _web_components_info_GameInfo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../web/components/info/GameInfo */ \"./src/web/components/info/GameInfo.tsx\");\n/* harmony import */ var _shared_engine_CulturalChessEngine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/engine/CulturalChessEngine */ \"./src/shared/engine/CulturalChessEngine.ts\");\n/* harmony import */ var _shared_constants_game__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/constants/game */ \"./src/shared/constants/game.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction Home() {\n    _s();\n    const [engine] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new _shared_engine_CulturalChessEngine__WEBPACK_IMPORTED_MODULE_5__.CulturalChessEngine());\n    const [gameHistory, setGameHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [canUndo, setCanUndo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [orientation, setOrientation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"white\");\n    const [culturalStyle, setCulturalStyle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"modern\");\n    const [narratives, setNarratives] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [evaluation, setEvaluation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const handleMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((from, to)=>{\n        const success = engine.makeMove(from, to);\n        if (success) {\n            const analysis = engine.getStyleBasedEvaluation();\n            const newNarratives = engine.getCulturalNarrative();\n            const newEvents = engine.getCulturalEventHistory();\n            setNarratives(newNarratives);\n            setEvaluation(analysis.evaluation);\n            setEvents(newEvents);\n            setGameHistory((prev)=>[\n                    ...prev,\n                    {\n                        from,\n                        to,\n                        piece: engine.getPieceAt(to)\n                    }\n                ]);\n            setCanUndo(true);\n        }\n    }, []);\n    const handleGameEnd = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((result)=>{\n        alert(\"Jogo finalizado! Resultado: \".concat(result));\n    }, []);\n    const handleStyleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((style)=>{\n        if (style in _shared_constants_game__WEBPACK_IMPORTED_MODULE_6__.CULTURAL_STYLES) {\n            setCulturalStyle(style);\n            engine.setCulturalStyle(style);\n            const analysis = engine.getStyleBasedEvaluation();\n            setEvaluation(analysis.evaluation);\n        }\n    }, []);\n    const handleNewGame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        engine.reset();\n        setGameHistory([]);\n        setNarratives([]);\n        setEvents([]);\n        setEvaluation(0);\n        setCanUndo(false);\n    }, []);\n    const handleUndo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (canUndo) {\n            engine.undoLastMove();\n            setGameHistory((prev)=>prev.slice(0, -1));\n            setCanUndo(gameHistory.length > 1);\n            const analysis = engine.getStyleBasedEvaluation();\n            const newNarratives = engine.getCulturalNarrative();\n            const newEvents = engine.getCulturalEventHistory();\n            setEvaluation(analysis.evaluation);\n            setNarratives(newNarratives);\n            setEvents(newEvents);\n        }\n    }, [\n        canUndo,\n        gameHistory.length\n    ]);\n    const handleFlipBoard = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setOrientation((prev)=>prev === \"white\" ? \"black\" : \"white\");\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        \"data-testid\": \"app-container\",\n        className: \"flex flex-col gap-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-testid\": \"header\",\n                className: \"mb-8 text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        \"data-testid\": \"title\",\n                        className: \"text-4xl font-bold text-white mb-2\",\n                        children: \"CHESS: Sistema Cultural de Xadrez\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                        lineNumber: 85,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        \"data-testid\": \"subtitle\",\n                        className: \"text-emerald-100\",\n                        children: \"Uma experi\\xeancia \\xfanica de xadrez com elementos culturais adaptativos\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                        lineNumber: 88,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                lineNumber: 84,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-testid\": \"main-content\",\n                className: \"grid lg:grid-cols-3 gap-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        \"data-testid\": \"board-controls\",\n                        className: \"lg:col-span-2 space-y-8\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_web_components_controls_GameControls__WEBPACK_IMPORTED_MODULE_3__.MemoizedGameControls, {\n                                culturalStyle: culturalStyle,\n                                onStyleChange: handleStyleChange,\n                                onFlipBoard: handleFlipBoard,\n                                onNewGame: handleNewGame,\n                                onUndo: handleUndo,\n                                canUndo: canUndo,\n                                isPlayerTurn: true\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                                lineNumber: 97,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                \"data-testid\": \"board-container\",\n                                className: \"flex justify-center w-full max-w-[800px] h-[calc(100vh-12rem)] min-h-[280px] mx-auto\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_web_components_board_ChessBoard__WEBPACK_IMPORTED_MODULE_2__.MemoizedChessBoard, {\n                                    orientation: orientation,\n                                    culturalStyle: culturalStyle,\n                                    showCoordinates: true,\n                                    onMove: handleMove,\n                                    onGameEnd: handleGameEnd\n                                }, void 0, false, {\n                                    fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                                    lineNumber: 111,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                                lineNumber: 107,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                        lineNumber: 96,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        \"data-testid\": \"info-panel\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_web_components_info_GameInfo__WEBPACK_IMPORTED_MODULE_4__.MemoizedGameInfo, {\n                            culturalStyle: culturalStyle,\n                            moves: gameHistory,\n                            evaluation: evaluation,\n                            narratives: narratives,\n                            events: events\n                        }, void 0, false, {\n                            fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                            lineNumber: 123,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                        lineNumber: 122,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n                lineNumber: 94,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/pages/index.tsx\",\n        lineNumber: 82,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"RSyPflo67lDzGFttycrJKfSjq2s=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNtQjtBQUNPO0FBQ1o7QUFFUTtBQUNoQjtBQUU1QyxTQUFTUSxPQUFPOztJQUM3QixNQUFNLENBQUNDLE9BQU8sR0FBR1IsK0NBQVFBLENBQUMsSUFBTSxJQUFJSyxtRkFBbUJBO0lBQ3ZELE1BQU0sQ0FBQ0ksYUFBYUMsZUFBZSxHQUFHViwrQ0FBUUEsQ0FBYyxFQUFFO0lBQzlELE1BQU0sQ0FBQ1csU0FBU0MsV0FBVyxHQUFHWiwrQ0FBUUEsQ0FBQyxLQUFLO0lBRTVDLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHZCwrQ0FBUUEsQ0FBb0I7SUFDbEUsTUFBTSxDQUFDZSxlQUFlQyxpQkFBaUIsR0FBR2hCLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ2lCLFlBQVlDLGNBQWMsR0FBR2xCLCtDQUFRQSxDQUFXLEVBQUU7SUFDekQsTUFBTSxDQUFDbUIsWUFBWUMsY0FBYyxHQUFHcEIsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDcUIsUUFBUUMsVUFBVSxHQUFHdEIsK0NBQVFBLENBSWhDLEVBQUU7SUFFTixNQUFNdUIsYUFBYXRCLGtEQUFXQSxDQUFDLENBQUN1QixNQUFxQkMsS0FBc0I7UUFDekUsTUFBTUMsVUFBVWxCLE9BQU9tQixRQUFRLENBQUNILE1BQU1DO1FBQ3RDLElBQUlDLFNBQVM7WUFDWCxNQUFNRSxXQUFXcEIsT0FBT3FCLHVCQUF1QjtZQUMvQyxNQUFNQyxnQkFBZ0J0QixPQUFPdUIsb0JBQW9CO1lBQ2pELE1BQU1DLFlBQVl4QixPQUFPeUIsdUJBQXVCO1lBRWhEZixjQUFjWTtZQUNkVixjQUFjUSxTQUFTVCxVQUFVO1lBQ2pDRyxVQUFVVTtZQUNWdEIsZUFBZXdCLENBQUFBLE9BQVE7dUJBQUlBO29CQUFNO3dCQUFFVjt3QkFBTUM7d0JBQUlVLE9BQU8zQixPQUFPNEIsVUFBVSxDQUFDWDtvQkFBSztpQkFBRTtZQUM3RWIsV0FBVyxJQUFJO1FBQ2pCLENBQUM7SUFDSCxHQUFHLEVBQUU7SUFFTCxNQUFNeUIsZ0JBQWdCcEMsa0RBQVdBLENBQUMsQ0FBQ3FDLFNBQW1CO1FBQ3BEQyxNQUFNLCtCQUFzQyxPQUFQRDtJQUN2QyxHQUFHLEVBQUU7SUFFTCxNQUFNRSxvQkFBb0J2QyxrREFBV0EsQ0FBQyxDQUFDd0MsUUFBa0I7UUFDdkQsSUFBSUEsU0FBU25DLG1FQUFlQSxFQUFFO1lBQzVCVSxpQkFBaUJ5QjtZQUNqQmpDLE9BQU9RLGdCQUFnQixDQUFDeUI7WUFDeEIsTUFBTWIsV0FBV3BCLE9BQU9xQix1QkFBdUI7WUFDL0NULGNBQWNRLFNBQVNULFVBQVU7UUFDbkMsQ0FBQztJQUNILEdBQUcsRUFBRTtJQUVMLE1BQU11QixnQkFBZ0J6QyxrREFBV0EsQ0FBQyxJQUFNO1FBQ3RDTyxPQUFPbUMsS0FBSztRQUNaakMsZUFBZSxFQUFFO1FBQ2pCUSxjQUFjLEVBQUU7UUFDaEJJLFVBQVUsRUFBRTtRQUNaRixjQUFjO1FBQ2RSLFdBQVcsS0FBSztJQUNsQixHQUFHLEVBQUU7SUFFTCxNQUFNZ0MsYUFBYTNDLGtEQUFXQSxDQUFDLElBQU07UUFDbkMsSUFBSVUsU0FBUztZQUNYSCxPQUFPcUMsWUFBWTtZQUNuQm5DLGVBQWV3QixDQUFBQSxPQUFRQSxLQUFLWSxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQ3RDbEMsV0FBV0gsWUFBWXNDLE1BQU0sR0FBRztZQUVoQyxNQUFNbkIsV0FBV3BCLE9BQU9xQix1QkFBdUI7WUFDL0MsTUFBTUMsZ0JBQWdCdEIsT0FBT3VCLG9CQUFvQjtZQUNqRCxNQUFNQyxZQUFZeEIsT0FBT3lCLHVCQUF1QjtZQUVoRGIsY0FBY1EsU0FBU1QsVUFBVTtZQUNqQ0QsY0FBY1k7WUFDZFIsVUFBVVU7UUFDWixDQUFDO0lBQ0gsR0FBRztRQUFDckI7UUFBU0YsWUFBWXNDLE1BQU07S0FBQztJQUVoQyxNQUFNQyxrQkFBa0IvQyxrREFBV0EsQ0FBQyxJQUFNO1FBQ3hDYSxlQUFlb0IsQ0FBQUEsT0FBUUEsU0FBUyxVQUFVLFVBQVUsT0FBTztJQUM3RCxHQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ2U7UUFBSUMsZUFBWTtRQUFnQkMsV0FBVTs7MEJBRXZDLDhEQUFDRjtnQkFBSUMsZUFBWTtnQkFBU0MsV0FBVTs7a0NBQ2xDLDhEQUFDQzt3QkFBR0YsZUFBWTt3QkFBUUMsV0FBVTtrQ0FBcUM7Ozs7OztrQ0FHdkUsOERBQUNFO3dCQUFFSCxlQUFZO3dCQUFXQyxXQUFVO2tDQUFtQjs7Ozs7Ozs7Ozs7OzBCQU16RCw4REFBQ0Y7Z0JBQUlDLGVBQVk7Z0JBQWVDLFdBQVU7O2tDQUV4Qyw4REFBQ0Y7d0JBQUlDLGVBQVk7d0JBQWlCQyxXQUFVOzswQ0FDMUMsOERBQUNoRCx1RkFBb0JBO2dDQUNuQlksZUFBZUE7Z0NBQ2Z1QyxlQUFlZDtnQ0FDZmUsYUFBYVA7Z0NBQ2JRLFdBQVdkO2dDQUNYZSxRQUFRYjtnQ0FDUmpDLFNBQVNBO2dDQUNUK0MsY0FBYyxJQUFJOzs7Ozs7MENBR3BCLDhEQUFDVDtnQ0FDQ0MsZUFBWTtnQ0FDWkMsV0FBVTswQ0FFViw0RUFBQ2pELGdGQUFrQkE7b0NBQ2pCVyxhQUFhQTtvQ0FDYkUsZUFBZUE7b0NBQ2Y0QyxpQkFBaUIsSUFBSTtvQ0FDckJDLFFBQVFyQztvQ0FDUnNDLFdBQVd4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBTWpCLDhEQUFDWTt3QkFBSUMsZUFBWTtrQ0FDZiw0RUFBQzlDLDJFQUFnQkE7NEJBQ2ZXLGVBQWVBOzRCQUNmK0MsT0FBT3JEOzRCQUNQVSxZQUFZQTs0QkFDWkYsWUFBWUE7NEJBQ1pJLFFBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU10QixDQUFDO0dBN0h1QmQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2luZGV4LnRzeD8xOWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNZW1vaXplZENoZXNzQm9hcmQgfSBmcm9tICcuLi93ZWIvY29tcG9uZW50cy9ib2FyZC9DaGVzc0JvYXJkJztcbmltcG9ydCB7IE1lbW9pemVkR2FtZUNvbnRyb2xzIH0gZnJvbSAnLi4vd2ViL2NvbXBvbmVudHMvY29udHJvbHMvR2FtZUNvbnRyb2xzJztcbmltcG9ydCB7IE1lbW9pemVkR2FtZUluZm8gfSBmcm9tICcuLi93ZWIvY29tcG9uZW50cy9pbmZvL0dhbWVJbmZvJztcbmltcG9ydCB7IENoZXNzUG9zaXRpb24sIENoZXNzTW92ZSB9IGZyb20gJy4uL3NoYXJlZC90eXBlcy9jaGVzcyc7XG5pbXBvcnQgeyBDdWx0dXJhbENoZXNzRW5naW5lIH0gZnJvbSAnLi4vc2hhcmVkL2VuZ2luZS9DdWx0dXJhbENoZXNzRW5naW5lJztcbmltcG9ydCB7IENVTFRVUkFMX1NUWUxFUyB9IGZyb20gJy4uL3NoYXJlZC9jb25zdGFudHMvZ2FtZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFtlbmdpbmVdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEN1bHR1cmFsQ2hlc3NFbmdpbmUoKSk7XG4gIGNvbnN0IFtnYW1lSGlzdG9yeSwgc2V0R2FtZUhpc3RvcnldID0gdXNlU3RhdGU8Q2hlc3NNb3ZlW10+KFtdKTtcbiAgY29uc3QgW2NhblVuZG8sIHNldENhblVuZG9dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IFtvcmllbnRhdGlvbiwgc2V0T3JpZW50YXRpb25dID0gdXNlU3RhdGU8J3doaXRlJyB8ICdibGFjayc+KCd3aGl0ZScpO1xuICBjb25zdCBbY3VsdHVyYWxTdHlsZSwgc2V0Q3VsdHVyYWxTdHlsZV0gPSB1c2VTdGF0ZSgnbW9kZXJuJyk7XG4gIGNvbnN0IFtuYXJyYXRpdmVzLCBzZXROYXJyYXRpdmVzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtldmFsdWF0aW9uLCBzZXRFdmFsdWF0aW9uXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGU8QXJyYXk8e1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICB9Pj4oW10pO1xuXG4gIGNvbnN0IGhhbmRsZU1vdmUgPSB1c2VDYWxsYmFjaygoZnJvbTogQ2hlc3NQb3NpdGlvbiwgdG86IENoZXNzUG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBzdWNjZXNzID0gZW5naW5lLm1ha2VNb3ZlKGZyb20sIHRvKTtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgY29uc3QgYW5hbHlzaXMgPSBlbmdpbmUuZ2V0U3R5bGVCYXNlZEV2YWx1YXRpb24oKTtcbiAgICAgIGNvbnN0IG5ld05hcnJhdGl2ZXMgPSBlbmdpbmUuZ2V0Q3VsdHVyYWxOYXJyYXRpdmUoKTtcbiAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IGVuZ2luZS5nZXRDdWx0dXJhbEV2ZW50SGlzdG9yeSgpO1xuICAgICAgXG4gICAgICBzZXROYXJyYXRpdmVzKG5ld05hcnJhdGl2ZXMpO1xuICAgICAgc2V0RXZhbHVhdGlvbihhbmFseXNpcy5ldmFsdWF0aW9uKTtcbiAgICAgIHNldEV2ZW50cyhuZXdFdmVudHMpO1xuICAgICAgc2V0R2FtZUhpc3RvcnkocHJldiA9PiBbLi4ucHJldiwgeyBmcm9tLCB0bywgcGllY2U6IGVuZ2luZS5nZXRQaWVjZUF0KHRvKSEgfV0pO1xuICAgICAgc2V0Q2FuVW5kbyh0cnVlKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBoYW5kbGVHYW1lRW5kID0gdXNlQ2FsbGJhY2soKHJlc3VsdDogc3RyaW5nKSA9PiB7XG4gICAgYWxlcnQoYEpvZ28gZmluYWxpemFkbyEgUmVzdWx0YWRvOiAke3Jlc3VsdH1gKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZVN0eWxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHN0eWxlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoc3R5bGUgaW4gQ1VMVFVSQUxfU1RZTEVTKSB7XG4gICAgICBzZXRDdWx0dXJhbFN0eWxlKHN0eWxlKTtcbiAgICAgIGVuZ2luZS5zZXRDdWx0dXJhbFN0eWxlKHN0eWxlKTtcbiAgICAgIGNvbnN0IGFuYWx5c2lzID0gZW5naW5lLmdldFN0eWxlQmFzZWRFdmFsdWF0aW9uKCk7XG4gICAgICBzZXRFdmFsdWF0aW9uKGFuYWx5c2lzLmV2YWx1YXRpb24pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZU5ld0dhbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZW5naW5lLnJlc2V0KCk7XG4gICAgc2V0R2FtZUhpc3RvcnkoW10pO1xuICAgIHNldE5hcnJhdGl2ZXMoW10pO1xuICAgIHNldEV2ZW50cyhbXSk7XG4gICAgc2V0RXZhbHVhdGlvbigwKTtcbiAgICBzZXRDYW5VbmRvKGZhbHNlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZVVuZG8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGNhblVuZG8pIHtcbiAgICAgIGVuZ2luZS51bmRvTGFzdE1vdmUoKTtcbiAgICAgIHNldEdhbWVIaXN0b3J5KHByZXYgPT4gcHJldi5zbGljZSgwLCAtMSkpO1xuICAgICAgc2V0Q2FuVW5kbyhnYW1lSGlzdG9yeS5sZW5ndGggPiAxKTtcbiAgICAgIFxuICAgICAgY29uc3QgYW5hbHlzaXMgPSBlbmdpbmUuZ2V0U3R5bGVCYXNlZEV2YWx1YXRpb24oKTtcbiAgICAgIGNvbnN0IG5ld05hcnJhdGl2ZXMgPSBlbmdpbmUuZ2V0Q3VsdHVyYWxOYXJyYXRpdmUoKTtcbiAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IGVuZ2luZS5nZXRDdWx0dXJhbEV2ZW50SGlzdG9yeSgpO1xuICAgICAgXG4gICAgICBzZXRFdmFsdWF0aW9uKGFuYWx5c2lzLmV2YWx1YXRpb24pO1xuICAgICAgc2V0TmFycmF0aXZlcyhuZXdOYXJyYXRpdmVzKTtcbiAgICAgIHNldEV2ZW50cyhuZXdFdmVudHMpO1xuICAgIH1cbiAgfSwgW2NhblVuZG8sIGdhbWVIaXN0b3J5Lmxlbmd0aF0pO1xuXG4gIGNvbnN0IGhhbmRsZUZsaXBCb2FyZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRPcmllbnRhdGlvbihwcmV2ID0+IHByZXYgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJyk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJhcHAtY29udGFpbmVyXCIgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtOFwiPlxuICAgICAgICB7LyogQ2FiZcOnYWxobyAqL31cbiAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cImhlYWRlclwiIGNsYXNzTmFtZT1cIm1iLTggdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICA8aDEgZGF0YS10ZXN0aWQ9XCJ0aXRsZVwiIGNsYXNzTmFtZT1cInRleHQtNHhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1iLTJcIj5cbiAgICAgICAgICAgIENIRVNTOiBTaXN0ZW1hIEN1bHR1cmFsIGRlIFhhZHJlelxuICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgPHAgZGF0YS10ZXN0aWQ9XCJzdWJ0aXRsZVwiIGNsYXNzTmFtZT1cInRleHQtZW1lcmFsZC0xMDBcIj5cbiAgICAgICAgICAgIFVtYSBleHBlcmnDqm5jaWEgw7puaWNhIGRlIHhhZHJleiBjb20gZWxlbWVudG9zIGN1bHR1cmFpcyBhZGFwdGF0aXZvc1xuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIMOBcmVhIHByaW5jaXBhbCAqL31cbiAgICAgICAgPGRpdiBkYXRhLXRlc3RpZD1cIm1haW4tY29udGVudFwiIGNsYXNzTmFtZT1cImdyaWQgbGc6Z3JpZC1jb2xzLTMgZ2FwLThcIj5cbiAgICAgICAgICB7LyogQ29udHJvbGVzIGUgVGFidWxlaXJvICovfVxuICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJib2FyZC1jb250cm9sc1wiIGNsYXNzTmFtZT1cImxnOmNvbC1zcGFuLTIgc3BhY2UteS04XCI+XG4gICAgICAgICAgICA8TWVtb2l6ZWRHYW1lQ29udHJvbHNcbiAgICAgICAgICAgICAgY3VsdHVyYWxTdHlsZT17Y3VsdHVyYWxTdHlsZX1cbiAgICAgICAgICAgICAgb25TdHlsZUNoYW5nZT17aGFuZGxlU3R5bGVDaGFuZ2V9XG4gICAgICAgICAgICAgIG9uRmxpcEJvYXJkPXtoYW5kbGVGbGlwQm9hcmR9XG4gICAgICAgICAgICAgIG9uTmV3R2FtZT17aGFuZGxlTmV3R2FtZX1cbiAgICAgICAgICAgICAgb25VbmRvPXtoYW5kbGVVbmRvfVxuICAgICAgICAgICAgICBjYW5VbmRvPXtjYW5VbmRvfVxuICAgICAgICAgICAgICBpc1BsYXllclR1cm49e3RydWV9IC8vIFRPRE86IEltcGxlbWVudGFyIGzDs2dpY2EgZGUgdHVybm9cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwiYm9hcmQtY29udGFpbmVyXCIgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgdy1mdWxsIG1heC13LVs4MDBweF0gaC1bY2FsYygxMDB2aC0xMnJlbSldIG1pbi1oLVsyODBweF0gbXgtYXV0b1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxNZW1vaXplZENoZXNzQm9hcmRcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbj17b3JpZW50YXRpb259XG4gICAgICAgICAgICAgICAgY3VsdHVyYWxTdHlsZT17Y3VsdHVyYWxTdHlsZX1cbiAgICAgICAgICAgICAgICBzaG93Q29vcmRpbmF0ZXM9e3RydWV9XG4gICAgICAgICAgICAgICAgb25Nb3ZlPXtoYW5kbGVNb3ZlfVxuICAgICAgICAgICAgICAgIG9uR2FtZUVuZD17aGFuZGxlR2FtZUVuZH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFBhaW5lbCBkZSBJbmZvcm1hw6fDtWVzICovfVxuICAgICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJpbmZvLXBhbmVsXCI+XG4gICAgICAgICAgICA8TWVtb2l6ZWRHYW1lSW5mb1xuICAgICAgICAgICAgICBjdWx0dXJhbFN0eWxlPXtjdWx0dXJhbFN0eWxlfVxuICAgICAgICAgICAgICBtb3Zlcz17Z2FtZUhpc3Rvcnl9XG4gICAgICAgICAgICAgIGV2YWx1YXRpb249e2V2YWx1YXRpb259XG4gICAgICAgICAgICAgIG5hcnJhdGl2ZXM9e25hcnJhdGl2ZXN9XG4gICAgICAgICAgICAgIGV2ZW50cz17ZXZlbnRzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiTWVtb2l6ZWRDaGVzc0JvYXJkIiwiTWVtb2l6ZWRHYW1lQ29udHJvbHMiLCJNZW1vaXplZEdhbWVJbmZvIiwiQ3VsdHVyYWxDaGVzc0VuZ2luZSIsIkNVTFRVUkFMX1NUWUxFUyIsIkhvbWUiLCJlbmdpbmUiLCJnYW1lSGlzdG9yeSIsInNldEdhbWVIaXN0b3J5IiwiY2FuVW5kbyIsInNldENhblVuZG8iLCJvcmllbnRhdGlvbiIsInNldE9yaWVudGF0aW9uIiwiY3VsdHVyYWxTdHlsZSIsInNldEN1bHR1cmFsU3R5bGUiLCJuYXJyYXRpdmVzIiwic2V0TmFycmF0aXZlcyIsImV2YWx1YXRpb24iLCJzZXRFdmFsdWF0aW9uIiwiZXZlbnRzIiwic2V0RXZlbnRzIiwiaGFuZGxlTW92ZSIsImZyb20iLCJ0byIsInN1Y2Nlc3MiLCJtYWtlTW92ZSIsImFuYWx5c2lzIiwiZ2V0U3R5bGVCYXNlZEV2YWx1YXRpb24iLCJuZXdOYXJyYXRpdmVzIiwiZ2V0Q3VsdHVyYWxOYXJyYXRpdmUiLCJuZXdFdmVudHMiLCJnZXRDdWx0dXJhbEV2ZW50SGlzdG9yeSIsInByZXYiLCJwaWVjZSIsImdldFBpZWNlQXQiLCJoYW5kbGVHYW1lRW5kIiwicmVzdWx0IiwiYWxlcnQiLCJoYW5kbGVTdHlsZUNoYW5nZSIsInN0eWxlIiwiaGFuZGxlTmV3R2FtZSIsInJlc2V0IiwiaGFuZGxlVW5kbyIsInVuZG9MYXN0TW92ZSIsInNsaWNlIiwibGVuZ3RoIiwiaGFuZGxlRmxpcEJvYXJkIiwiZGl2IiwiZGF0YS10ZXN0aWQiLCJjbGFzc05hbWUiLCJoMSIsInAiLCJvblN0eWxlQ2hhbmdlIiwib25GbGlwQm9hcmQiLCJvbk5ld0dhbWUiLCJvblVuZG8iLCJpc1BsYXllclR1cm4iLCJzaG93Q29vcmRpbmF0ZXMiLCJvbk1vdmUiLCJvbkdhbWVFbmQiLCJtb3ZlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./src/shared/constants/game.ts":
/*!**************************************!*\
  !*** ./src/shared/constants/game.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AI_LEVELS\": function() { return /* binding */ AI_LEVELS; },\n/* harmony export */   \"ANALYSIS_CONFIG\": function() { return /* binding */ ANALYSIS_CONFIG; },\n/* harmony export */   \"BOARD_SIZE\": function() { return /* binding */ BOARD_SIZE; },\n/* harmony export */   \"CACHE_CONFIG\": function() { return /* binding */ CACHE_CONFIG; },\n/* harmony export */   \"CULTURAL_EVENTS\": function() { return /* binding */ CULTURAL_EVENTS; },\n/* harmony export */   \"CULTURAL_STYLES\": function() { return /* binding */ CULTURAL_STYLES; },\n/* harmony export */   \"GAME_RESULTS\": function() { return /* binding */ GAME_RESULTS; },\n/* harmony export */   \"GAME_STATUS\": function() { return /* binding */ GAME_STATUS; },\n/* harmony export */   \"INITIAL_FEN\": function() { return /* binding */ INITIAL_FEN; },\n/* harmony export */   \"MONITORING_CONFIG\": function() { return /* binding */ MONITORING_CONFIG; },\n/* harmony export */   \"MOVE_QUALITY\": function() { return /* binding */ MOVE_QUALITY; },\n/* harmony export */   \"MOVE_TYPES\": function() { return /* binding */ MOVE_TYPES; },\n/* harmony export */   \"PIECES\": function() { return /* binding */ PIECES; },\n/* harmony export */   \"PIECE_SYMBOLS\": function() { return /* binding */ PIECE_SYMBOLS; },\n/* harmony export */   \"TIME_CONTROLS\": function() { return /* binding */ TIME_CONTROLS; }\n/* harmony export */ });\n// Constantes do jogo de xadrez\n// Configuraes do tabuleiro\nconst BOARD_SIZE = 8;\nconst INITIAL_FEN = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n// Peas do jogo\nconst PIECES = {\n    KING: \"k\",\n    QUEEN: \"q\",\n    ROOK: \"r\",\n    BISHOP: \"b\",\n    KNIGHT: \"n\",\n    PAWN: \"p\"\n};\n// Smbolos Unicode das peas\nconst PIECE_SYMBOLS = {\n    // Peas brancas\n    \"K\": \"\",\n    \"Q\": \"\",\n    \"R\": \"\",\n    \"B\": \"\",\n    \"N\": \"\",\n    \"P\": \"\",\n    // Peas pretas\n    \"k\": \"\",\n    \"q\": \"\",\n    \"r\": \"\",\n    \"b\": \"\",\n    \"n\": \"\",\n    \"p\": \"\"\n};\n// Status do jogo\nconst GAME_STATUS = {\n    WAITING: \"waiting\",\n    ACTIVE: \"active\",\n    PAUSED: \"paused\",\n    COMPLETED: \"completed\",\n    ABORTED: \"aborted\"\n};\n// Tipos de movimento\nconst MOVE_TYPES = {\n    NORMAL: \"normal\",\n    CAPTURE: \"capture\",\n    CASTLE_KINGSIDE: \"castle_kingside\",\n    CASTLE_QUEENSIDE: \"castle_queenside\",\n    EN_PASSANT: \"en_passant\",\n    PROMOTION: \"promotion\"\n};\n// Resultados do jogo\nconst GAME_RESULTS = {\n    WHITE_WIN: \"white_win\",\n    BLACK_WIN: \"black_win\",\n    DRAW: \"draw\",\n    STALEMATE: \"stalemate\",\n    INSUFFICIENT_MATERIAL: \"insufficient_material\",\n    THREEFOLD_REPETITION: \"threefold_repetition\",\n    FIFTY_MOVE_RULE: \"fifty_move_rule\",\n    ABANDONED: \"abandoned\"\n};\n// Controles de tempo\nconst TIME_CONTROLS = {\n    BULLET: {\n        initial: 60 * 1,\n        increment: 0\n    },\n    BLITZ: {\n        initial: 60 * 3,\n        increment: 2\n    },\n    RAPID: {\n        initial: 60 * 10,\n        increment: 5\n    },\n    CLASSICAL: {\n        initial: 60 * 30,\n        increment: 10\n    }\n};\n// Nveis de dificuldade da IA\nconst AI_LEVELS = {\n    BEGINNER: 1,\n    CASUAL: 3,\n    INTERMEDIATE: 5,\n    ADVANCED: 7,\n    EXPERT: 9\n};\n// Estilos culturais\nconst CULTURAL_STYLES = {\n    MEDIEVAL: \"medieval\",\n    RENAISSANCE: \"renaissance\",\n    MODERN: \"modern\",\n    ANCIENT: \"ancient\"\n};\n// Eventos culturais\nconst CULTURAL_EVENTS = {\n    BRILLIANT_MOVE: \"brilliant_move\",\n    CRITICAL_POSITION: \"critical_position\",\n    WINNING_SEQUENCE: \"winning_sequence\",\n    TACTICAL_OPPORTUNITY: \"tactical_opportunity\",\n    STRATEGIC_ADVANTAGE: \"strategic_advantage\"\n};\n// Configuraes de anlise\nconst ANALYSIS_CONFIG = {\n    DEPTH_DEFAULT: 20,\n    DEPTH_DEEP: 30,\n    MIN_TIME: 100,\n    MAX_TIME: 5000,\n    NODES_LIMIT: 1000000\n};\n// Mtricas de qualidade\nconst MOVE_QUALITY = {\n    BRILLIANT: {\n        threshold: 0.95,\n        color: \"#FFD700\"\n    },\n    GREAT: {\n        threshold: 0.85,\n        color: \"#32CD32\"\n    },\n    GOOD: {\n        threshold: 0.70,\n        color: \"#90EE90\"\n    },\n    INACCURACY: {\n        threshold: 0.50,\n        color: \"#FFD700\"\n    },\n    MISTAKE: {\n        threshold: 0.30,\n        color: \"#FFA500\"\n    },\n    BLUNDER: {\n        threshold: 0.15,\n        color: \"#FF0000\"\n    }\n};\n// Configuraes de cache\nconst CACHE_CONFIG = {\n    POSITION_TTL: 60 * 60,\n    ANALYSIS_TTL: 24 * 60 * 60,\n    MAX_CACHE_SIZE: 1000,\n    WARMUP_DEPTH: 2\n};\n// Configuraes de monitoramento\nconst MONITORING_CONFIG = {\n    METRICS_INTERVAL: 5000,\n    HEALTH_CHECK_INTERVAL: 30000,\n    ERROR_THRESHOLD: 0.05,\n    PERFORMANCE_THRESHOLD: 1000\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGtCQUFrQjtJQUNsQkMsdUJBQXVCO0lBQ3ZCQyxpQkFBaUI7SUFDakJDLHVCQUF1QjtBQUN6QixFQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zaGFyZWQvY29uc3RhbnRzL2dhbWUudHM/NDVhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb25zdGFudGVzIGRvIGpvZ28gZGUgeGFkcmV6XG5cbi8vIENvbmZpZ3VyYcOnw7VlcyBkbyB0YWJ1bGVpcm9cbmV4cG9ydCBjb25zdCBCT0FSRF9TSVpFID0gODtcbmV4cG9ydCBjb25zdCBJTklUSUFMX0ZFTiA9ICdybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMSc7XG5cbi8vIFBlw6dhcyBkbyBqb2dvXG5leHBvcnQgY29uc3QgUElFQ0VTID0ge1xuICBLSU5HOiAnaycsXG4gIFFVRUVOOiAncScsXG4gIFJPT0s6ICdyJyxcbiAgQklTSE9QOiAnYicsXG4gIEtOSUdIVDogJ24nLFxuICBQQVdOOiAncCcsXG59IGFzIGNvbnN0O1xuXG4vLyBTw61tYm9sb3MgVW5pY29kZSBkYXMgcGXDp2FzXG5leHBvcnQgY29uc3QgUElFQ0VfU1lNQk9MUyA9IHtcbiAgLy8gUGXDp2FzIGJyYW5jYXNcbiAgJ0snOiAn4pmUJyxcbiAgJ1EnOiAn4pmVJyxcbiAgJ1InOiAn4pmWJyxcbiAgJ0InOiAn4pmXJyxcbiAgJ04nOiAn4pmYJyxcbiAgJ1AnOiAn4pmZJyxcbiAgLy8gUGXDp2FzIHByZXRhc1xuICAnayc6ICfimZonLFxuICAncSc6ICfimZsnLFxuICAncic6ICfimZwnLFxuICAnYic6ICfimZ0nLFxuICAnbic6ICfimZ4nLFxuICAncCc6ICfimZ8nLFxufSBhcyBjb25zdDtcblxuLy8gU3RhdHVzIGRvIGpvZ29cbmV4cG9ydCBjb25zdCBHQU1FX1NUQVRVUyA9IHtcbiAgV0FJVElORzogJ3dhaXRpbmcnLFxuICBBQ1RJVkU6ICdhY3RpdmUnLFxuICBQQVVTRUQ6ICdwYXVzZWQnLFxuICBDT01QTEVURUQ6ICdjb21wbGV0ZWQnLFxuICBBQk9SVEVEOiAnYWJvcnRlZCcsXG59IGFzIGNvbnN0O1xuXG4vLyBUaXBvcyBkZSBtb3ZpbWVudG9cbmV4cG9ydCBjb25zdCBNT1ZFX1RZUEVTID0ge1xuICBOT1JNQUw6ICdub3JtYWwnLFxuICBDQVBUVVJFOiAnY2FwdHVyZScsXG4gIENBU1RMRV9LSU5HU0lERTogJ2Nhc3RsZV9raW5nc2lkZScsXG4gIENBU1RMRV9RVUVFTlNJREU6ICdjYXN0bGVfcXVlZW5zaWRlJyxcbiAgRU5fUEFTU0FOVDogJ2VuX3Bhc3NhbnQnLFxuICBQUk9NT1RJT046ICdwcm9tb3Rpb24nLFxufSBhcyBjb25zdDtcblxuLy8gUmVzdWx0YWRvcyBkbyBqb2dvXG5leHBvcnQgY29uc3QgR0FNRV9SRVNVTFRTID0ge1xuICBXSElURV9XSU46ICd3aGl0ZV93aW4nLFxuICBCTEFDS19XSU46ICdibGFja193aW4nLFxuICBEUkFXOiAnZHJhdycsXG4gIFNUQUxFTUFURTogJ3N0YWxlbWF0ZScsXG4gIElOU1VGRklDSUVOVF9NQVRFUklBTDogJ2luc3VmZmljaWVudF9tYXRlcmlhbCcsXG4gIFRIUkVFRk9MRF9SRVBFVElUSU9OOiAndGhyZWVmb2xkX3JlcGV0aXRpb24nLFxuICBGSUZUWV9NT1ZFX1JVTEU6ICdmaWZ0eV9tb3ZlX3J1bGUnLFxuICBBQkFORE9ORUQ6ICdhYmFuZG9uZWQnLFxufSBhcyBjb25zdDtcblxuLy8gQ29udHJvbGVzIGRlIHRlbXBvXG5leHBvcnQgY29uc3QgVElNRV9DT05UUk9MUyA9IHtcbiAgQlVMTEVUOiB7XG4gICAgaW5pdGlhbDogNjAgKiAxLCAgICAgIC8vIDEgbWludXRvXG4gICAgaW5jcmVtZW50OiAwLFxuICB9LFxuICBCTElUWjoge1xuICAgIGluaXRpYWw6IDYwICogMywgICAgICAvLyAzIG1pbnV0b3NcbiAgICBpbmNyZW1lbnQ6IDIsXG4gIH0sXG4gIFJBUElEOiB7XG4gICAgaW5pdGlhbDogNjAgKiAxMCwgICAgIC8vIDEwIG1pbnV0b3NcbiAgICBpbmNyZW1lbnQ6IDUsXG4gIH0sXG4gIENMQVNTSUNBTDoge1xuICAgIGluaXRpYWw6IDYwICogMzAsICAgICAvLyAzMCBtaW51dG9zXG4gICAgaW5jcmVtZW50OiAxMCxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbi8vIE7DrXZlaXMgZGUgZGlmaWN1bGRhZGUgZGEgSUFcbmV4cG9ydCBjb25zdCBBSV9MRVZFTFMgPSB7XG4gIEJFR0lOTkVSOiAxLFxuICBDQVNVQUw6IDMsXG4gIElOVEVSTUVESUFURTogNSxcbiAgQURWQU5DRUQ6IDcsXG4gIEVYUEVSVDogOSxcbn0gYXMgY29uc3Q7XG5cbi8vIEVzdGlsb3MgY3VsdHVyYWlzXG5leHBvcnQgY29uc3QgQ1VMVFVSQUxfU1RZTEVTID0ge1xuICBNRURJRVZBTDogJ21lZGlldmFsJyxcbiAgUkVOQUlTU0FOQ0U6ICdyZW5haXNzYW5jZScsXG4gIE1PREVSTjogJ21vZGVybicsXG4gIEFOQ0lFTlQ6ICdhbmNpZW50Jyxcbn0gYXMgY29uc3Q7XG5cbi8vIEV2ZW50b3MgY3VsdHVyYWlzXG5leHBvcnQgY29uc3QgQ1VMVFVSQUxfRVZFTlRTID0ge1xuICBCUklMTElBTlRfTU9WRTogJ2JyaWxsaWFudF9tb3ZlJyxcbiAgQ1JJVElDQUxfUE9TSVRJT046ICdjcml0aWNhbF9wb3NpdGlvbicsXG4gIFdJTk5JTkdfU0VRVUVOQ0U6ICd3aW5uaW5nX3NlcXVlbmNlJyxcbiAgVEFDVElDQUxfT1BQT1JUVU5JVFk6ICd0YWN0aWNhbF9vcHBvcnR1bml0eScsXG4gIFNUUkFURUdJQ19BRFZBTlRBR0U6ICdzdHJhdGVnaWNfYWR2YW50YWdlJyxcbn0gYXMgY29uc3Q7XG5cbi8vIENvbmZpZ3VyYcOnw7VlcyBkZSBhbsOhbGlzZVxuZXhwb3J0IGNvbnN0IEFOQUxZU0lTX0NPTkZJRyA9IHtcbiAgREVQVEhfREVGQVVMVDogMjAsXG4gIERFUFRIX0RFRVA6IDMwLFxuICBNSU5fVElNRTogMTAwLCAgICAvLyBtc1xuICBNQVhfVElNRTogNTAwMCwgICAvLyBtc1xuICBOT0RFU19MSU1JVDogMTAwMDAwMCxcbn0gYXMgY29uc3Q7XG5cbi8vIE3DqXRyaWNhcyBkZSBxdWFsaWRhZGVcbmV4cG9ydCBjb25zdCBNT1ZFX1FVQUxJVFkgPSB7XG4gIEJSSUxMSUFOVDoge1xuICAgIHRocmVzaG9sZDogMC45NSxcbiAgICBjb2xvcjogJyNGRkQ3MDAnLFxuICB9LFxuICBHUkVBVDoge1xuICAgIHRocmVzaG9sZDogMC44NSxcbiAgICBjb2xvcjogJyMzMkNEMzInLFxuICB9LFxuICBHT09EOiB7XG4gICAgdGhyZXNob2xkOiAwLjcwLFxuICAgIGNvbG9yOiAnIzkwRUU5MCcsXG4gIH0sXG4gIElOQUNDVVJBQ1k6IHtcbiAgICB0aHJlc2hvbGQ6IDAuNTAsXG4gICAgY29sb3I6ICcjRkZENzAwJyxcbiAgfSxcbiAgTUlTVEFLRToge1xuICAgIHRocmVzaG9sZDogMC4zMCxcbiAgICBjb2xvcjogJyNGRkE1MDAnLFxuICB9LFxuICBCTFVOREVSOiB7XG4gICAgdGhyZXNob2xkOiAwLjE1LFxuICAgIGNvbG9yOiAnI0ZGMDAwMCcsXG4gIH0sXG59IGFzIGNvbnN0O1xuXG4vLyBDb25maWd1cmHDp8O1ZXMgZGUgY2FjaGVcbmV4cG9ydCBjb25zdCBDQUNIRV9DT05GSUcgPSB7XG4gIFBPU0lUSU9OX1RUTDogNjAgKiA2MCwgICAgLy8gMSBob3JhXG4gIEFOQUxZU0lTX1RUTDogMjQgKiA2MCAqIDYwLCAvLyAxIGRpYVxuICBNQVhfQ0FDSEVfU0laRTogMTAwMCwgICAgIC8vIGVudHJhZGFzXG4gIFdBUk1VUF9ERVBUSDogMiwgICAgICAgICAgLy8gbsOtdmVpcyBkZSBwcm9mdW5kaWRhZGUgcGFyYSBwcsOpLWNhcnJlZ2FyXG59IGFzIGNvbnN0O1xuXG4vLyBDb25maWd1cmHDp8O1ZXMgZGUgbW9uaXRvcmFtZW50b1xuZXhwb3J0IGNvbnN0IE1PTklUT1JJTkdfQ09ORklHID0ge1xuICBNRVRSSUNTX0lOVEVSVkFMOiA1MDAwLCAgIC8vIDUgc2VndW5kb3NcbiAgSEVBTFRIX0NIRUNLX0lOVEVSVkFMOiAzMDAwMCwgLy8gMzAgc2VndW5kb3NcbiAgRVJST1JfVEhSRVNIT0xEOiAwLjA1LCAgICAvLyA1JSBkZSBlcnJvIG3DoXhpbW9cbiAgUEVSRk9STUFOQ0VfVEhSRVNIT0xEOiAxMDAwLCAvLyAxIHNlZ3VuZG8gbcOheGltbyBkZSByZXNwb3N0YVxufSBhcyBjb25zdDtcbiJdLCJuYW1lcyI6WyJCT0FSRF9TSVpFIiwiSU5JVElBTF9GRU4iLCJQSUVDRVMiLCJLSU5HIiwiUVVFRU4iLCJST09LIiwiQklTSE9QIiwiS05JR0hUIiwiUEFXTiIsIlBJRUNFX1NZTUJPTFMiLCJHQU1FX1NUQVRVUyIsIldBSVRJTkciLCJBQ1RJVkUiLCJQQVVTRUQiLCJDT01QTEVURUQiLCJBQk9SVEVEIiwiTU9WRV9UWVBFUyIsIk5PUk1BTCIsIkNBUFRVUkUiLCJDQVNUTEVfS0lOR1NJREUiLCJDQVNUTEVfUVVFRU5TSURFIiwiRU5fUEFTU0FOVCIsIlBST01PVElPTiIsIkdBTUVfUkVTVUxUUyIsIldISVRFX1dJTiIsIkJMQUNLX1dJTiIsIkRSQVciLCJTVEFMRU1BVEUiLCJJTlNVRkZJQ0lFTlRfTUFURVJJQUwiLCJUSFJFRUZPTERfUkVQRVRJVElPTiIsIkZJRlRZX01PVkVfUlVMRSIsIkFCQU5ET05FRCIsIlRJTUVfQ09OVFJPTFMiLCJCVUxMRVQiLCJpbml0aWFsIiwiaW5jcmVtZW50IiwiQkxJVFoiLCJSQVBJRCIsIkNMQVNTSUNBTCIsIkFJX0xFVkVMUyIsIkJFR0lOTkVSIiwiQ0FTVUFMIiwiSU5URVJNRURJQVRFIiwiQURWQU5DRUQiLCJFWFBFUlQiLCJDVUxUVVJBTF9TVFlMRVMiLCJNRURJRVZBTCIsIlJFTkFJU1NBTkNFIiwiTU9ERVJOIiwiQU5DSUVOVCIsIkNVTFRVUkFMX0VWRU5UUyIsIkJSSUxMSUFOVF9NT1ZFIiwiQ1JJVElDQUxfUE9TSVRJT04iLCJXSU5OSU5HX1NFUVVFTkNFIiwiVEFDVElDQUxfT1BQT1JUVU5JVFkiLCJTVFJBVEVHSUNfQURWQU5UQUdFIiwiQU5BTFlTSVNfQ09ORklHIiwiREVQVEhfREVGQVVMVCIsIkRFUFRIX0RFRVAiLCJNSU5fVElNRSIsIk1BWF9USU1FIiwiTk9ERVNfTElNSVQiLCJNT1ZFX1FVQUxJVFkiLCJCUklMTElBTlQiLCJ0aHJlc2hvbGQiLCJjb2xvciIsIkdSRUFUIiwiR09PRCIsIklOQUNDVVJBQ1kiLCJNSVNUQUtFIiwiQkxVTkRFUiIsIkNBQ0hFX0NPTkZJRyIsIlBPU0lUSU9OX1RUTCIsIkFOQUxZU0lTX1RUTCIsIk1BWF9DQUNIRV9TSVpFIiwiV0FSTVVQX0RFUFRIIiwiTU9OSVRPUklOR19DT05GSUciLCJNRVRSSUNTX0lOVEVSVkFMIiwiSEVBTFRIX0NIRUNLX0lOVEVSVkFMIiwiRVJST1JfVEhSRVNIT0xEIiwiUEVSRk9STUFOQ0VfVEhSRVNIT0xEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/shared/constants/game.ts\n"));

/***/ }),

/***/ "./src/shared/engine/ChessEngineBase.ts":
/*!**********************************************!*\
  !*** ./src/shared/engine/ChessEngineBase.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChessEngineBase\": function() { return /* binding */ ChessEngineBase; }\n/* harmony export */ });\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var _monitoring_ArquimaxMonitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./monitoring/ArquimaxMonitor */ \"./src/shared/engine/monitoring/ArquimaxMonitor.ts\");\n/* harmony import */ var _constants_game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/game */ \"./src/shared/constants/game.ts\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n/**\n * Implementao base do motor de xadrez.\n * \n * Esta classe fornece a funcionalidade central para um motor de xadrez,\n * incluindo gerenciamento de estado do jogo, validao de movimentos,\n * avaliao de posio e eventos do jogo.\n * \n * @implements {ChessEngine}\n */ class ChessEngineBase {\n    // Estado do jogo\n    /**\n   * Obtm a representao atual do tabuleiro.\n   * \n   * @returns Uma matriz 8x8 representando o tabuleiro, onde cada elemento\n   *  uma pea de xadrez ou null para casas vazias.\n   */ getBoard() {\n        const board = this.game.board();\n        return board.map((row)=>row.map((square)=>square ? {\n                    type: square.type,\n                    color: square.color === \"w\" ? \"white\" : \"black\"\n                } : null));\n    }\n    /**\n   * Obtm a posio atual em notao FEN.\n   * \n   * @returns String FEN representando o estado atual do jogo\n   */ getFEN() {\n        return this.game.fen();\n    }\n    /**\n   * Define uma nova posio para o jogo usando notao FEN.\n   * \n   * @param fen - String FEN representando a nova posio\n   * @throws {Error} Se a string FEN for invlida\n   * @emits {POSITION_CHANGED} Quando a posio  alterada com sucesso\n   */ setFEN(fen) {\n        try {\n            // Na nova verso do chess.js, load() j valida o FEN\n            this.game.load(fen);\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen\n            });\n        } catch (e) {\n            throw new Error(\"Invalid FEN string\");\n        }\n    }\n    // Movimentos\n    /**\n   * Obtm todos os movimentos legais possveis para uma pea em uma determinada posio.\n   * \n   * @param position - Posio da pea no tabuleiro\n   * @returns Lista de movimentos legais possveis\n   */ getPossibleMoves(position) {\n        try {\n            const square = this.positionToSquare(position);\n            const fen = this.getFEN();\n            const cacheKey = \"\".concat(fen, \":\").concat(square);\n            const cacheHit = this.positionCache.has(cacheKey);\n            let moves;\n            if (cacheHit) {\n                const cache = this.positionCache.get(cacheKey);\n                moves = cache.bestLine;\n            } else {\n                moves = this.game.moves({\n                    square,\n                    verbose: true\n                });\n                // Cache the result\n                this.positionCache.set(cacheKey, {\n                    evaluation: 0,\n                    depth: 0,\n                    bestLine: moves,\n                    threats: [],\n                    positionalFeatures: {\n                        pawnStructure: 0,\n                        kingSafety: 0,\n                        mobility: 0,\n                        centerControl: 0,\n                        pieceActivity: 0\n                    }\n                });\n            }\n            this.monitor.recordCacheAccess(cacheHit);\n            return moves.map((move)=>({\n                    from: this.squareToPosition(move.from),\n                    to: this.squareToPosition(move.to),\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                }));\n        } catch (e) {\n            // Se houver erro na gerao de movimentos, retorna lista vazia\n            return [];\n        }\n    }\n    /**\n   * Executa um movimento no tabuleiro.\n   * \n   * @param from - Posio inicial da pea\n   * @param to - Posio final da pea\n   * @returns true se o movimento foi executado com sucesso, false caso contrrio\n   * @emits {MOVE_MADE} Quando um movimento  realizado com sucesso\n   * @emits {CHECK} Quando o movimento resulta em xeque\n   * @emits {GAME_OVER} Quando o movimento resulta em fim de jogo\n   */ makeMove(from, to) {\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\" // Auto-promove para rainha por padro\n            });\n            if (move) {\n                const chessMove = {\n                    from,\n                    to,\n                    piece: {\n                        type: move.piece,\n                        color: move.color === \"w\" ? \"white\" : \"black\"\n                    },\n                    captured: move.captured ? {\n                        type: move.captured,\n                        color: move.color === \"w\" ? \"black\" : \"white\"\n                    } : undefined,\n                    promotion: move.promotion\n                };\n                this.emitEvent({\n                    type: \"MOVE_MADE\",\n                    move: chessMove\n                });\n                if (this.isCheck()) {\n                    this.emitEvent({\n                        type: \"CHECK\",\n                        kingPosition: this.findKing(this.getCurrentPlayer())\n                    });\n                }\n                if (this.isGameOver()) {\n                    let result = \"draw\";\n                    if (this.isCheckmate()) {\n                        result = this.getCurrentPlayer() === \"white\" ? \"black\" : \"white\";\n                    }\n                    this.emitEvent({\n                        type: \"GAME_OVER\",\n                        result\n                    });\n                }\n                return true;\n            }\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n   * Desfaz o ltimo movimento realizado.\n   * \n   * @returns true se havia um movimento para desfazer, false caso contrrio\n   * @emits {POSITION_CHANGED} Quando o movimento  desfeito com sucesso\n   */ undoLastMove() {\n        const move = this.game.undo();\n        if (move) {\n            this.emitEvent({\n                type: \"POSITION_CHANGED\",\n                fen: this.getFEN()\n            });\n            return true;\n        }\n        return false;\n    }\n    // Estado do jogo\n    /**\n   * Verifica se o jogador atual est em xeque.\n   * \n   * @returns true se o jogador atual est em xeque, false caso contrrio\n   */ isCheck() {\n        return this.game.isCheck();\n    }\n    /**\n   * Verifica se o jogador atual est em xeque-mate.\n   * \n   * @returns true se o jogador atual est em xeque-mate, false caso contrrio\n   */ isCheckmate() {\n        return this.game.isCheckmate();\n    }\n    /**\n   * Verifica se o jogo est empatado.\n   * \n   * @returns true se o jogo est empatado, false caso contrrio\n   */ isDraw() {\n        return this.game.isDraw();\n    }\n    /**\n   * Verifica se o jogo terminou (xeque-mate ou empate).\n   * \n   * @returns true se o jogo terminou, false caso contrrio\n   */ isGameOver() {\n        return this.game.isGameOver();\n    }\n    /**\n   * Obtm o jogador atual.\n   * \n   * @returns 'white' para as brancas, 'black' para as pretas\n   */ getCurrentPlayer() {\n        const turn = this.game.turn();\n        return turn === \"w\" ? \"white\" : \"black\";\n    }\n    // Avaliao e anlise\n    /**\n   * Avalia a posio atual do jogo.\n   * \n   * Esta funo considera diversos fatores para avaliar a posio:\n   * - Material: Valor das peas presentes no tabuleiro\n   * - Posio: Qualidade do posicionamento das peas\n   * - Mobilidade: Quantidade de movimentos disponveis\n   * - Segurana do Rei: Avaliao da proteo do rei\n   * - Estrutura de Pees: Qualidade da estrutura de pees\n   * \n   * @returns Um nmero que representa a avaliao da posio.\n   * Valores positivos favorecem as brancas, negativos favorecem as pretas.\n   */ evaluatePosition() {\n        // Implementao bsica de avaliao\n        const weights = this.options.evaluationParameters || {\n            materialWeight: 1,\n            positionWeight: 0.1,\n            mobilityWeight: 0.1,\n            kingSafetyWeight: 0.2,\n            pawnStructureWeight: 0.1\n        };\n        let score = 0;\n        // Material\n        score += this.evaluateMaterial() * weights.materialWeight;\n        // Posio das peas\n        score += this.evaluatePiecePositions() * weights.positionWeight;\n        // Mobilidade\n        score += this.evaluateMobility() * weights.mobilityWeight;\n        // Segurana do rei\n        score += this.evaluateKingSafety() * weights.kingSafetyWeight;\n        // Estrutura de pees\n        score += this.evaluatePawnStructure() * weights.pawnStructureWeight;\n        return score;\n    }\n    evaluatePiecePositions() {\n        // Simple piece-square tables evaluation\n        const pieceSquareValues = {\n            p: [\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50,\n                    50\n                ],\n                [\n                    10,\n                    10,\n                    20,\n                    30,\n                    30,\n                    20,\n                    10,\n                    10\n                ],\n                [\n                    5,\n                    5,\n                    10,\n                    25,\n                    25,\n                    10,\n                    5,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    20,\n                    20,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    5,\n                    -5,\n                    -10,\n                    0,\n                    0,\n                    -10,\n                    -5,\n                    5\n                ],\n                [\n                    5,\n                    10,\n                    10,\n                    -20,\n                    -20,\n                    10,\n                    10,\n                    5\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            n: [\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -30,\n                    0,\n                    10,\n                    15,\n                    15,\n                    10,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    15,\n                    20,\n                    20,\n                    15,\n                    5,\n                    -30\n                ],\n                [\n                    -30,\n                    0,\n                    15,\n                    20,\n                    20,\n                    15,\n                    0,\n                    -30\n                ],\n                [\n                    -30,\n                    5,\n                    10,\n                    15,\n                    15,\n                    10,\n                    5,\n                    -30\n                ],\n                [\n                    -40,\n                    -20,\n                    0,\n                    5,\n                    5,\n                    0,\n                    -20,\n                    -40\n                ],\n                [\n                    -50,\n                    -40,\n                    -30,\n                    -30,\n                    -30,\n                    -30,\n                    -40,\n                    -50\n                ]\n            ],\n            b: [\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ],\n                [\n                    -10,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    5,\n                    10,\n                    10,\n                    5,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    5,\n                    10,\n                    10,\n                    5,\n                    5,\n                    -10\n                ],\n                [\n                    -10,\n                    0,\n                    10,\n                    10,\n                    10,\n                    10,\n                    0,\n                    -10\n                ],\n                [\n                    -10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    10,\n                    -10\n                ],\n                [\n                    -10,\n                    5,\n                    0,\n                    0,\n                    0,\n                    0,\n                    5,\n                    -10\n                ],\n                [\n                    -20,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -10,\n                    -20\n                ]\n            ]\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const pieceTable = pieceSquareValues[piece.type];\n                    if (pieceTable) {\n                        const positionValue = pieceTable[piece.color === \"w\" ? row : 7 - row][col];\n                        score += piece.color === \"w\" ? positionValue : -positionValue;\n                    }\n                }\n            }\n        }\n        return score;\n    }\n    /**\n   * Encontra o melhor movimento possvel para o jogador atual.\n   * \n   * @param depth - Profundidade mxima de busca na rvore de movimentos\n   * @returns O melhor movimento encontrado, ou null se nenhum movimento for possvel\n   * @todo Implementar algoritmo minimax com poda alpha-beta\n   */ getBestMove(depth) {\n        // TODO: Implementar busca minimax com poda alpha-beta\n        return null;\n    }\n    /**\n   * Obtm o histrico completo de movimentos do jogo.\n   * \n   * @returns Lista de movimentos realizados desde o incio do jogo\n   */ getGameHistory() {\n        return this.game.history({\n            verbose: true\n        }).map((move)=>({\n                from: this.squareToPosition(move.from),\n                to: this.squareToPosition(move.to),\n                piece: {\n                    type: move.piece,\n                    color: move.color === \"w\" ? \"white\" : \"black\"\n                },\n                captured: move.captured ? {\n                    type: move.captured,\n                    color: move.color === \"w\" ? \"black\" : \"white\"\n                } : undefined,\n                promotion: move.promotion\n            }));\n    }\n    // Validao\n    /**\n   * Verifica se um movimento  vlido sem execut-lo.\n   * \n   * @param from - Posio inicial da pea\n   * @param to - Posio final da pea\n   * @returns true se o movimento  legal, false caso contrrio\n   */ isValidMove(from, to) {\n        // Validao bsica de posio\n        if (!this.isValidPosition(from) || !this.isValidPosition(to)) {\n            return false;\n        }\n        // Verifica se a pea pertence ao jogador atual\n        const piece = this.game.board()[from.row][from.col];\n        if (!piece || piece.color !== (this.getCurrentPlayer() === \"white\" ? \"w\" : \"b\")) {\n            return false;\n        }\n        // Tenta fazer o movimento no chess.js\n        try {\n            const move = this.game.move({\n                from: this.positionToSquare(from),\n                to: this.positionToSquare(to),\n                promotion: \"q\"\n            });\n            if (move) {\n                // Desfaz o movimento para manter o estado original\n                this.game.undo();\n                return true;\n            }\n        } catch (e) {\n        // Ignora erros do chess.js\n        }\n        return false;\n    }\n    /**\n   * Verifica se uma posio est dentro dos limites do tabuleiro.\n   * \n   * @param position - Posio a ser verificada\n   * @returns true se a posio  vlida, false caso contrrio\n   */ isValidPosition(position) {\n        return position.row >= 0 && position.row < 8 && position.col >= 0 && position.col < 8;\n    }\n    // Utilidades\n    /**\n   * Reinicia o jogo para a posio inicial.\n   * \n   * @emits {POSITION_CHANGED} Quando o tabuleiro  reiniciado\n   */ reset() {\n        this.game.reset();\n        this.positionCache.clear();\n        this.emitEvent({\n            type: \"POSITION_CHANGED\",\n            fen: this.getFEN()\n        });\n    }\n    /**\n   * Cria uma cpia independente do motor de xadrez atual.\n   * \n   * @returns Uma nova instncia do motor com o mesmo estado atual\n   */ clone() {\n        const clonedEngine = new ChessEngineBase(this.options);\n        clonedEngine.setFEN(this.getFEN());\n        return clonedEngine;\n    }\n    // Mtodos protegidos auxiliares\n    positionToSquare(position) {\n        const file = String.fromCharCode(\"a\".charCodeAt(0) + position.col);\n        const rank = 8 - position.row;\n        return \"\".concat(file).concat(rank);\n    }\n    squareToPosition(square) {\n        const col = square.charCodeAt(0) - \"a\".charCodeAt(0);\n        const row = 8 - parseInt(square[1]);\n        return {\n            row,\n            col\n        };\n    }\n    findKing(color) {\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece && piece.type === \"k\" && piece.color === (color === \"white\" ? \"w\" : \"b\")) {\n                    return {\n                        row,\n                        col\n                    };\n                }\n            }\n        }\n        throw new Error(\"King not found\");\n    }\n    /**\n   * Verifica o status de sade do motor.\n   * \n   * @returns Status atual do motor incluindo mtricas de desempenho\n   */ checkHealth() {\n        return this.monitor.checkHealth();\n    }\n    /**\n   * Emite um evento do motor.\n   * \n   * @param event - Evento a ser emitido\n   */ emitEvent(event) {\n        this.eventEmitter.emit(\"engine-event\", event);\n        this.monitor.recordEvent(event);\n    }\n    // Mtodos de avaliao\n    evaluateMaterial() {\n        const pieceValues = {\n            p: 1,\n            n: 3,\n            b: 3,\n            r: 5,\n            q: 9,\n            k: 0\n        };\n        let score = 0;\n        const board = this.game.board();\n        for(let row = 0; row < 8; row++){\n            for(let col = 0; col < 8; col++){\n                const piece = board[row][col];\n                if (piece) {\n                    const value = pieceValues[piece.type];\n                    score += piece.color === \"w\" ? value : -value;\n                }\n            }\n        }\n        return score;\n    }\n    evaluateMobility() {\n        const whiteMoves = this.game.moves().length;\n        // Clona o jogo para ver os movimentos do oponente\n        const tempGame = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(this.game.fen());\n        tempGame.load(this.game.fen().replace(\" w \", \" b \"));\n        const blackMoves = tempGame.moves().length;\n        return whiteMoves - blackMoves;\n    }\n    evaluateKingSafety() {\n        // TODO: Implementar avaliao de segurana do rei\n        return 0;\n    }\n    evaluatePawnStructure() {\n        // TODO: Implementar avaliao de estrutura de pees\n        return 0;\n    }\n    // Event handlers\n    on(eventName, handler) {\n        this.eventEmitter.on(eventName, handler);\n    }\n    off(eventName, handler) {\n        this.eventEmitter.off(eventName, handler);\n    }\n    /**\n   * Cria uma nova instncia do motor de xadrez.\n   * \n   * @param options - Opes de configurao do motor\n   * @param options.startPosition - Posio inicial em notao FEN (opcional)\n   * @param options.evaluationParameters - Parmetros para avaliao de posio (opcional)\n   */ constructor(options = {}){\n        this.game = new chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess(options.startPosition || _constants_game__WEBPACK_IMPORTED_MODULE_2__.INITIAL_FEN);\n        this.options = options;\n        this.eventEmitter = new events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n        this.positionCache = new Map();\n        this.monitor = new _monitoring_ArquimaxMonitor__WEBPACK_IMPORTED_MODULE_1__.ArquimaxMonitor();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBYzhCO0FBQ2Y7QUFDVjtBQUV0Qzs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1JO0lBOEJYLGlCQUFpQjtJQUNqQjs7Ozs7R0FLQyxHQUNEQyxXQUEyQjtRQUN6QixNQUFNQyxRQUFRLElBQUksQ0FBQ0MsSUFBSSxDQUFDRCxLQUFLO1FBQzdCLE9BQU9BLE1BQU1FLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFDZkEsSUFBSUQsR0FBRyxDQUFDRSxDQUFBQSxTQUNOQSxTQUFTO29CQUNQQyxNQUFNRCxPQUFPQyxJQUFJO29CQUNqQkMsT0FBT0YsT0FBT0UsS0FBSyxLQUFLLE1BQU0sVUFBVSxPQUFPO2dCQUNqRCxJQUFJLElBQUk7SUFHZDtJQUVBOzs7O0dBSUMsR0FDREMsU0FBaUI7UUFDZixPQUFPLElBQUksQ0FBQ04sSUFBSSxDQUFDTyxHQUFHO0lBQ3RCO0lBRUE7Ozs7OztHQU1DLEdBQ0RDLE9BQU9ELEdBQVcsRUFBUTtRQUN4QixJQUFJO1lBQ0YscURBQXFEO1lBQ3JELElBQUksQ0FBQ1AsSUFBSSxDQUFDUyxJQUFJLENBQUNGO1lBQ2YsSUFBSSxDQUFDRyxTQUFTLENBQUM7Z0JBQ2JOLE1BQU07Z0JBQ05HO1lBQ0Y7UUFDRixFQUFFLE9BQU9JLEdBQUc7WUFDVixNQUFNLElBQUlDLE1BQU0sc0JBQXNCO1FBQ3hDO0lBQ0Y7SUFFQSxhQUFhO0lBQ2I7Ozs7O0dBS0MsR0FDREMsaUJBQWlCQyxRQUF1QixFQUFlO1FBQ3JELElBQUk7WUFDRixNQUFNWCxTQUFTLElBQUksQ0FBQ1ksZ0JBQWdCLENBQUNEO1lBQ3JDLE1BQU1QLE1BQU0sSUFBSSxDQUFDRCxNQUFNO1lBQ3ZCLE1BQU1VLFdBQVcsR0FBVWIsT0FBUEksS0FBSSxLQUFVLE9BQVBKO1lBQzNCLE1BQU1jLFdBQVcsSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ0g7WUFFeEMsSUFB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QUFJO29CQUFJO2lCQUFFO2FBQ2hDO1lBQ0RDLEdBQUc7Z0JBQ0Q7b0JBQUMsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFHLENBQUM7b0JBQUs7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUUsQ0FBQztvQkFBRyxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFLO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUs7b0JBQUc7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUs7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBRztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSztvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFHO29CQUFJO29CQUFJO29CQUFJO29CQUFLO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBSztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBRSxDQUFDO29CQUFHLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztpQkFBRzthQUNsQztZQUNEQyxHQUFHO2dCQUNEO29CQUFDLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSTtvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFLO29CQUFJO29CQUFHO29CQUFJO29CQUFLO29CQUFJO29CQUFFLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUs7b0JBQUk7b0JBQUc7b0JBQUk7b0JBQUs7b0JBQUk7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBSztvQkFBRztvQkFBSTtvQkFBSTtvQkFBSTtvQkFBSztvQkFBRSxDQUFDO2lCQUFHO2dCQUNqQztvQkFBQyxDQUFDO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFJO29CQUFHLENBQUM7aUJBQUc7Z0JBQ2pDO29CQUFDLENBQUM7b0JBQUs7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUk7b0JBQUUsQ0FBQztpQkFBRztnQkFDakM7b0JBQUMsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO29CQUFHLENBQUM7b0JBQUcsQ0FBQztvQkFBRyxDQUFDO2lCQUFHO2FBQ2xDO1FBQ0g7UUFFQSxJQUFJVCxRQUFRO1FBQ1osTUFBTXBFLFFBQVEsSUFBSSxDQUFDQyxJQUFJLENBQUNELEtBQUs7UUFFN0IsSUFBSyxJQUFJRyxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztZQUNoQyxJQUFLLElBQUkyRSxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztnQkFDaEMsTUFBTXBDLFFBQVExQyxLQUFLLENBQUNHLElBQUksQ0FBQzJFLElBQUk7Z0JBQzdCLElBQUlwQyxPQUFPO29CQUNULE1BQU1xQyxhQUFhTCxpQkFBaUIsQ0FBQ2hDLE1BQU1yQyxJQUFJLENBQW1DO29CQUNsRixJQUFJMEUsWUFBWTt3QkFDZCxNQUFNQyxnQkFBZ0JELFVBQVUsQ0FBQ3JDLE1BQU1wQyxLQUFLLEtBQUssTUFBTUgsTUFBTSxJQUFJQSxHQUFHLENBQUMsQ0FBQzJFLElBQUk7d0JBQzFFVixTQUFTMUIsTUFBTXBDLEtBQUssS0FBSyxNQUFNMEUsZ0JBQWdCLENBQUNBLGFBQWE7b0JBQy9ELENBQUM7Z0JBQ0gsQ0FBQztZQUNIO1FBQ0Y7UUFFQSxPQUFPWjtJQUNUO0lBRUE7Ozs7OztHQU1DLEdBQ0RhLFlBQVlyRCxLQUFhLEVBQW9CO1FBQzNDLHNEQUFzRDtRQUN0RCxPQUFPLElBQUk7SUFDYjtJQUVBOzs7O0dBSUMsR0FDRHNELGlCQUE4QjtRQUM1QixPQUFPLElBQUksQ0FBQ2pGLElBQUksQ0FBQ2tGLE9BQU8sQ0FBQztZQUFFMUQsU0FBUyxJQUFJO1FBQUMsR0FBR3ZCLEdBQUcsQ0FBQ29DLENBQUFBLE9BQVM7Z0JBQ3ZEQyxNQUFNLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNGLEtBQUtDLElBQUk7Z0JBQ3JDRSxJQUFJLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUNGLEtBQUtHLEVBQUU7Z0JBQ2pDQyxPQUFPO29CQUNMckMsTUFBTWlDLEtBQUtJLEtBQUs7b0JBQ2hCcEMsT0FBT2dDLEtBQUtoQyxLQUFLLEtBQUssTUFBTSxVQUFVLE9BQU87Z0JBQy9DO2dCQUNBcUMsVUFBVUwsS0FBS0ssUUFBUSxHQUFHO29CQUN4QnRDLE1BQU1pQyxLQUFLSyxRQUFRO29CQUNuQnJDLE9BQU9nQyxLQUFLaEMsS0FBSyxLQUFLLE1BQU0sVUFBVSxPQUFPO2dCQUMvQyxJQUFJc0MsU0FBUztnQkFDYkMsV0FBV1AsS0FBS08sU0FBUztZQUMzQjtJQUNGO0lBRUEsWUFBWTtJQUNaOzs7Ozs7R0FNQyxHQUNEdUMsWUFBWTdDLElBQW1CLEVBQUVFLEVBQWlCLEVBQVc7UUFDM0QsOEJBQThCO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUM0QyxlQUFlLENBQUM5QyxTQUFTLENBQUMsSUFBSSxDQUFDOEMsZUFBZSxDQUFDNUMsS0FBSztZQUM1RCxPQUFPLEtBQUs7UUFDZCxDQUFDO1FBRUQsK0NBQStDO1FBQy9DLE1BQU1DLFFBQVEsSUFBSSxDQUFDekMsSUFBSSxDQUFDRCxLQUFLLEVBQUUsQ0FBQ3VDLEtBQUtwQyxHQUFHLENBQUMsQ0FBQ29DLEtBQUt1QyxHQUFHLENBQUM7UUFDbkQsSUFBSSxDQUFDcEMsU0FBU0EsTUFBTXBDLEtBQUssS0FBTSxLQUFJLENBQUM2QyxnQkFBZ0IsT0FBTyxVQUFVLE1BQU0sR0FBRyxHQUFHO1lBQy9FLE9BQU8sS0FBSztRQUNkLENBQUM7UUFFRCxzQ0FBc0M7UUFDdEMsSUFBSTtZQUNGLE1BQU1iLE9BQU8sSUFBSSxDQUFDckMsSUFBSSxDQUFDcUMsSUFBSSxDQUFDO2dCQUMxQkMsTUFBTSxJQUFJLENBQUN2QixnQkFBZ0IsQ0FBQ3VCO2dCQUM1QkUsSUFBSSxJQUFJLENBQUN6QixnQkFBZ0IsQ0FBQ3lCO2dCQUMxQkksV0FBVztZQUNiO1lBRUEsSUFBSVAsTUFBTTtnQkFDUixtREFBbUQ7Z0JBQ25ELElBQUksQ0FBQ3JDLElBQUksQ0FBQ3VELElBQUk7Z0JBQ2QsT0FBTyxJQUFJO1lBQ2IsQ0FBQztRQUNILEVBQUUsT0FBTzVDLEdBQUc7UUFDViwyQkFBMkI7UUFDN0I7UUFFQSxPQUFPLEtBQUs7SUFDZDtJQUVBOzs7OztHQUtDLEdBQ0R5RSxnQkFBZ0J0RSxRQUF1QixFQUFXO1FBQ2hELE9BQU9BLFNBQVNaLEdBQUcsSUFBSSxLQUFLWSxTQUFTWixHQUFHLEdBQUcsS0FDcENZLFNBQVMrRCxHQUFHLElBQUksS0FBSy9ELFNBQVMrRCxHQUFHLEdBQUc7SUFDN0M7SUFFQSxhQUFhO0lBQ2I7Ozs7R0FJQyxHQUNEUSxRQUFjO1FBQ1osSUFBSSxDQUFDckYsSUFBSSxDQUFDcUYsS0FBSztRQUNmLElBQUksQ0FBQ25FLGFBQWEsQ0FBQ29FLEtBQUs7UUFDeEIsSUFBSSxDQUFDNUUsU0FBUyxDQUFDO1lBQ2JOLE1BQU07WUFDTkcsS0FBSyxJQUFJLENBQUNELE1BQU07UUFDbEI7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRGlGLFFBQXFCO1FBQ25CLE1BQU1DLGVBQWUsSUFBSTNGLGdCQUFnQixJQUFJLENBQUMrRCxPQUFPO1FBQ3JENEIsYUFBYWhGLE1BQU0sQ0FBQyxJQUFJLENBQUNGLE1BQU07UUFDL0IsT0FBT2tGO0lBQ1Q7SUFFQSxnQ0FBZ0M7SUFDdEJ6RSxpQkFBaUJELFFBQXVCLEVBQVU7UUFDMUQsTUFBTTJFLE9BQU9DLE9BQU9DLFlBQVksQ0FBQyxJQUFJQyxVQUFVLENBQUMsS0FBSzlFLFNBQVMrRCxHQUFHO1FBQ2pFLE1BQU1nQixPQUFPLElBQUkvRSxTQUFTWixHQUFHO1FBQzdCLE9BQU8sR0FBVTJGLE9BQVBKLE1BQVksT0FBTEk7SUFDbkI7SUFFVXRELGlCQUFpQnBDLE1BQWMsRUFBaUI7UUFDeEQsTUFBTTBFLE1BQU0xRSxPQUFPeUYsVUFBVSxDQUFDLEtBQUssSUFBSUEsVUFBVSxDQUFDO1FBQ2xELE1BQU0xRixNQUFNLElBQUk0RixTQUFTM0YsTUFBTSxDQUFDLEVBQUU7UUFDbEMsT0FBTztZQUFFRDtZQUFLMkU7UUFBSTtJQUNwQjtJQUVVNUIsU0FBUzVDLEtBQXdCLEVBQWlCO1FBQzFELE1BQU1OLFFBQVEsSUFBSSxDQUFDQyxJQUFJLENBQUNELEtBQUs7UUFDN0IsSUFBSyxJQUFJRyxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztZQUNoQyxJQUFLLElBQUkyRSxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztnQkFDaEMsTUFBTXBDLFFBQVExQyxLQUFLLENBQUNHLElBQUksQ0FBQzJFLElBQUk7Z0JBQzdCLElBQUlwQyxTQUNBQSxNQUFNckMsSUFBSSxLQUFLLE9BQ2ZxQyxNQUFNcEMsS0FBSyxLQUFNQSxDQUFBQSxVQUFVLFVBQVUsTUFBTSxHQUFHLEdBQUc7b0JBQ25ELE9BQU87d0JBQUVIO3dCQUFLMkU7b0JBQUk7Z0JBQ3BCLENBQUM7WUFDSDtRQUNGO1FBQ0EsTUFBTSxJQUFJakUsTUFBTSxrQkFBa0I7SUFDcEM7SUFFQTs7OztHQUlDLEdBQ0QsY0FBbUM7UUFDakMsT0FBTyxJQUFJLENBQUN1QixPQUFPLENBQUM0RCxXQUFXO0lBQ2pDO0lBRUE7Ozs7R0FJQyxHQUNELFVBQW9CQyxLQUFrQixFQUFRO1FBQzVDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsZ0JBQWdCRjtRQUN2QyxJQUFJLENBQUM3RCxPQUFPLENBQUNnRSxXQUFXLENBQUNIO0lBQzNCO0lBRUEsdUJBQXVCO0lBQ2Y1QixtQkFBMkI7UUFDakMsTUFBTWdDLGNBQWM7WUFDbEIxQixHQUFHO1lBQ0hDLEdBQUc7WUFDSEMsR0FBRztZQUNIeUIsR0FBRztZQUNIQyxHQUFHO1lBQ0hDLEdBQUc7UUFDTDtRQUVBLElBQUlwQyxRQUFRO1FBQ1osTUFBTXBFLFFBQVEsSUFBSSxDQUFDQyxJQUFJLENBQUNELEtBQUs7UUFFN0IsSUFBSyxJQUFJRyxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztZQUNoQyxJQUFLLElBQUkyRSxNQUFNLEdBQUdBLE1BQU0sR0FBR0EsTUFBTztnQkFDaEMsTUFBTXBDLFFBQVExQyxLQUFLLENBQUNHLElBQUksQ0FBQzJFLElBQUk7Z0JBQzdCLElBQUlwQyxPQUFPO29CQUNULE1BQU0rRCxRQUFRSixXQUFXLENBQUMzRCxNQUFNckMsSUFBSSxDQUE2QjtvQkFDakUrRCxTQUFTMUIsTUFBTXBDLEtBQUssS0FBSyxNQUFNbUcsUUFBUSxDQUFDQSxLQUFLO2dCQUMvQyxDQUFDO1lBQ0g7UUFDRjtRQUVBLE9BQU9yQztJQUNUO0lBRVFHLG1CQUEyQjtRQUNqQyxNQUFNbUMsYUFBYSxJQUFJLENBQUN6RyxJQUFJLENBQUNvQixLQUFLLEdBQUdzRixNQUFNO1FBQzNDLGtEQUFrRDtRQUNsRCxNQUFNQyxXQUFXLElBQUlsSCwyQ0FBS0EsQ0FBQyxJQUFJLENBQUNPLElBQUksQ0FBQ08sR0FBRztRQUN4Q29HLFNBQVNsRyxJQUFJLENBQUMsSUFBSSxDQUFDVCxJQUFJLENBQUNPLEdBQUcsR0FBR3FHLE9BQU8sQ0FBQyxPQUFPO1FBQzdDLE1BQU1DLGFBQWFGLFNBQVN2RixLQUFLLEdBQUdzRixNQUFNO1FBRTFDLE9BQU9ELGFBQWFJO0lBQ3RCO0lBRVF0QyxxQkFBNkI7UUFDbkMsa0RBQWtEO1FBQ2xELE9BQU87SUFDVDtJQUVRQyx3QkFBZ0M7UUFDdEMsb0RBQW9EO1FBQ3BELE9BQU87SUFDVDtJQUVBLGlCQUFpQjtJQUNqQnNDLEdBQUdDLFNBQWlCLEVBQUVDLE9BQXFDLEVBQVE7UUFDakUsSUFBSSxDQUFDZixZQUFZLENBQUNhLEVBQUUsQ0FBQ0MsV0FBV0M7SUFDbEM7SUFFQUMsSUFBSUYsU0FBaUIsRUFBRUMsT0FBcUMsRUFBUTtRQUNsRSxJQUFJLENBQUNmLFlBQVksQ0FBQ2dCLEdBQUcsQ0FBQ0YsV0FBV0M7SUFDbkM7SUEzaUJBOzs7Ozs7R0FNQyxHQUNERSxZQUFZdEQsVUFBeUIsQ0FBQyxDQUFDLENBQUU7UUFDdkMsSUFBSSxDQUFDNUQsSUFBSSxHQUFHLElBQUlQLDJDQUFLQSxDQUFDbUUsUUFBUXVELGFBQWEsSUFBSXhILHdEQUFXQTtRQUMxRCxJQUFJLENBQUNpRSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDcUMsWUFBWSxHQUFHLElBQUlyRyxnREFBWUE7UUFDcEMsSUFBSSxDQUFDc0IsYUFBYSxHQUFHLElBQUlrRztRQUN6QixJQUFJLENBQUNqRixPQUFPLEdBQUcsSUFBSXpDLHdFQUFlQTtJQUNwQztBQStoQkYsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2hhcmVkL2VuZ2luZS9DaGVzc0VuZ2luZUJhc2UudHM/ZjI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzcyB9IGZyb20gJ2NoZXNzLmpzJztcbmltcG9ydCB7IFxuICBDaGVzc0VuZ2luZSwgXG4gIEVuZ2luZU9wdGlvbnMsIFxuICBFbmdpbmVBbmFseXNpcyxcbiAgRW5naW5lRXZlbnQsXG4gIEhlYWx0aFN0YXR1c1xufSBmcm9tICcuLi90eXBlcy9lbmdpbmUnO1xuaW1wb3J0IHsgXG4gIENoZXNzUG9zaXRpb24sIFxuICBDaGVzc1BpZWNlLCBcbiAgQ2hlc3NNb3ZlLFxuICBQaWVjZVR5cGVcbn0gZnJvbSAnLi4vdHlwZXMvY2hlc3MnO1xuaW1wb3J0IHsgQXJxdWltYXhNb25pdG9yIH0gZnJvbSAnLi9tb25pdG9yaW5nL0FycXVpbWF4TW9uaXRvcic7XG5pbXBvcnQgeyBJTklUSUFMX0ZFTiB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogSW1wbGVtZW50YcOnw6NvIGJhc2UgZG8gbW90b3IgZGUgeGFkcmV6LlxuICogXG4gKiBFc3RhIGNsYXNzZSBmb3JuZWNlIGEgZnVuY2lvbmFsaWRhZGUgY2VudHJhbCBwYXJhIHVtIG1vdG9yIGRlIHhhZHJleixcbiAqIGluY2x1aW5kbyBnZXJlbmNpYW1lbnRvIGRlIGVzdGFkbyBkbyBqb2dvLCB2YWxpZGHDp8OjbyBkZSBtb3ZpbWVudG9zLFxuICogYXZhbGlhw6fDo28gZGUgcG9zacOnw6NvIGUgZXZlbnRvcyBkbyBqb2dvLlxuICogXG4gKiBAaW1wbGVtZW50cyB7Q2hlc3NFbmdpbmV9XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVzc0VuZ2luZUJhc2UgaW1wbGVtZW50cyBDaGVzc0VuZ2luZSB7XG4gIC8qKiBJbnN0w6JuY2lhIGRvIGNoZXNzLmpzIHF1ZSBnZXJlbmNpYSBhcyByZWdyYXMgZSBlc3RhZG8gZG8gam9nbyAqL1xuICBwcm90ZWN0ZWQgZ2FtZTogQ2hlc3M7XG5cbiAgLyoqIE9ww6fDtWVzIGRlIGNvbmZpZ3VyYcOnw6NvIGRvIG1vdG9yICovXG4gIHByb3RlY3RlZCBvcHRpb25zOiBFbmdpbmVPcHRpb25zO1xuXG4gIC8qKiBFbWlzc29yIGRlIGV2ZW50b3MgcGFyYSBub3RpZmljYXIgbXVkYW7Dp2FzIG5vIGVzdGFkbyBkbyBqb2dvICovXG4gIHByb3RlY3RlZCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuICAvKiogQ2FjaGUgZGUgYW7DoWxpc2VzIGRlIHBvc2nDp8OjbyBwYXJhIG90aW1pemHDp8OjbyAqL1xuICBwcm90ZWN0ZWQgcG9zaXRpb25DYWNoZTogTWFwPHN0cmluZywgRW5naW5lQW5hbHlzaXM+O1xuXG4gIHByaXZhdGUgbW9uaXRvcjogQXJxdWltYXhNb25pdG9yO1xuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBub3ZhIGluc3TDom5jaWEgZG8gbW90b3IgZGUgeGFkcmV6LlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcMOnw7VlcyBkZSBjb25maWd1cmHDp8OjbyBkbyBtb3RvclxuICAgKiBAcGFyYW0gb3B0aW9ucy5zdGFydFBvc2l0aW9uIC0gUG9zacOnw6NvIGluaWNpYWwgZW0gbm90YcOnw6NvIEZFTiAob3BjaW9uYWwpXG4gICAqIEBwYXJhbSBvcHRpb25zLmV2YWx1YXRpb25QYXJhbWV0ZXJzIC0gUGFyw6JtZXRyb3MgcGFyYSBhdmFsaWHDp8OjbyBkZSBwb3Npw6fDo28gKG9wY2lvbmFsKVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRW5naW5lT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5nYW1lID0gbmV3IENoZXNzKG9wdGlvbnMuc3RhcnRQb3NpdGlvbiB8fCBJTklUSUFMX0ZFTik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnBvc2l0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tb25pdG9yID0gbmV3IEFycXVpbWF4TW9uaXRvcigpO1xuICB9XG5cbiAgLy8gRXN0YWRvIGRvIGpvZ29cbiAgLyoqXG4gICAqIE9idMOpbSBhIHJlcHJlc2VudGHDp8OjbyBhdHVhbCBkbyB0YWJ1bGVpcm8uXG4gICAqIFxuICAgKiBAcmV0dXJucyBVbWEgbWF0cml6IDh4OCByZXByZXNlbnRhbmRvIG8gdGFidWxlaXJvLCBvbmRlIGNhZGEgZWxlbWVudG9cbiAgICogw6kgdW1hIHBlw6dhIGRlIHhhZHJleiBvdSBudWxsIHBhcmEgY2FzYXMgdmF6aWFzLlxuICAgKi9cbiAgZ2V0Qm9hcmQoKTogQ2hlc3NQaWVjZVtdW10ge1xuICAgIGNvbnN0IGJvYXJkID0gdGhpcy5nYW1lLmJvYXJkKCk7XG4gICAgcmV0dXJuIGJvYXJkLm1hcChyb3cgPT4gXG4gICAgICByb3cubWFwKHNxdWFyZSA9PiBcbiAgICAgICAgc3F1YXJlID8ge1xuICAgICAgICAgIHR5cGU6IHNxdWFyZS50eXBlIGFzIFBpZWNlVHlwZSxcbiAgICAgICAgICBjb2xvcjogc3F1YXJlLmNvbG9yID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgICB9IDogbnVsbFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIGEgcG9zacOnw6NvIGF0dWFsIGVtIG5vdGHDp8OjbyBGRU4uXG4gICAqIFxuICAgKiBAcmV0dXJucyBTdHJpbmcgRkVOIHJlcHJlc2VudGFuZG8gbyBlc3RhZG8gYXR1YWwgZG8gam9nb1xuICAgKi9cbiAgZ2V0RkVOKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5mZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgdW1hIG5vdmEgcG9zacOnw6NvIHBhcmEgbyBqb2dvIHVzYW5kbyBub3Rhw6fDo28gRkVOLlxuICAgKiBcbiAgICogQHBhcmFtIGZlbiAtIFN0cmluZyBGRU4gcmVwcmVzZW50YW5kbyBhIG5vdmEgcG9zacOnw6NvXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBTZSBhIHN0cmluZyBGRU4gZm9yIGludsOhbGlkYVxuICAgKiBAZW1pdHMge1BPU0lUSU9OX0NIQU5HRUR9IFF1YW5kbyBhIHBvc2nDp8OjbyDDqSBhbHRlcmFkYSBjb20gc3VjZXNzb1xuICAgKi9cbiAgc2V0RkVOKGZlbjogc3RyaW5nKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5hIG5vdmEgdmVyc8OjbyBkbyBjaGVzcy5qcywgbG9hZCgpIGrDoSB2YWxpZGEgbyBGRU5cbiAgICAgIHRoaXMuZ2FtZS5sb2FkKGZlbik7XG4gICAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsIFxuICAgICAgICBmZW4gXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRkVOIHN0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmltZW50b3NcbiAgLyoqXG4gICAqIE9idMOpbSB0b2RvcyBvcyBtb3ZpbWVudG9zIGxlZ2FpcyBwb3Nzw612ZWlzIHBhcmEgdW1hIHBlw6dhIGVtIHVtYSBkZXRlcm1pbmFkYSBwb3Npw6fDo28uXG4gICAqIFxuICAgKiBAcGFyYW0gcG9zaXRpb24gLSBQb3Npw6fDo28gZGEgcGXDp2Egbm8gdGFidWxlaXJvXG4gICAqIEByZXR1cm5zIExpc3RhIGRlIG1vdmltZW50b3MgbGVnYWlzIHBvc3PDrXZlaXNcbiAgICovXG4gIGdldFBvc3NpYmxlTW92ZXMocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBDaGVzc01vdmVbXSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMucG9zaXRpb25Ub1NxdWFyZShwb3NpdGlvbik7XG4gICAgICBjb25zdCBmZW4gPSB0aGlzLmdldEZFTigpO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtmZW59OiR7c3F1YXJlfWA7XG4gICAgICBjb25zdCBjYWNoZUhpdCA9IHRoaXMucG9zaXRpb25DYWNoZS5oYXMoY2FjaGVLZXkpO1xuICAgICAgXG4gICAgICBsZXQgbW92ZXM7XG4gICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBvc2l0aW9uQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgbW92ZXMgPSBjYWNoZSEuYmVzdExpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3ZlcyA9IHRoaXMuZ2FtZS5tb3Zlcyh7IFxuICAgICAgICAgIHNxdWFyZSxcbiAgICAgICAgICB2ZXJib3NlOiB0cnVlIFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICB0aGlzLnBvc2l0aW9uQ2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgZXZhbHVhdGlvbjogMCxcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBiZXN0TGluZTogbW92ZXMsXG4gICAgICAgICAgdGhyZWF0czogW10sXG4gICAgICAgICAgcG9zaXRpb25hbEZlYXR1cmVzOiB7XG4gICAgICAgICAgICBwYXduU3RydWN0dXJlOiAwLFxuICAgICAgICAgICAga2luZ1NhZmV0eTogMCxcbiAgICAgICAgICAgIG1vYmlsaXR5OiAwLFxuICAgICAgICAgICAgY2VudGVyQ29udHJvbDogMCxcbiAgICAgICAgICAgIHBpZWNlQWN0aXZpdHk6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLm1vbml0b3IucmVjb3JkQ2FjaGVBY2Nlc3MoY2FjaGVIaXQpO1xuXG4gICAgICByZXR1cm4gbW92ZXMubWFwKG1vdmUgPT4gKHtcbiAgICAgICAgZnJvbTogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUuZnJvbSksXG4gICAgICAgIHRvOiB0aGlzLnNxdWFyZVRvUG9zaXRpb24obW92ZS50byksXG4gICAgICAgIHBpZWNlOiB7XG4gICAgICAgICAgdHlwZTogbW92ZS5waWVjZSBhcyBQaWVjZVR5cGUsXG4gICAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmVkOiBtb3ZlLmNhcHR1cmVkID8ge1xuICAgICAgICAgIHR5cGU6IG1vdmUuY2FwdHVyZWQgYXMgUGllY2VUeXBlLFxuICAgICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnYmxhY2snIDogJ3doaXRlJ1xuICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICBwcm9tb3Rpb246IG1vdmUucHJvbW90aW9uIGFzIFBpZWNlVHlwZSB8IHVuZGVmaW5lZCxcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBTZSBob3V2ZXIgZXJybyBuYSBnZXJhw6fDo28gZGUgbW92aW1lbnRvcywgcmV0b3JuYSBsaXN0YSB2YXppYVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRhIHVtIG1vdmltZW50byBubyB0YWJ1bGVpcm8uXG4gICAqIFxuICAgKiBAcGFyYW0gZnJvbSAtIFBvc2nDp8OjbyBpbmljaWFsIGRhIHBlw6dhXG4gICAqIEBwYXJhbSB0byAtIFBvc2nDp8OjbyBmaW5hbCBkYSBwZcOnYVxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gbW92aW1lbnRvIGZvaSBleGVjdXRhZG8gY29tIHN1Y2Vzc28sIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKiBAZW1pdHMge01PVkVfTUFERX0gUXVhbmRvIHVtIG1vdmltZW50byDDqSByZWFsaXphZG8gY29tIHN1Y2Vzc29cbiAgICogQGVtaXRzIHtDSEVDS30gUXVhbmRvIG8gbW92aW1lbnRvIHJlc3VsdGEgZW0geGVxdWVcbiAgICogQGVtaXRzIHtHQU1FX09WRVJ9IFF1YW5kbyBvIG1vdmltZW50byByZXN1bHRhIGVtIGZpbSBkZSBqb2dvXG4gICAqL1xuICBtYWtlTW92ZShmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtb3ZlID0gdGhpcy5nYW1lLm1vdmUoe1xuICAgICAgICBmcm9tOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUoZnJvbSksXG4gICAgICAgIHRvOiB0aGlzLnBvc2l0aW9uVG9TcXVhcmUodG8pLFxuICAgICAgICBwcm9tb3Rpb246ICdxJyAvLyBBdXRvLXByb21vdmUgcGFyYSByYWluaGEgcG9yIHBhZHLDo29cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobW92ZSkge1xuICAgICAgICBjb25zdCBjaGVzc01vdmU6IENoZXNzTW92ZSA9IHtcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBpZWNlOiB7XG4gICAgICAgICAgICB0eXBlOiBtb3ZlLnBpZWNlLFxuICAgICAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlZDogbW92ZS5jYXB0dXJlZCA/IHtcbiAgICAgICAgICAgIHR5cGU6IG1vdmUuY2FwdHVyZWQsXG4gICAgICAgICAgICBjb2xvcjogbW92ZS5jb2xvciA9PT0gJ3cnID8gJ2JsYWNrJyA6ICd3aGl0ZSdcbiAgICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHByb21vdGlvbjogbW92ZS5wcm9tb3Rpb24sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoeyB0eXBlOiAnTU9WRV9NQURFJywgbW92ZTogY2hlc3NNb3ZlIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KHsgXG4gICAgICAgICAgICB0eXBlOiAnQ0hFQ0snLFxuICAgICAgICAgICAga2luZ1Bvc2l0aW9uOiB0aGlzLmZpbmRLaW5nKHRoaXMuZ2V0Q3VycmVudFBsYXllcigpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNHYW1lT3ZlcigpKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9ICdkcmF3JztcbiAgICAgICAgICBpZiAodGhpcy5pc0NoZWNrbWF0ZSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldEN1cnJlbnRQbGF5ZXIoKSA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXRFdmVudCh7IHR5cGU6ICdHQU1FX09WRVInLCByZXN1bHQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2ZheiBvIMO6bHRpbW8gbW92aW1lbnRvIHJlYWxpemFkby5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgaGF2aWEgdW0gbW92aW1lbnRvIHBhcmEgZGVzZmF6ZXIsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKiBAZW1pdHMge1BPU0lUSU9OX0NIQU5HRUR9IFF1YW5kbyBvIG1vdmltZW50byDDqSBkZXNmZWl0byBjb20gc3VjZXNzb1xuICAgKi9cbiAgdW5kb0xhc3RNb3ZlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG1vdmUgPSB0aGlzLmdhbWUudW5kbygpO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICB0aGlzLmVtaXRFdmVudCh7IFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsXG4gICAgICAgIGZlbjogdGhpcy5nZXRGRU4oKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXN0YWRvIGRvIGpvZ29cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIG8gam9nYWRvciBhdHVhbCBlc3TDoSBlbSB4ZXF1ZS5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBqb2dhZG9yIGF0dWFsIGVzdMOhIGVtIHhlcXVlLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzQ2hlY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0NoZWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2Egc2UgbyBqb2dhZG9yIGF0dWFsIGVzdMOhIGVtIHhlcXVlLW1hdGUuXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gam9nYWRvciBhdHVhbCBlc3TDoSBlbSB4ZXF1ZS1tYXRlLCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzQ2hlY2ttYXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdhbWUuaXNDaGVja21hdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIGpvZ28gZXN0w6EgZW1wYXRhZG8uXG4gICAqIFxuICAgKiBAcmV0dXJucyB0cnVlIHNlIG8gam9nbyBlc3TDoSBlbXBhdGFkbywgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc0RyYXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0RyYXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmljYSBzZSBvIGpvZ28gdGVybWlub3UgKHhlcXVlLW1hdGUgb3UgZW1wYXRlKS5cbiAgICogXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBqb2dvIHRlcm1pbm91LCBmYWxzZSBjYXNvIGNvbnRyw6FyaW9cbiAgICovXG4gIGlzR2FtZU92ZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5pc0dhbWVPdmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG8gam9nYWRvciBhdHVhbC5cbiAgICogXG4gICAqIEByZXR1cm5zICd3aGl0ZScgcGFyYSBhcyBicmFuY2FzLCAnYmxhY2snIHBhcmEgYXMgcHJldGFzXG4gICAqL1xuICBnZXRDdXJyZW50UGxheWVyKCk6ICd3aGl0ZScgfCAnYmxhY2snIHtcbiAgICBjb25zdCB0dXJuID0gdGhpcy5nYW1lLnR1cm4oKTtcbiAgICByZXR1cm4gdHVybiA9PT0gJ3cnID8gJ3doaXRlJyA6ICdibGFjayc7XG4gIH1cblxuICAvLyBBdmFsaWHDp8OjbyBlIGFuw6FsaXNlXG4gIC8qKlxuICAgKiBBdmFsaWEgYSBwb3Npw6fDo28gYXR1YWwgZG8gam9nby5cbiAgICogXG4gICAqIEVzdGEgZnVuw6fDo28gY29uc2lkZXJhIGRpdmVyc29zIGZhdG9yZXMgcGFyYSBhdmFsaWFyIGEgcG9zacOnw6NvOlxuICAgKiAtIE1hdGVyaWFsOiBWYWxvciBkYXMgcGXDp2FzIHByZXNlbnRlcyBubyB0YWJ1bGVpcm9cbiAgICogLSBQb3Npw6fDo286IFF1YWxpZGFkZSBkbyBwb3NpY2lvbmFtZW50byBkYXMgcGXDp2FzXG4gICAqIC0gTW9iaWxpZGFkZTogUXVhbnRpZGFkZSBkZSBtb3ZpbWVudG9zIGRpc3BvbsOtdmVpc1xuICAgKiAtIFNlZ3VyYW7Dp2EgZG8gUmVpOiBBdmFsaWHDp8OjbyBkYSBwcm90ZcOnw6NvIGRvIHJlaVxuICAgKiAtIEVzdHJ1dHVyYSBkZSBQZcO1ZXM6IFF1YWxpZGFkZSBkYSBlc3RydXR1cmEgZGUgcGXDtWVzXG4gICAqIFxuICAgKiBAcmV0dXJucyBVbSBuw7ptZXJvIHF1ZSByZXByZXNlbnRhIGEgYXZhbGlhw6fDo28gZGEgcG9zacOnw6NvLlxuICAgKiBWYWxvcmVzIHBvc2l0aXZvcyBmYXZvcmVjZW0gYXMgYnJhbmNhcywgbmVnYXRpdm9zIGZhdm9yZWNlbSBhcyBwcmV0YXMuXG4gICAqL1xuICBldmFsdWF0ZVBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgLy8gSW1wbGVtZW50YcOnw6NvIGLDoXNpY2EgZGUgYXZhbGlhw6fDo29cbiAgICBjb25zdCB3ZWlnaHRzID0gdGhpcy5vcHRpb25zLmV2YWx1YXRpb25QYXJhbWV0ZXJzIHx8IHtcbiAgICAgIG1hdGVyaWFsV2VpZ2h0OiAxLFxuICAgICAgcG9zaXRpb25XZWlnaHQ6IDAuMSxcbiAgICAgIG1vYmlsaXR5V2VpZ2h0OiAwLjEsXG4gICAgICBraW5nU2FmZXR5V2VpZ2h0OiAwLjIsXG4gICAgICBwYXduU3RydWN0dXJlV2VpZ2h0OiAwLjFcbiAgICB9O1xuXG4gICAgbGV0IHNjb3JlID0gMDtcblxuICAgIC8vIE1hdGVyaWFsXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZU1hdGVyaWFsKCkgKiB3ZWlnaHRzLm1hdGVyaWFsV2VpZ2h0O1xuXG4gICAgLy8gUG9zacOnw6NvIGRhcyBwZcOnYXNcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlUGllY2VQb3NpdGlvbnMoKSAqIHdlaWdodHMucG9zaXRpb25XZWlnaHQ7XG5cbiAgICAvLyBNb2JpbGlkYWRlXG4gICAgc2NvcmUgKz0gdGhpcy5ldmFsdWF0ZU1vYmlsaXR5KCkgKiB3ZWlnaHRzLm1vYmlsaXR5V2VpZ2h0O1xuXG4gICAgLy8gU2VndXJhbsOnYSBkbyByZWlcbiAgICBzY29yZSArPSB0aGlzLmV2YWx1YXRlS2luZ1NhZmV0eSgpICogd2VpZ2h0cy5raW5nU2FmZXR5V2VpZ2h0O1xuXG4gICAgLy8gRXN0cnV0dXJhIGRlIHBlw7Vlc1xuICAgIHNjb3JlICs9IHRoaXMuZXZhbHVhdGVQYXduU3RydWN0dXJlKCkgKiB3ZWlnaHRzLnBhd25TdHJ1Y3R1cmVXZWlnaHQ7XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlUGllY2VQb3NpdGlvbnMoKTogbnVtYmVyIHtcbiAgICAvLyBTaW1wbGUgcGllY2Utc3F1YXJlIHRhYmxlcyBldmFsdWF0aW9uXG4gICAgY29uc3QgcGllY2VTcXVhcmVWYWx1ZXMgPSB7XG4gICAgICBwOiBbIC8vIFBhd25zXG4gICAgICAgIFswLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLCAgMF0sXG4gICAgICAgIFs1MCwgNTAsIDUwLCA1MCwgNTAsIDUwLCA1MCwgNTBdLFxuICAgICAgICBbMTAsIDEwLCAyMCwgMzAsIDMwLCAyMCwgMTAsIDEwXSxcbiAgICAgICAgWzUsICA1LCAxMCwgMjUsIDI1LCAxMCwgIDUsICA1XSxcbiAgICAgICAgWzAsICAwLCAgMCwgMjAsIDIwLCAgMCwgIDAsICAwXSxcbiAgICAgICAgWzUsIC01LC0xMCwgIDAsICAwLC0xMCwgLTUsICA1XSxcbiAgICAgICAgWzUsIDEwLCAxMCwtMjAsLTIwLCAxMCwgMTAsICA1XSxcbiAgICAgICAgWzAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsICAwXVxuICAgICAgXSxcbiAgICAgIG46IFsgLy8gS25pZ2h0c1xuICAgICAgICBbLTUwLC00MCwtMzAsLTMwLC0zMCwtMzAsLTQwLC01MF0sXG4gICAgICAgIFstNDAsLTIwLCAgMCwgIDAsICAwLCAgMCwtMjAsLTQwXSxcbiAgICAgICAgWy0zMCwgIDAsIDEwLCAxNSwgMTUsIDEwLCAgMCwtMzBdLFxuICAgICAgICBbLTMwLCAgNSwgMTUsIDIwLCAyMCwgMTUsICA1LC0zMF0sXG4gICAgICAgIFstMzAsICAwLCAxNSwgMjAsIDIwLCAxNSwgIDAsLTMwXSxcbiAgICAgICAgWy0zMCwgIDUsIDEwLCAxNSwgMTUsIDEwLCAgNSwtMzBdLFxuICAgICAgICBbLTQwLC0yMCwgIDAsICA1LCAgNSwgIDAsLTIwLC00MF0sXG4gICAgICAgIFstNTAsLTQwLC0zMCwtMzAsLTMwLC0zMCwtNDAsLTUwXVxuICAgICAgXSxcbiAgICAgIGI6IFsgLy8gQmlzaG9wc1xuICAgICAgICBbLTIwLC0xMCwtMTAsLTEwLC0xMCwtMTAsLTEwLC0yMF0sXG4gICAgICAgIFstMTAsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsLTEwXSxcbiAgICAgICAgWy0xMCwgIDAsICA1LCAxMCwgMTAsICA1LCAgMCwtMTBdLFxuICAgICAgICBbLTEwLCAgNSwgIDUsIDEwLCAxMCwgIDUsICA1LC0xMF0sXG4gICAgICAgIFstMTAsICAwLCAxMCwgMTAsIDEwLCAxMCwgIDAsLTEwXSxcbiAgICAgICAgWy0xMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwtMTBdLFxuICAgICAgICBbLTEwLCAgNSwgIDAsICAwLCAgMCwgIDAsICA1LC0xMF0sXG4gICAgICAgIFstMjAsLTEwLC0xMCwtMTAsLTEwLC0xMCwtMTAsLTIwXVxuICAgICAgXVxuICAgIH07XG5cbiAgICBsZXQgc2NvcmUgPSAwO1xuICAgIGNvbnN0IGJvYXJkID0gdGhpcy5nYW1lLmJvYXJkKCk7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgIGNvbnN0IHBpZWNlVGFibGUgPSBwaWVjZVNxdWFyZVZhbHVlc1twaWVjZS50eXBlIGFzIGtleW9mIHR5cGVvZiBwaWVjZVNxdWFyZVZhbHVlc107XG4gICAgICAgICAgaWYgKHBpZWNlVGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uVmFsdWUgPSBwaWVjZVRhYmxlW3BpZWNlLmNvbG9yID09PSAndycgPyByb3cgOiA3IC0gcm93XVtjb2xdO1xuICAgICAgICAgICAgc2NvcmUgKz0gcGllY2UuY29sb3IgPT09ICd3JyA/IHBvc2l0aW9uVmFsdWUgOiAtcG9zaXRpb25WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICAvKipcbiAgICogRW5jb250cmEgbyBtZWxob3IgbW92aW1lbnRvIHBvc3PDrXZlbCBwYXJhIG8gam9nYWRvciBhdHVhbC5cbiAgICogXG4gICAqIEBwYXJhbSBkZXB0aCAtIFByb2Z1bmRpZGFkZSBtw6F4aW1hIGRlIGJ1c2NhIG5hIMOhcnZvcmUgZGUgbW92aW1lbnRvc1xuICAgKiBAcmV0dXJucyBPIG1lbGhvciBtb3ZpbWVudG8gZW5jb250cmFkbywgb3UgbnVsbCBzZSBuZW5odW0gbW92aW1lbnRvIGZvciBwb3Nzw612ZWxcbiAgICogQHRvZG8gSW1wbGVtZW50YXIgYWxnb3JpdG1vIG1pbmltYXggY29tIHBvZGEgYWxwaGEtYmV0YVxuICAgKi9cbiAgZ2V0QmVzdE1vdmUoZGVwdGg6IG51bWJlcik6IENoZXNzTW92ZSB8IG51bGwge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGJ1c2NhIG1pbmltYXggY29tIHBvZGEgYWxwaGEtYmV0YVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idMOpbSBvIGhpc3TDs3JpY28gY29tcGxldG8gZGUgbW92aW1lbnRvcyBkbyBqb2dvLlxuICAgKiBcbiAgICogQHJldHVybnMgTGlzdGEgZGUgbW92aW1lbnRvcyByZWFsaXphZG9zIGRlc2RlIG8gaW7DrWNpbyBkbyBqb2dvXG4gICAqL1xuICBnZXRHYW1lSGlzdG9yeSgpOiBDaGVzc01vdmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2FtZS5oaXN0b3J5KHsgdmVyYm9zZTogdHJ1ZSB9KS5tYXAobW92ZSA9PiAoe1xuICAgICAgZnJvbTogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUuZnJvbSksXG4gICAgICB0bzogdGhpcy5zcXVhcmVUb1Bvc2l0aW9uKG1vdmUudG8pLFxuICAgICAgcGllY2U6IHtcbiAgICAgICAgdHlwZTogbW92ZS5waWVjZSxcbiAgICAgICAgY29sb3I6IG1vdmUuY29sb3IgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snXG4gICAgICB9LFxuICAgICAgY2FwdHVyZWQ6IG1vdmUuY2FwdHVyZWQgPyB7XG4gICAgICAgIHR5cGU6IG1vdmUuY2FwdHVyZWQsXG4gICAgICAgIGNvbG9yOiBtb3ZlLmNvbG9yID09PSAndycgPyAnYmxhY2snIDogJ3doaXRlJ1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHByb21vdGlvbjogbW92ZS5wcm9tb3Rpb24sXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gVmFsaWRhw6fDo29cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIHVtIG1vdmltZW50byDDqSB2w6FsaWRvIHNlbSBleGVjdXTDoS1sby5cbiAgICogXG4gICAqIEBwYXJhbSBmcm9tIC0gUG9zacOnw6NvIGluaWNpYWwgZGEgcGXDp2FcbiAgICogQHBhcmFtIHRvIC0gUG9zacOnw6NvIGZpbmFsIGRhIHBlw6dhXG4gICAqIEByZXR1cm5zIHRydWUgc2UgbyBtb3ZpbWVudG8gw6kgbGVnYWwsIGZhbHNlIGNhc28gY29udHLDoXJpb1xuICAgKi9cbiAgaXNWYWxpZE1vdmUoZnJvbTogQ2hlc3NQb3NpdGlvbiwgdG86IENoZXNzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgICAvLyBWYWxpZGHDp8OjbyBiw6FzaWNhIGRlIHBvc2nDp8Ojb1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUG9zaXRpb24oZnJvbSkgfHwgIXRoaXMuaXNWYWxpZFBvc2l0aW9uKHRvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmaWNhIHNlIGEgcGXDp2EgcGVydGVuY2UgYW8gam9nYWRvciBhdHVhbFxuICAgIGNvbnN0IHBpZWNlID0gdGhpcy5nYW1lLmJvYXJkKClbZnJvbS5yb3ddW2Zyb20uY29sXTtcbiAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLmNvbG9yICE9PSAodGhpcy5nZXRDdXJyZW50UGxheWVyKCkgPT09ICd3aGl0ZScgPyAndycgOiAnYicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGVudGEgZmF6ZXIgbyBtb3ZpbWVudG8gbm8gY2hlc3MuanNcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW92ZSA9IHRoaXMuZ2FtZS5tb3ZlKHtcbiAgICAgICAgZnJvbTogdGhpcy5wb3NpdGlvblRvU3F1YXJlKGZyb20pLFxuICAgICAgICB0bzogdGhpcy5wb3NpdGlvblRvU3F1YXJlKHRvKSxcbiAgICAgICAgcHJvbW90aW9uOiAncSdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobW92ZSkge1xuICAgICAgICAvLyBEZXNmYXogbyBtb3ZpbWVudG8gcGFyYSBtYW50ZXIgbyBlc3RhZG8gb3JpZ2luYWxcbiAgICAgICAgdGhpcy5nYW1lLnVuZG8oKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWdub3JhIGVycm9zIGRvIGNoZXNzLmpzXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWNhIHNlIHVtYSBwb3Npw6fDo28gZXN0w6EgZGVudHJvIGRvcyBsaW1pdGVzIGRvIHRhYnVsZWlyby5cbiAgICogXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFBvc2nDp8OjbyBhIHNlciB2ZXJpZmljYWRhXG4gICAqIEByZXR1cm5zIHRydWUgc2UgYSBwb3Npw6fDo28gw6kgdsOhbGlkYSwgZmFsc2UgY2FzbyBjb250csOhcmlvXG4gICAqL1xuICBpc1ZhbGlkUG9zaXRpb24ocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgICByZXR1cm4gcG9zaXRpb24ucm93ID49IDAgJiYgcG9zaXRpb24ucm93IDwgOCAmJlxuICAgICAgICAgICBwb3NpdGlvbi5jb2wgPj0gMCAmJiBwb3NpdGlvbi5jb2wgPCA4O1xuICB9XG5cbiAgLy8gVXRpbGlkYWRlc1xuICAvKipcbiAgICogUmVpbmljaWEgbyBqb2dvIHBhcmEgYSBwb3Npw6fDo28gaW5pY2lhbC5cbiAgICogXG4gICAqIEBlbWl0cyB7UE9TSVRJT05fQ0hBTkdFRH0gUXVhbmRvIG8gdGFidWxlaXJvIMOpIHJlaW5pY2lhZG9cbiAgICovXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuZ2FtZS5yZXNldCgpO1xuICAgIHRoaXMucG9zaXRpb25DYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuZW1pdEV2ZW50KHsgXG4gICAgICB0eXBlOiAnUE9TSVRJT05fQ0hBTkdFRCcsXG4gICAgICBmZW46IHRoaXMuZ2V0RkVOKClcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmlhIHVtYSBjw7NwaWEgaW5kZXBlbmRlbnRlIGRvIG1vdG9yIGRlIHhhZHJleiBhdHVhbC5cbiAgICogXG4gICAqIEByZXR1cm5zIFVtYSBub3ZhIGluc3TDom5jaWEgZG8gbW90b3IgY29tIG8gbWVzbW8gZXN0YWRvIGF0dWFsXG4gICAqL1xuICBjbG9uZSgpOiBDaGVzc0VuZ2luZSB7XG4gICAgY29uc3QgY2xvbmVkRW5naW5lID0gbmV3IENoZXNzRW5naW5lQmFzZSh0aGlzLm9wdGlvbnMpO1xuICAgIGNsb25lZEVuZ2luZS5zZXRGRU4odGhpcy5nZXRGRU4oKSk7XG4gICAgcmV0dXJuIGNsb25lZEVuZ2luZTtcbiAgfVxuXG4gIC8vIE3DqXRvZG9zIHByb3RlZ2lkb3MgYXV4aWxpYXJlc1xuICBwcm90ZWN0ZWQgcG9zaXRpb25Ub1NxdWFyZShwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbik6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJ2EnLmNoYXJDb2RlQXQoMCkgKyBwb3NpdGlvbi5jb2wpO1xuICAgIGNvbnN0IHJhbmsgPSA4IC0gcG9zaXRpb24ucm93O1xuICAgIHJldHVybiBgJHtmaWxlfSR7cmFua31gO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNxdWFyZVRvUG9zaXRpb24oc3F1YXJlOiBzdHJpbmcpOiBDaGVzc1Bvc2l0aW9uIHtcbiAgICBjb25zdCBjb2wgPSBzcXVhcmUuY2hhckNvZGVBdCgwKSAtICdhJy5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IHJvdyA9IDggLSBwYXJzZUludChzcXVhcmVbMV0pO1xuICAgIHJldHVybiB7IHJvdywgY29sIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgZmluZEtpbmcoY29sb3I6ICd3aGl0ZScgfCAnYmxhY2snKTogQ2hlc3NQb3NpdGlvbiB7XG4gICAgY29uc3QgYm9hcmQgPSB0aGlzLmdhbWUuYm9hcmQoKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgICAgIGlmIChwaWVjZSAmJiBcbiAgICAgICAgICAgIHBpZWNlLnR5cGUgPT09ICdrJyAmJiBcbiAgICAgICAgICAgIHBpZWNlLmNvbG9yID09PSAoY29sb3IgPT09ICd3aGl0ZScgPyAndycgOiAnYicpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgcm93LCBjb2wgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tpbmcgbm90IGZvdW5kJyk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpY2EgbyBzdGF0dXMgZGUgc2HDumRlIGRvIG1vdG9yLlxuICAgKiBcbiAgICogQHJldHVybnMgU3RhdHVzIGF0dWFsIGRvIG1vdG9yIGluY2x1aW5kbyBtw6l0cmljYXMgZGUgZGVzZW1wZW5ob1xuICAgKi9cbiAgcHVibGljIGNoZWNrSGVhbHRoKCk6IEhlYWx0aFN0YXR1cyB7XG4gICAgcmV0dXJuIHRoaXMubW9uaXRvci5jaGVja0hlYWx0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRlIHVtIGV2ZW50byBkbyBtb3Rvci5cbiAgICogXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50byBhIHNlciBlbWl0aWRvXG4gICAqL1xuICBwcm90ZWN0ZWQgZW1pdEV2ZW50KGV2ZW50OiBFbmdpbmVFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2VuZ2luZS1ldmVudCcsIGV2ZW50KTtcbiAgICB0aGlzLm1vbml0b3IucmVjb3JkRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgLy8gTcOpdG9kb3MgZGUgYXZhbGlhw6fDo29cbiAgcHJpdmF0ZSBldmFsdWF0ZU1hdGVyaWFsKCk6IG51bWJlciB7XG4gICAgY29uc3QgcGllY2VWYWx1ZXMgPSB7XG4gICAgICBwOiAxLFxuICAgICAgbjogMyxcbiAgICAgIGI6IDMsXG4gICAgICByOiA1LFxuICAgICAgcTogOSxcbiAgICAgIGs6IDBcbiAgICB9O1xuXG4gICAgbGV0IHNjb3JlID0gMDtcbiAgICBjb25zdCBib2FyZCA9IHRoaXMuZ2FtZS5ib2FyZCgpO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDg7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbcm93XVtjb2xdO1xuICAgICAgICBpZiAocGllY2UpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBpZWNlVmFsdWVzW3BpZWNlLnR5cGUgYXMga2V5b2YgdHlwZW9mIHBpZWNlVmFsdWVzXTtcbiAgICAgICAgICBzY29yZSArPSBwaWVjZS5jb2xvciA9PT0gJ3cnID8gdmFsdWUgOiAtdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlTW9iaWxpdHkoKTogbnVtYmVyIHtcbiAgICBjb25zdCB3aGl0ZU1vdmVzID0gdGhpcy5nYW1lLm1vdmVzKCkubGVuZ3RoO1xuICAgIC8vIENsb25hIG8gam9nbyBwYXJhIHZlciBvcyBtb3ZpbWVudG9zIGRvIG9wb25lbnRlXG4gICAgY29uc3QgdGVtcEdhbWUgPSBuZXcgQ2hlc3ModGhpcy5nYW1lLmZlbigpKTtcbiAgICB0ZW1wR2FtZS5sb2FkKHRoaXMuZ2FtZS5mZW4oKS5yZXBsYWNlKCcgdyAnLCAnIGIgJykpO1xuICAgIGNvbnN0IGJsYWNrTW92ZXMgPSB0ZW1wR2FtZS5tb3ZlcygpLmxlbmd0aDtcbiAgICBcbiAgICByZXR1cm4gd2hpdGVNb3ZlcyAtIGJsYWNrTW92ZXM7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlS2luZ1NhZmV0eSgpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGF2YWxpYcOnw6NvIGRlIHNlZ3VyYW7Dp2EgZG8gcmVpXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBwcml2YXRlIGV2YWx1YXRlUGF3blN0cnVjdHVyZSgpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGF2YWxpYcOnw6NvIGRlIGVzdHJ1dHVyYSBkZSBwZcO1ZXNcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiAoZXZlbnQ6IEVuZ2luZUV2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogKGV2ZW50OiBFbmdpbmVFdmVudCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ2hlc3MiLCJBcnF1aW1heE1vbml0b3IiLCJJTklUSUFMX0ZFTiIsIkV2ZW50RW1pdHRlciIsIkNoZXNzRW5naW5lQmFzZSIsImdldEJvYXJkIiwiYm9hcmQiLCJnYW1lIiwibWFwIiwicm93Iiwic3F1YXJlIiwidHlwZSIsImNvbG9yIiwiZ2V0RkVOIiwiZmVuIiwic2V0RkVOIiwibG9hZCIsImVtaXRFdmVudCIsImUiLCJFcnJvciIsImdldFBvc3NpYmxlTW92ZXMiLCJwb3NpdGlvbiIsInBvc2l0aW9uVG9TcXVhcmUiLCJjYWNoZUtleSIsImNhY2hlSGl0IiwicG9zaXRpb25DYWNoZSIsImhhcyIsIm1vdmVzIiwiY2FjaGUiLCJnZXQiLCJiZXN0TGluZSIsInZlcmJvc2UiLCJzZXQiLCJldmFsdWF0aW9uIiwiZGVwdGgiLCJ0aHJlYXRzIiwicG9zaXRpb25hbEZlYXR1cmVzIiwicGF3blN0cnVjdHVyZSIsImtpbmdTYWZldHkiLCJtb2JpbGl0eSIsImNlbnRlckNvbnRyb2wiLCJwaWVjZUFjdGl2aXR5IiwibW9uaXRvciIsInJlY29yZENhY2hlQWNjZXNzIiwibW92ZSIsImZyb20iLCJzcXVhcmVUb1Bvc2l0aW9uIiwidG8iLCJwaWVjZSIsImNhcHR1cmVkIiwidW5kZWZpbmVkIiwicHJvbW90aW9uIiwibWFrZU1vdmUiLCJjaGVzc01vdmUiLCJpc0NoZWNrIiwia2luZ1Bvc2l0aW9uIiwiZmluZEtpbmciLCJnZXRDdXJyZW50UGxheWVyIiwiaXNHYW1lT3ZlciIsInJlc3VsdCIsImlzQ2hlY2ttYXRlIiwidW5kb0xhc3RNb3ZlIiwidW5kbyIsImlzRHJhdyIsInR1cm4iLCJldmFsdWF0ZVBvc2l0aW9uIiwid2VpZ2h0cyIsIm9wdGlvbnMiLCJldmFsdWF0aW9uUGFyYW1ldGVycyIsIm1hdGVyaWFsV2VpZ2h0IiwicG9zaXRpb25XZWlnaHQiLCJtb2JpbGl0eVdlaWdodCIsImtpbmdTYWZldHlXZWlnaHQiLCJwYXduU3RydWN0dXJlV2VpZ2h0Iiwic2NvcmUiLCJldmFsdWF0ZU1hdGVyaWFsIiwiZXZhbHVhdGVQaWVjZVBvc2l0aW9ucyIsImV2YWx1YXRlTW9iaWxpdHkiLCJldmFsdWF0ZUtpbmdTYWZldHkiLCJldmFsdWF0ZVBhd25TdHJ1Y3R1cmUiLCJwaWVjZVNxdWFyZVZhbHVlcyIsInAiLCJuIiwiYiIsImNvbCIsInBpZWNlVGFibGUiLCJwb3NpdGlvblZhbHVlIiwiZ2V0QmVzdE1vdmUiLCJnZXRHYW1lSGlzdG9yeSIsImhpc3RvcnkiLCJpc1ZhbGlkTW92ZSIsImlzVmFsaWRQb3NpdGlvbiIsInJlc2V0IiwiY2xlYXIiLCJjbG9uZSIsImNsb25lZEVuZ2luZSIsImZpbGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUF0IiwicmFuayIsInBhcnNlSW50IiwiY2hlY2tIZWFsdGgiLCJldmVudCIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJyZWNvcmRFdmVudCIsInBpZWNlVmFsdWVzIiwiciIsInEiLCJrIiwidmFsdWUiLCJ3aGl0ZU1vdmVzIiwibGVuZ3RoIiwidGVtcEdhbWUiLCJyZXBsYWNlIiwiYmxhY2tNb3ZlcyIsIm9uIiwiZXZlbnROYW1lIiwiaGFuZGxlciIsIm9mZiIsImNvbnN0cnVjdG9yIiwic3RhcnRQb3NpdGlvbiIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/shared/engine/ChessEngineBase.ts\n"));

/***/ }),

/***/ "./src/shared/engine/CulturalChessEngine.ts":
/*!**************************************************!*\
  !*** ./src/shared/engine/CulturalChessEngine.ts ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CulturalChessEngine\": function() { return /* binding */ CulturalChessEngine; }\n/* harmony export */ });\n/* harmony import */ var _ChessEngineBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChessEngineBase */ \"./src/shared/engine/ChessEngineBase.ts\");\n/* harmony import */ var _constants_game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/game */ \"./src/shared/constants/game.ts\");\n\n\nclass CulturalChessEngine extends _ChessEngineBase__WEBPACK_IMPORTED_MODULE_0__.ChessEngineBase {\n    // Implementao da interface CulturalEngineExtension\n    setCulturalStyle(style) {\n        if (!(style in _constants_game__WEBPACK_IMPORTED_MODULE_1__.CULTURAL_STYLES)) {\n            throw new Error(\"Estilo cultural inv\\xe1lido: \".concat(style));\n        }\n        this.currentStyle = style;\n        this.triggerCulturalEvent(\"STYLE_CHANGED\");\n    }\n    getCulturalNarrative() {\n        const narratives = [];\n        const recentMoves = this.playStyleHistory.slice(-5);\n        const styleAnalysis = this.analyzePlayStyle();\n        // Narrativa baseada no estilo dominante\n        narratives.push(\"Seu jogo reflete o estilo \".concat(styleAnalysis.dominantStyle, \", \") + \"com \\xeanfase em \".concat(this.getStyleCharacteristics(styleAnalysis.dominantStyle), \".\"));\n        // Narrativa baseada nos movimentos recentes\n        if (recentMoves.length > 0) {\n            const recentStyle = this.analyzeMoveSequence(recentMoves);\n            narratives.push(\"Nos \\xfaltimos movimentos, voc\\xea demonstrou uma tend\\xeancia a \" + \"\".concat(this.getStyleTendency(recentStyle), \".\"));\n        }\n        // Narrativa cultural especfica\n        narratives.push(this.getCulturalStyleNarrative());\n        return narratives;\n    }\n    getStyleBasedEvaluation() {\n        const baseEvaluation = super.evaluatePosition();\n        const styleModifier = this.getStyleModifier();\n        const modifiedEvaluation = baseEvaluation * styleModifier;\n        return {\n            style: this.currentStyle,\n            evaluation: modifiedEvaluation,\n            explanation: this.getStyleEvaluation()\n        };\n    }\n    triggerCulturalEvent(type) {\n        if (!(type in _constants_game__WEBPACK_IMPORTED_MODULE_1__.CULTURAL_EVENTS)) {\n            throw new Error(\"Tipo de evento cultural inv\\xe1lido: \".concat(type));\n        }\n        const event = {\n            type,\n            timestamp: Date.now(),\n            description: this.getEventDescription(type)\n        };\n        this.culturalEvents.push(event);\n        this.emitEvent({\n            type: \"CULTURAL_EVENT\",\n            event: {\n                type: event.type,\n                description: event.description\n            }\n        });\n    }\n    getCulturalEventHistory() {\n        return [\n            ...this.culturalEvents\n        ];\n    }\n    analyzePlayStyle() {\n        const metrics = this.calculateStyleMetrics();\n        const dominantStyle = this.findDominantStyle(metrics);\n        const recommendations = this.generateRecommendations(metrics);\n        return {\n            dominantStyle,\n            styleMetrics: metrics,\n            recommendations\n        };\n    }\n    // Mtodos auxiliares privados\n    analyzeMoveStyle(move) {\n        const isAggressive = this.isAggressiveMove(move);\n        const isPositional = this.isPositionalMove(move);\n        const isTactical = this.isTacticalMove(move);\n        if (isAggressive) {\n            this.triggerCulturalEvent(\"AGGRESSIVE_MOVE\");\n        } else if (isPositional) {\n            this.triggerCulturalEvent(\"POSITIONAL_MOVE\");\n        } else if (isTactical) {\n            this.triggerCulturalEvent(\"TACTICAL_MOVE\");\n        }\n    }\n    analyzeMoveSequence(moves) {\n        let aggressiveCount = 0;\n        let positionalCount = 0;\n        let tacticalCount = 0;\n        moves.forEach((move)=>{\n            if (this.isAggressiveMove(move)) aggressiveCount++;\n            if (this.isPositionalMove(move)) positionalCount++;\n            if (this.isTacticalMove(move)) tacticalCount++;\n        });\n        const total = moves.length;\n        const scores = {\n            aggressive: aggressiveCount / total,\n            positional: positionalCount / total,\n            tactical: tacticalCount / total\n        };\n        return Object.entries(scores).reduce((a, b)=>a[1] > b[1] ? a : b)[0];\n    }\n    isAggressiveMove(move) {\n        return Boolean(move.captured || // Captura\n        this.isCheck() || // Xeque\n        this.isAttackingCenterPieces(move) // Ataque ao centro\n        );\n    }\n    isPositionalMove(move) {\n        return Boolean(this.improvesPosition(move) || this.controlsImportantSquares(move) || this.improvesPawnStructure(move));\n    }\n    isTacticalMove(move) {\n        return Boolean(this.createsThreat(move) || this.createsFork(move) || this.createsPin(move));\n    }\n    calculateStyleMetrics() {\n        const metrics = {\n            aggressive: 0,\n            defensive: 0,\n            positional: 0,\n            tactical: 0\n        };\n        this.playStyleHistory.forEach((move)=>{\n            if (this.isAggressiveMove(move)) metrics.aggressive++;\n            if (this.isPositionalMove(move)) metrics.positional++;\n            if (this.isTacticalMove(move)) metrics.tactical++;\n            // Movimento defensivo  calculado de forma diferente\n            if (this.isDefensiveMove(move)) metrics.defensive++;\n        });\n        // Normaliza as mtricas\n        const total = Object.values(metrics).reduce((a, b)=>a + b, 0);\n        if (total > 0) {\n            Object.keys(metrics).forEach((key)=>{\n                metrics[key] = metrics[key] / total;\n            });\n        }\n        return metrics;\n    }\n    findDominantStyle(metrics) {\n        return Object.entries(metrics).reduce((a, b)=>a[1] > b[1] ? a : b)[0];\n    }\n    generateRecommendations(metrics) {\n        const recommendations = [];\n        const dominantStyle = this.findDominantStyle(metrics);\n        // Recomendaes baseadas no estilo dominante\n        recommendations.push(\"Continue explorando seu estilo \".concat(dominantStyle, \", mas considere tamb\\xe9m:\"));\n        // Recomendaes para equilibrar o jogo\n        Object.entries(metrics).filter((param)=>{\n            let [style] = param;\n            return style !== dominantStyle;\n        }).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return a - b;\n        }).forEach((param)=>{\n            let [style, value] = param;\n            if (value < 0.2) {\n                recommendations.push(this.getStyleRecommendation(style));\n            }\n        });\n        return recommendations;\n    }\n    getStyleModifier() {\n        // Modifica a avaliao baseada no estilo cultural\n        const modifiers = {\n            medieval: 1.1,\n            renaissance: 1.2,\n            modern: 1.0,\n            ancient: 0.9 // Valoriza sacrifcios e ataques\n        };\n        return modifiers[this.currentStyle] || 1.0;\n    }\n    getStyleEvaluation() {\n        const evaluation = super.evaluatePosition();\n        const style = this.currentStyle;\n        switch(style){\n            case \"medieval\":\n                return evaluation > 0 ? \"Vantagem material e posicional s\\xf3lida\" : \"Necessidade de consolidar posi\\xe7\\xe3o e material\";\n            case \"renaissance\":\n                return evaluation > 0 ? \"Excelente desenvolvimento e mobilidade\" : \"Oportunidade para melhorar desenvolvimento\";\n            case \"modern\":\n                return evaluation > 0 ? \"Posi\\xe7\\xe3o equilibrada com vantagem\" : \"Posi\\xe7\\xe3o requer aten\\xe7\\xe3o estrat\\xe9gica\";\n            case \"ancient\":\n                return evaluation > 0 ? \"Potencial para sacrif\\xedcios decisivos\" : \"Momento para sacrif\\xedcios t\\xe1ticos\";\n            default:\n                return \"Avalia\\xe7\\xe3o padr\\xe3o da posi\\xe7\\xe3o\";\n        }\n    }\n    getStyleCharacteristics(style) {\n        const characteristics = {\n            aggressive: \"ataques diretos e sacrif\\xedcios\",\n            defensive: \"s\\xf3lida estrutura defensiva\",\n            positional: \"controle posicional e estrat\\xe9gico\",\n            tactical: \"combina\\xe7\\xf5es e t\\xe1ticas complexas\"\n        };\n        return characteristics[style] || \"estilo equilibrado\";\n    }\n    getStyleTendency(style) {\n        const tendencies = {\n            aggressive: \"buscar iniciativas de ataque\",\n            defensive: \"fortalecer sua posi\\xe7\\xe3o\",\n            positional: \"controlar pontos estrat\\xe9gicos\",\n            tactical: \"criar amea\\xe7as t\\xe1ticas\"\n        };\n        return tendencies[style] || \"manter um jogo equilibrado\";\n    }\n    getEventDescription(type) {\n        const descriptions = {\n            AGGRESSIVE_MOVE: \"Movimento agressivo detectado\",\n            POSITIONAL_MOVE: \"Melhoria posicional significativa\",\n            TACTICAL_MOVE: \"Combina\\xe7\\xe3o t\\xe1tica identificada\",\n            STYLE_CHANGED: \"Estilo alterado para \".concat(this.currentStyle),\n            BRILLIANT_MOVE: \"Movimento brilhante executado\",\n            CRITICAL_POSITION: \"Posi\\xe7\\xe3o cr\\xedtica alcan\\xe7ada\"\n        };\n        return descriptions[type] || \"Evento cultural ocorrido\";\n    }\n    getCulturalStyleNarrative() {\n        const narratives = {\n            medieval: \"Seu jogo reflete a solidez e tradi\\xe7\\xe3o do xadrez medieval.\",\n            renaissance: \"Voc\\xea demonstra a criatividade e inova\\xe7\\xe3o do per\\xedodo renascentista.\",\n            modern: \"Seu estilo incorpora princ\\xedpios modernos de flexibilidade e pragmatismo.\",\n            ancient: \"Sua abordagem evoca a sabedoria e profundidade do xadrez antigo.\"\n        };\n        return narratives[this.currentStyle] || \"Seu estilo \\xe9 \\xfanico e pessoal.\";\n    }\n    getStyleRecommendation(style) {\n        const recommendations = {\n            aggressive: \"Procure oportunidades de ataque direto ao rei advers\\xe1rio\",\n            defensive: \"Fortale\\xe7a sua estrutura de pe\\xf5es e seguran\\xe7a do rei\",\n            positional: \"Foque no controle do centro e posicionamento de pe\\xe7as\",\n            tactical: \"Busque combina\\xe7\\xf5es e trocas favor\\xe1veis\"\n        };\n        return recommendations[style] || \"Mantenha um jogo equilibrado\";\n    }\n    // Mtodos de avaliao especficos\n    isAttackingCenterPieces(move) {\n        const centerSquares = [\n            {\n                row: 3,\n                col: 3\n            },\n            {\n                row: 3,\n                col: 4\n            },\n            {\n                row: 4,\n                col: 3\n            },\n            {\n                row: 4,\n                col: 4\n            }\n        ];\n        return centerSquares.some((square)=>square.row === move.to.row && square.col === move.to.col);\n    }\n    improvesPosition(move) {\n        // Verifica se o movimento melhora a posio da pea\n        const fromScore = this.getSquareValue(move.from);\n        const toScore = this.getSquareValue(move.to);\n        return toScore > fromScore;\n    }\n    controlsImportantSquares(move) {\n        // Verifica se o movimento controla casas importantes\n        const attacks = this.getPossibleMoves(move.to);\n        return attacks.some((attack)=>this.isImportantSquare(attack.to));\n    }\n    improvesPawnStructure(move) {\n        // TODO: Implementar anlise de estrutura de pees\n        return false;\n    }\n    createsThreat(move) {\n        const clone = this.clone();\n        clone.makeMove(move.from, move.to);\n        return clone.isCheck();\n    }\n    createsFork(move) {\n        // TODO: Implementar deteco de garfo\n        return false;\n    }\n    createsPin(move) {\n        // TODO: Implementar deteco de cravada\n        return false;\n    }\n    isDefensiveMove(move) {\n        // TODO: Implementar deteco de movimento defensivo\n        return false;\n    }\n    getSquareValue(position) {\n        // Valores das casas do tabuleiro (centro vale mais)\n        const squareValues = [\n            [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1,\n                0\n            ],\n            [\n                0,\n                1,\n                2,\n                2,\n                2,\n                2,\n                1,\n                0\n            ],\n            [\n                0,\n                1,\n                2,\n                3,\n                3,\n                2,\n                1,\n                0\n            ],\n            [\n                0,\n                1,\n                2,\n                3,\n                3,\n                2,\n                1,\n                0\n            ],\n            [\n                0,\n                1,\n                2,\n                2,\n                2,\n                2,\n                1,\n                0\n            ],\n            [\n                0,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        return squareValues[position.row][position.col];\n    }\n    isImportantSquare(position) {\n        return this.getSquareValue(position) >= 2;\n    }\n    constructor(options = {}){\n        super(options);\n        this.currentStyle = \"modern\";\n        this.culturalEvents = [];\n        this.playStyleHistory = [];\n        // Registra movimentos para anlise de estilo\n        this.on(\"engine-event\", (event)=>{\n            if (event.type === \"MOVE_MADE\") {\n                this.playStyleHistory.push(event.move);\n                this.analyzeMoveStyle(event.move);\n            }\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9DdWx0dXJhbENoZXNzRW5naW5lLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRDtBQUdpQjtBQUU5RCxNQUFNRyw0QkFBNEJILDZEQUFlQTtJQXdCdEQscURBQXFEO0lBQ3JESSxpQkFBaUJDLEtBQWEsRUFBUTtRQUNwQyxJQUFJLENBQUVBLENBQUFBLFNBQVNKLDREQUFjLEdBQUk7WUFDL0IsTUFBTSxJQUFJSyxNQUFNLGdDQUFtQyxPQUFORCxRQUFTO1FBQ3hELENBQUM7UUFDRCxJQUFJLENBQUNFLFlBQVksR0FBR0Y7UUFDcEIsSUFBSSxDQUFDRyxvQkFBb0IsQ0FBQztJQUM1QjtJQUVBQyx1QkFBaUM7UUFDL0IsTUFBTUMsYUFBdUIsRUFBRTtRQUMvQixNQUFNQyxjQUFjLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNDLEtBQUssQ0FBQyxDQUFDO1FBQ2pELE1BQU1DLGdCQUFnQixJQUFJLENBQUNDLGdCQUFnQjtRQUUzQyx3Q0FBd0M7UUFDeENMLFdBQVdNLElBQUksQ0FDYiw2QkFBeUQsT0FBNUJGLGNBQWNHLGFBQWEsRUFBQyxRQUN6RCxvQkFBMkUsT0FBMUQsSUFBSSxDQUFDQyx1QkFBdUIsQ0FBQ0osY0FBY0csYUFBYSxHQUFFO1FBRzdFLDRDQUE0QztRQUM1QyxJQUFJTixZQUFZUSxNQUFNLEdBQUcsR0FBRztZQUMxQixNQUFNQyxjQUFjLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNWO1lBQzdDRCxXQUFXTSxJQUFJLENBQ2Isc0VBQ0EsR0FBc0MsT0FBbkMsSUFBSSxDQUFDTSxnQkFBZ0IsQ0FBQ0YsY0FBYTtRQUUxQyxDQUFDO1FBRUQsZ0NBQWdDO1FBQ2hDVixXQUFXTSxJQUFJLENBQUMsSUFBSSxDQUFDTyx5QkFBeUI7UUFFOUMsT0FBT2I7SUFDVDtJQUVBYywwQkFJRTtRQUNBLE1BQU1DLGlCQUFpQixLQUFLLENBQUNDLGdCQUFnQjtRQUM3QyxNQUFNQyxnQkFBZ0IsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDM0Ms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SUFBSSxDQUFDNUIsZ0JBQWdCLEdBQUcsRUFBRTtRQUUxQiw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDaUgsRUFBRSxDQUFDLGdCQUFnQixDQUFDM0YsUUFBVTtZQUNqQyxJQUFJQSxNQUFNRCxJQUFJLEtBQUssYUFBYTtnQkFDOUIsSUFBSSxDQUFDckIsZ0JBQWdCLENBQUNJLElBQUksQ0FBQ2tCLE1BQU1nQixJQUFJO2dCQUNyQyxJQUFJLENBQUNELGdCQUFnQixDQUFDZixNQUFNZ0IsSUFBSTtZQUNsQyxDQUFDO1FBQ0g7SUFDRjtBQTJYRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zaGFyZWQvZW5naW5lL0N1bHR1cmFsQ2hlc3NFbmdpbmUudHM/NmZlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzc0VuZ2luZUJhc2UgfSBmcm9tICcuL0NoZXNzRW5naW5lQmFzZSc7XG5pbXBvcnQgeyBDdWx0dXJhbEVuZ2luZUV4dGVuc2lvbiwgRW5naW5lT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzL2VuZ2luZSc7XG5pbXBvcnQgeyBDaGVzc01vdmUgfSBmcm9tICcuLi90eXBlcy9jaGVzcyc7XG5pbXBvcnQgeyBDVUxUVVJBTF9TVFlMRVMsIENVTFRVUkFMX0VWRU5UUyB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lJztcblxuZXhwb3J0IGNsYXNzIEN1bHR1cmFsQ2hlc3NFbmdpbmUgZXh0ZW5kcyBDaGVzc0VuZ2luZUJhc2UgaW1wbGVtZW50cyBDdWx0dXJhbEVuZ2luZUV4dGVuc2lvbiB7XG4gIHByaXZhdGUgY3VycmVudFN0eWxlOiBzdHJpbmc7XG4gIHByaXZhdGUgY3VsdHVyYWxFdmVudHM6IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgfVtdO1xuICBwcml2YXRlIHBsYXlTdHlsZUhpc3Rvcnk6IENoZXNzTW92ZVtdO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVuZ2luZU9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuY3VycmVudFN0eWxlID0gJ21vZGVybic7XG4gICAgdGhpcy5jdWx0dXJhbEV2ZW50cyA9IFtdO1xuICAgIHRoaXMucGxheVN0eWxlSGlzdG9yeSA9IFtdO1xuXG4gICAgLy8gUmVnaXN0cmEgbW92aW1lbnRvcyBwYXJhIGFuw6FsaXNlIGRlIGVzdGlsb1xuICAgIHRoaXMub24oJ2VuZ2luZS1ldmVudCcsIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdNT1ZFX01BREUnKSB7XG4gICAgICAgIHRoaXMucGxheVN0eWxlSGlzdG9yeS5wdXNoKGV2ZW50Lm1vdmUpO1xuICAgICAgICB0aGlzLmFuYWx5emVNb3ZlU3R5bGUoZXZlbnQubW92ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBJbXBsZW1lbnRhw6fDo28gZGEgaW50ZXJmYWNlIEN1bHR1cmFsRW5naW5lRXh0ZW5zaW9uXG4gIHNldEN1bHR1cmFsU3R5bGUoc3R5bGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghKHN0eWxlIGluIENVTFRVUkFMX1NUWUxFUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXN0aWxvIGN1bHR1cmFsIGludsOhbGlkbzogJHtzdHlsZX1gKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50U3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLnRyaWdnZXJDdWx0dXJhbEV2ZW50KCdTVFlMRV9DSEFOR0VEJyk7XG4gIH1cblxuICBnZXRDdWx0dXJhbE5hcnJhdGl2ZSgpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgbmFycmF0aXZlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWNlbnRNb3ZlcyA9IHRoaXMucGxheVN0eWxlSGlzdG9yeS5zbGljZSgtNSk7XG4gICAgY29uc3Qgc3R5bGVBbmFseXNpcyA9IHRoaXMuYW5hbHl6ZVBsYXlTdHlsZSgpO1xuXG4gICAgLy8gTmFycmF0aXZhIGJhc2VhZGEgbm8gZXN0aWxvIGRvbWluYW50ZVxuICAgIG5hcnJhdGl2ZXMucHVzaChcbiAgICAgIGBTZXUgam9nbyByZWZsZXRlIG8gZXN0aWxvICR7c3R5bGVBbmFseXNpcy5kb21pbmFudFN0eWxlfSwgYCArXG4gICAgICBgY29tIMOqbmZhc2UgZW0gJHt0aGlzLmdldFN0eWxlQ2hhcmFjdGVyaXN0aWNzKHN0eWxlQW5hbHlzaXMuZG9taW5hbnRTdHlsZSl9LmBcbiAgICApO1xuXG4gICAgLy8gTmFycmF0aXZhIGJhc2VhZGEgbm9zIG1vdmltZW50b3MgcmVjZW50ZXNcbiAgICBpZiAocmVjZW50TW92ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVjZW50U3R5bGUgPSB0aGlzLmFuYWx5emVNb3ZlU2VxdWVuY2UocmVjZW50TW92ZXMpO1xuICAgICAgbmFycmF0aXZlcy5wdXNoKFxuICAgICAgICBgTm9zIMO6bHRpbW9zIG1vdmltZW50b3MsIHZvY8OqIGRlbW9uc3Ryb3UgdW1hIHRlbmTDqm5jaWEgYSBgICtcbiAgICAgICAgYCR7dGhpcy5nZXRTdHlsZVRlbmRlbmN5KHJlY2VudFN0eWxlKX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBOYXJyYXRpdmEgY3VsdHVyYWwgZXNwZWPDrWZpY2FcbiAgICBuYXJyYXRpdmVzLnB1c2godGhpcy5nZXRDdWx0dXJhbFN0eWxlTmFycmF0aXZlKCkpO1xuXG4gICAgcmV0dXJuIG5hcnJhdGl2ZXM7XG4gIH1cblxuICBnZXRTdHlsZUJhc2VkRXZhbHVhdGlvbigpOiB7XG4gICAgc3R5bGU6IHN0cmluZztcbiAgICBldmFsdWF0aW9uOiBudW1iZXI7XG4gICAgZXhwbGFuYXRpb246IHN0cmluZztcbiAgfSB7XG4gICAgY29uc3QgYmFzZUV2YWx1YXRpb24gPSBzdXBlci5ldmFsdWF0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc3R5bGVNb2RpZmllciA9IHRoaXMuZ2V0U3R5bGVNb2RpZmllcigpO1xuICAgIGNvbnN0IG1vZGlmaWVkRXZhbHVhdGlvbiA9IGJhc2VFdmFsdWF0aW9uICogc3R5bGVNb2RpZmllcjtcblxuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogdGhpcy5jdXJyZW50U3R5bGUsXG4gICAgICBldmFsdWF0aW9uOiBtb2RpZmllZEV2YWx1YXRpb24sXG4gICAgICBleHBsYW5hdGlvbjogdGhpcy5nZXRTdHlsZUV2YWx1YXRpb24oKVxuICAgIH07XG4gIH1cblxuICB0cmlnZ2VyQ3VsdHVyYWxFdmVudCh0eXBlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoISh0eXBlIGluIENVTFRVUkFMX0VWRU5UUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGlwbyBkZSBldmVudG8gY3VsdHVyYWwgaW52w6FsaWRvOiAke3R5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZ2V0RXZlbnREZXNjcmlwdGlvbih0eXBlKVxuICAgIH07XG5cbiAgICB0aGlzLmN1bHR1cmFsRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIHRoaXMuZW1pdEV2ZW50KHtcbiAgICAgIHR5cGU6ICdDVUxUVVJBTF9FVkVOVCcsXG4gICAgICBldmVudDoge1xuICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICBkZXNjcmlwdGlvbjogZXZlbnQuZGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEN1bHR1cmFsRXZlbnRIaXN0b3J5KCk6IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgfVtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuY3VsdHVyYWxFdmVudHNdO1xuICB9XG5cbiAgYW5hbHl6ZVBsYXlTdHlsZSgpOiB7XG4gICAgZG9taW5hbnRTdHlsZTogc3RyaW5nO1xuICAgIHN0eWxlTWV0cmljczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgICByZWNvbW1lbmRhdGlvbnM6IHN0cmluZ1tdO1xuICB9IHtcbiAgICBjb25zdCBtZXRyaWNzID0gdGhpcy5jYWxjdWxhdGVTdHlsZU1ldHJpY3MoKTtcbiAgICBjb25zdCBkb21pbmFudFN0eWxlID0gdGhpcy5maW5kRG9taW5hbnRTdHlsZShtZXRyaWNzKTtcbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSB0aGlzLmdlbmVyYXRlUmVjb21tZW5kYXRpb25zKG1ldHJpY3MpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbWluYW50U3R5bGUsXG4gICAgICBzdHlsZU1ldHJpY3M6IG1ldHJpY3MsXG4gICAgICByZWNvbW1lbmRhdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLy8gTcOpdG9kb3MgYXV4aWxpYXJlcyBwcml2YWRvc1xuICBwcml2YXRlIGFuYWx5emVNb3ZlU3R5bGUobW92ZTogQ2hlc3NNb3ZlKTogdm9pZCB7XG4gICAgY29uc3QgaXNBZ2dyZXNzaXZlID0gdGhpcy5pc0FnZ3Jlc3NpdmVNb3ZlKG1vdmUpO1xuICAgIGNvbnN0IGlzUG9zaXRpb25hbCA9IHRoaXMuaXNQb3NpdGlvbmFsTW92ZShtb3ZlKTtcbiAgICBjb25zdCBpc1RhY3RpY2FsID0gdGhpcy5pc1RhY3RpY2FsTW92ZShtb3ZlKTtcblxuICAgIGlmIChpc0FnZ3Jlc3NpdmUpIHtcbiAgICAgIHRoaXMudHJpZ2dlckN1bHR1cmFsRXZlbnQoJ0FHR1JFU1NJVkVfTU9WRScpO1xuICAgIH0gZWxzZSBpZiAoaXNQb3NpdGlvbmFsKSB7XG4gICAgICB0aGlzLnRyaWdnZXJDdWx0dXJhbEV2ZW50KCdQT1NJVElPTkFMX01PVkUnKTtcbiAgICB9IGVsc2UgaWYgKGlzVGFjdGljYWwpIHtcbiAgICAgIHRoaXMudHJpZ2dlckN1bHR1cmFsRXZlbnQoJ1RBQ1RJQ0FMX01PVkUnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFuYWx5emVNb3ZlU2VxdWVuY2UobW92ZXM6IENoZXNzTW92ZVtdKTogc3RyaW5nIHtcbiAgICBsZXQgYWdncmVzc2l2ZUNvdW50ID0gMDtcbiAgICBsZXQgcG9zaXRpb25hbENvdW50ID0gMDtcbiAgICBsZXQgdGFjdGljYWxDb3VudCA9IDA7XG5cbiAgICBtb3Zlcy5mb3JFYWNoKG1vdmUgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNBZ2dyZXNzaXZlTW92ZShtb3ZlKSkgYWdncmVzc2l2ZUNvdW50Kys7XG4gICAgICBpZiAodGhpcy5pc1Bvc2l0aW9uYWxNb3ZlKG1vdmUpKSBwb3NpdGlvbmFsQ291bnQrKztcbiAgICAgIGlmICh0aGlzLmlzVGFjdGljYWxNb3ZlKG1vdmUpKSB0YWN0aWNhbENvdW50Kys7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0b3RhbCA9IG1vdmVzLmxlbmd0aDtcbiAgICBjb25zdCBzY29yZXMgPSB7XG4gICAgICBhZ2dyZXNzaXZlOiBhZ2dyZXNzaXZlQ291bnQgLyB0b3RhbCxcbiAgICAgIHBvc2l0aW9uYWw6IHBvc2l0aW9uYWxDb3VudCAvIHRvdGFsLFxuICAgICAgdGFjdGljYWw6IHRhY3RpY2FsQ291bnQgLyB0b3RhbFxuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc2NvcmVzKVxuICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYVsxXSA+IGJbMV0gPyBhIDogYilbMF07XG4gIH1cblxuICBwcml2YXRlIGlzQWdncmVzc2l2ZU1vdmUobW92ZTogQ2hlc3NNb3ZlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICBtb3ZlLmNhcHR1cmVkIHx8IC8vIENhcHR1cmFcbiAgICAgIHRoaXMuaXNDaGVjaygpIHx8IC8vIFhlcXVlXG4gICAgICB0aGlzLmlzQXR0YWNraW5nQ2VudGVyUGllY2VzKG1vdmUpIC8vIEF0YXF1ZSBhbyBjZW50cm9cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1Bvc2l0aW9uYWxNb3ZlKG1vdmU6IENoZXNzTW92ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgdGhpcy5pbXByb3Zlc1Bvc2l0aW9uKG1vdmUpIHx8XG4gICAgICB0aGlzLmNvbnRyb2xzSW1wb3J0YW50U3F1YXJlcyhtb3ZlKSB8fFxuICAgICAgdGhpcy5pbXByb3Zlc1Bhd25TdHJ1Y3R1cmUobW92ZSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1RhY3RpY2FsTW92ZShtb3ZlOiBDaGVzc01vdmUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIHRoaXMuY3JlYXRlc1RocmVhdChtb3ZlKSB8fFxuICAgICAgdGhpcy5jcmVhdGVzRm9yayhtb3ZlKSB8fFxuICAgICAgdGhpcy5jcmVhdGVzUGluKG1vdmUpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlU3R5bGVNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIGNvbnN0IG1ldHJpY3M6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICBhZ2dyZXNzaXZlOiAwLFxuICAgICAgZGVmZW5zaXZlOiAwLFxuICAgICAgcG9zaXRpb25hbDogMCxcbiAgICAgIHRhY3RpY2FsOiAwXG4gICAgfTtcblxuICAgIHRoaXMucGxheVN0eWxlSGlzdG9yeS5mb3JFYWNoKG1vdmUgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNBZ2dyZXNzaXZlTW92ZShtb3ZlKSkgbWV0cmljcy5hZ2dyZXNzaXZlKys7XG4gICAgICBpZiAodGhpcy5pc1Bvc2l0aW9uYWxNb3ZlKG1vdmUpKSBtZXRyaWNzLnBvc2l0aW9uYWwrKztcbiAgICAgIGlmICh0aGlzLmlzVGFjdGljYWxNb3ZlKG1vdmUpKSBtZXRyaWNzLnRhY3RpY2FsKys7XG4gICAgICAvLyBNb3ZpbWVudG8gZGVmZW5zaXZvIMOpIGNhbGN1bGFkbyBkZSBmb3JtYSBkaWZlcmVudGVcbiAgICAgIGlmICh0aGlzLmlzRGVmZW5zaXZlTW92ZShtb3ZlKSkgbWV0cmljcy5kZWZlbnNpdmUrKztcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6YSBhcyBtw6l0cmljYXNcbiAgICBjb25zdCB0b3RhbCA9IE9iamVjdC52YWx1ZXMobWV0cmljcykucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgaWYgKHRvdGFsID4gMCkge1xuICAgICAgT2JqZWN0LmtleXMobWV0cmljcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBtZXRyaWNzW2tleV0gPSBtZXRyaWNzW2tleV0gLyB0b3RhbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRyaWNzO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRG9taW5hbnRTdHlsZShtZXRyaWNzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMobWV0cmljcylcbiAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGFbMV0gPiBiWzFdID8gYSA6IGIpWzBdO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyhtZXRyaWNzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBkb21pbmFudFN0eWxlID0gdGhpcy5maW5kRG9taW5hbnRTdHlsZShtZXRyaWNzKTtcblxuICAgIC8vIFJlY29tZW5kYcOnw7VlcyBiYXNlYWRhcyBubyBlc3RpbG8gZG9taW5hbnRlXG4gICAgcmVjb21tZW5kYXRpb25zLnB1c2goXG4gICAgICBgQ29udGludWUgZXhwbG9yYW5kbyBzZXUgZXN0aWxvICR7ZG9taW5hbnRTdHlsZX0sIG1hcyBjb25zaWRlcmUgdGFtYsOpbTpgXG4gICAgKTtcblxuICAgIC8vIFJlY29tZW5kYcOnw7VlcyBwYXJhIGVxdWlsaWJyYXIgbyBqb2dvXG4gICAgT2JqZWN0LmVudHJpZXMobWV0cmljcylcbiAgICAgIC5maWx0ZXIoKFtzdHlsZV0pID0+IHN0eWxlICE9PSBkb21pbmFudFN0eWxlKVxuICAgICAgLnNvcnQoKFssYV0sIFssYl0pID0+IGEgLSBiKVxuICAgICAgLmZvckVhY2goKFtzdHlsZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAuMikge1xuICAgICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5nZXRTdHlsZVJlY29tbWVuZGF0aW9uKHN0eWxlIGFzIGtleW9mIHR5cGVvZiBtZXRyaWNzKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3R5bGVNb2RpZmllcigpOiBudW1iZXIge1xuICAgIC8vIE1vZGlmaWNhIGEgYXZhbGlhw6fDo28gYmFzZWFkYSBubyBlc3RpbG8gY3VsdHVyYWxcbiAgICBjb25zdCBtb2RpZmllcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICBtZWRpZXZhbDogMS4xLCAvLyBWYWxvcml6YSBtYXRlcmlhbCBlIHBvc2nDp8Ojb1xuICAgICAgcmVuYWlzc2FuY2U6IDEuMiwgLy8gVmFsb3JpemEgbW9iaWxpZGFkZSBlIGRlc2Vudm9sdmltZW50b1xuICAgICAgbW9kZXJuOiAxLjAsIC8vIEJhbGFuY2VhZG9cbiAgICAgIGFuY2llbnQ6IDAuOSAvLyBWYWxvcml6YSBzYWNyaWbDrWNpb3MgZSBhdGFxdWVzXG4gICAgfTtcblxuICAgIHJldHVybiBtb2RpZmllcnNbdGhpcy5jdXJyZW50U3R5bGVdIHx8IDEuMDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3R5bGVFdmFsdWF0aW9uKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZXZhbHVhdGlvbiA9IHN1cGVyLmV2YWx1YXRlUG9zaXRpb24oKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuY3VycmVudFN0eWxlO1xuXG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbWVkaWV2YWwnOlxuICAgICAgICByZXR1cm4gZXZhbHVhdGlvbiA+IDBcbiAgICAgICAgICA/ICdWYW50YWdlbSBtYXRlcmlhbCBlIHBvc2ljaW9uYWwgc8OzbGlkYSdcbiAgICAgICAgICA6ICdOZWNlc3NpZGFkZSBkZSBjb25zb2xpZGFyIHBvc2nDp8OjbyBlIG1hdGVyaWFsJztcbiAgICAgIGNhc2UgJ3JlbmFpc3NhbmNlJzpcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRpb24gPiAwXG4gICAgICAgICAgPyAnRXhjZWxlbnRlIGRlc2Vudm9sdmltZW50byBlIG1vYmlsaWRhZGUnXG4gICAgICAgICAgOiAnT3BvcnR1bmlkYWRlIHBhcmEgbWVsaG9yYXIgZGVzZW52b2x2aW1lbnRvJztcbiAgICAgIGNhc2UgJ21vZGVybic6XG4gICAgICAgIHJldHVybiBldmFsdWF0aW9uID4gMFxuICAgICAgICAgID8gJ1Bvc2nDp8OjbyBlcXVpbGlicmFkYSBjb20gdmFudGFnZW0nXG4gICAgICAgICAgOiAnUG9zacOnw6NvIHJlcXVlciBhdGVuw6fDo28gZXN0cmF0w6lnaWNhJztcbiAgICAgIGNhc2UgJ2FuY2llbnQnOlxuICAgICAgICByZXR1cm4gZXZhbHVhdGlvbiA+IDBcbiAgICAgICAgICA/ICdQb3RlbmNpYWwgcGFyYSBzYWNyaWbDrWNpb3MgZGVjaXNpdm9zJ1xuICAgICAgICAgIDogJ01vbWVudG8gcGFyYSBzYWNyaWbDrWNpb3MgdMOhdGljb3MnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdBdmFsaWHDp8OjbyBwYWRyw6NvIGRhIHBvc2nDp8Ojbyc7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdHlsZUNoYXJhY3RlcmlzdGljcyhzdHlsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3M6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBhZ2dyZXNzaXZlOiAnYXRhcXVlcyBkaXJldG9zIGUgc2Fjcmlmw61jaW9zJyxcbiAgICAgIGRlZmVuc2l2ZTogJ3PDs2xpZGEgZXN0cnV0dXJhIGRlZmVuc2l2YScsXG4gICAgICBwb3NpdGlvbmFsOiAnY29udHJvbGUgcG9zaWNpb25hbCBlIGVzdHJhdMOpZ2ljbycsXG4gICAgICB0YWN0aWNhbDogJ2NvbWJpbmHDp8O1ZXMgZSB0w6F0aWNhcyBjb21wbGV4YXMnXG4gICAgfTtcblxuICAgIHJldHVybiBjaGFyYWN0ZXJpc3RpY3Nbc3R5bGVdIHx8ICdlc3RpbG8gZXF1aWxpYnJhZG8nO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdHlsZVRlbmRlbmN5KHN0eWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHRlbmRlbmNpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBhZ2dyZXNzaXZlOiAnYnVzY2FyIGluaWNpYXRpdmFzIGRlIGF0YXF1ZScsXG4gICAgICBkZWZlbnNpdmU6ICdmb3J0YWxlY2VyIHN1YSBwb3Npw6fDo28nLFxuICAgICAgcG9zaXRpb25hbDogJ2NvbnRyb2xhciBwb250b3MgZXN0cmF0w6lnaWNvcycsXG4gICAgICB0YWN0aWNhbDogJ2NyaWFyIGFtZWHDp2FzIHTDoXRpY2FzJ1xuICAgIH07XG5cbiAgICByZXR1cm4gdGVuZGVuY2llc1tzdHlsZV0gfHwgJ21hbnRlciB1bSBqb2dvIGVxdWlsaWJyYWRvJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RXZlbnREZXNjcmlwdGlvbih0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIEFHR1JFU1NJVkVfTU9WRTogJ01vdmltZW50byBhZ3Jlc3Npdm8gZGV0ZWN0YWRvJyxcbiAgICAgIFBPU0lUSU9OQUxfTU9WRTogJ01lbGhvcmlhIHBvc2ljaW9uYWwgc2lnbmlmaWNhdGl2YScsXG4gICAgICBUQUNUSUNBTF9NT1ZFOiAnQ29tYmluYcOnw6NvIHTDoXRpY2EgaWRlbnRpZmljYWRhJyxcbiAgICAgIFNUWUxFX0NIQU5HRUQ6IGBFc3RpbG8gYWx0ZXJhZG8gcGFyYSAke3RoaXMuY3VycmVudFN0eWxlfWAsXG4gICAgICBCUklMTElBTlRfTU9WRTogJ01vdmltZW50byBicmlsaGFudGUgZXhlY3V0YWRvJyxcbiAgICAgIENSSVRJQ0FMX1BPU0lUSU9OOiAnUG9zacOnw6NvIGNyw610aWNhIGFsY2Fuw6dhZGEnXG4gICAgfTtcblxuICAgIHJldHVybiBkZXNjcmlwdGlvbnNbdHlwZV0gfHwgJ0V2ZW50byBjdWx0dXJhbCBvY29ycmlkbyc7XG4gIH1cblxuICBwcml2YXRlIGdldEN1bHR1cmFsU3R5bGVOYXJyYXRpdmUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBuYXJyYXRpdmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgbWVkaWV2YWw6ICdTZXUgam9nbyByZWZsZXRlIGEgc29saWRleiBlIHRyYWRpw6fDo28gZG8geGFkcmV6IG1lZGlldmFsLicsXG4gICAgICByZW5haXNzYW5jZTogJ1ZvY8OqIGRlbW9uc3RyYSBhIGNyaWF0aXZpZGFkZSBlIGlub3Zhw6fDo28gZG8gcGVyw61vZG8gcmVuYXNjZW50aXN0YS4nLFxuICAgICAgbW9kZXJuOiAnU2V1IGVzdGlsbyBpbmNvcnBvcmEgcHJpbmPDrXBpb3MgbW9kZXJub3MgZGUgZmxleGliaWxpZGFkZSBlIHByYWdtYXRpc21vLicsXG4gICAgICBhbmNpZW50OiAnU3VhIGFib3JkYWdlbSBldm9jYSBhIHNhYmVkb3JpYSBlIHByb2Z1bmRpZGFkZSBkbyB4YWRyZXogYW50aWdvLidcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5hcnJhdGl2ZXNbdGhpcy5jdXJyZW50U3R5bGVdIHx8ICdTZXUgZXN0aWxvIMOpIMO6bmljbyBlIHBlc3NvYWwuJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3R5bGVSZWNvbW1lbmRhdGlvbihzdHlsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBhZ2dyZXNzaXZlOiAnUHJvY3VyZSBvcG9ydHVuaWRhZGVzIGRlIGF0YXF1ZSBkaXJldG8gYW8gcmVpIGFkdmVyc8OhcmlvJyxcbiAgICAgIGRlZmVuc2l2ZTogJ0ZvcnRhbGXDp2Egc3VhIGVzdHJ1dHVyYSBkZSBwZcO1ZXMgZSBzZWd1cmFuw6dhIGRvIHJlaScsXG4gICAgICBwb3NpdGlvbmFsOiAnRm9xdWUgbm8gY29udHJvbGUgZG8gY2VudHJvIGUgcG9zaWNpb25hbWVudG8gZGUgcGXDp2FzJyxcbiAgICAgIHRhY3RpY2FsOiAnQnVzcXVlIGNvbWJpbmHDp8O1ZXMgZSB0cm9jYXMgZmF2b3LDoXZlaXMnXG4gICAgfTtcblxuICAgIHJldHVybiByZWNvbW1lbmRhdGlvbnNbc3R5bGVdIHx8ICdNYW50ZW5oYSB1bSBqb2dvIGVxdWlsaWJyYWRvJztcbiAgfVxuXG4gIC8vIE3DqXRvZG9zIGRlIGF2YWxpYcOnw6NvIGVzcGVjw61maWNvc1xuICBwcml2YXRlIGlzQXR0YWNraW5nQ2VudGVyUGllY2VzKG1vdmU6IENoZXNzTW92ZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNlbnRlclNxdWFyZXMgPSBbXG4gICAgICB7IHJvdzogMywgY29sOiAzIH0sIHsgcm93OiAzLCBjb2w6IDQgfSxcbiAgICAgIHsgcm93OiA0LCBjb2w6IDMgfSwgeyByb3c6IDQsIGNvbDogNCB9XG4gICAgXTtcbiAgICByZXR1cm4gY2VudGVyU3F1YXJlcy5zb21lKHNxdWFyZSA9PlxuICAgICAgc3F1YXJlLnJvdyA9PT0gbW92ZS50by5yb3cgJiYgc3F1YXJlLmNvbCA9PT0gbW92ZS50by5jb2xcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpbXByb3Zlc1Bvc2l0aW9uKG1vdmU6IENoZXNzTW92ZSk6IGJvb2xlYW4ge1xuICAgIC8vIFZlcmlmaWNhIHNlIG8gbW92aW1lbnRvIG1lbGhvcmEgYSBwb3Npw6fDo28gZGEgcGXDp2FcbiAgICBjb25zdCBmcm9tU2NvcmUgPSB0aGlzLmdldFNxdWFyZVZhbHVlKG1vdmUuZnJvbSk7XG4gICAgY29uc3QgdG9TY29yZSA9IHRoaXMuZ2V0U3F1YXJlVmFsdWUobW92ZS50byk7XG4gICAgcmV0dXJuIHRvU2NvcmUgPiBmcm9tU2NvcmU7XG4gIH1cblxuICBwcml2YXRlIGNvbnRyb2xzSW1wb3J0YW50U3F1YXJlcyhtb3ZlOiBDaGVzc01vdmUpOiBib29sZWFuIHtcbiAgICAvLyBWZXJpZmljYSBzZSBvIG1vdmltZW50byBjb250cm9sYSBjYXNhcyBpbXBvcnRhbnRlc1xuICAgIGNvbnN0IGF0dGFja3MgPSB0aGlzLmdldFBvc3NpYmxlTW92ZXMobW92ZS50byk7XG4gICAgcmV0dXJuIGF0dGFja3Muc29tZShhdHRhY2sgPT4gdGhpcy5pc0ltcG9ydGFudFNxdWFyZShhdHRhY2sudG8pKTtcbiAgfVxuXG4gIHByaXZhdGUgaW1wcm92ZXNQYXduU3RydWN0dXJlKG1vdmU6IENoZXNzTW92ZSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGFuw6FsaXNlIGRlIGVzdHJ1dHVyYSBkZSBwZcO1ZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZXNUaHJlYXQobW92ZTogQ2hlc3NNb3ZlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgY2xvbmUubWFrZU1vdmUobW92ZS5mcm9tLCBtb3ZlLnRvKTtcbiAgICByZXR1cm4gY2xvbmUuaXNDaGVjaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVzRm9yayhtb3ZlOiBDaGVzc01vdmUpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnRhciBkZXRlY8Onw6NvIGRlIGdhcmZvXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVzUGluKG1vdmU6IENoZXNzTW92ZSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGRldGVjw6fDo28gZGUgY3JhdmFkYVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgaXNEZWZlbnNpdmVNb3ZlKG1vdmU6IENoZXNzTW92ZSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudGFyIGRldGVjw6fDo28gZGUgbW92aW1lbnRvIGRlZmVuc2l2b1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3F1YXJlVmFsdWUocG9zaXRpb246IENoZXNzUG9zaXRpb24pOiBudW1iZXIge1xuICAgIC8vIFZhbG9yZXMgZGFzIGNhc2FzIGRvIHRhYnVsZWlybyAoY2VudHJvIHZhbGUgbWFpcylcbiAgICBjb25zdCBzcXVhcmVWYWx1ZXMgPSBbXG4gICAgICBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICBbMCwgMSwgMSwgMSwgMSwgMSwgMSwgMF0sXG4gICAgICBbMCwgMSwgMiwgMiwgMiwgMiwgMSwgMF0sXG4gICAgICBbMCwgMSwgMiwgMywgMywgMiwgMSwgMF0sXG4gICAgICBbMCwgMSwgMiwgMywgMywgMiwgMSwgMF0sXG4gICAgICBbMCwgMSwgMiwgMiwgMiwgMiwgMSwgMF0sXG4gICAgICBbMCwgMSwgMSwgMSwgMSwgMSwgMSwgMF0sXG4gICAgICBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICBdO1xuXG4gICAgcmV0dXJuIHNxdWFyZVZhbHVlc1twb3NpdGlvbi5yb3ddW3Bvc2l0aW9uLmNvbF07XG4gIH1cblxuICBwcml2YXRlIGlzSW1wb3J0YW50U3F1YXJlKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3F1YXJlVmFsdWUocG9zaXRpb24pID49IDI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDaGVzc0VuZ2luZUJhc2UiLCJDVUxUVVJBTF9TVFlMRVMiLCJDVUxUVVJBTF9FVkVOVFMiLCJDdWx0dXJhbENoZXNzRW5naW5lIiwic2V0Q3VsdHVyYWxTdHlsZSIsInN0eWxlIiwiRXJyb3IiLCJjdXJyZW50U3R5bGUiLCJ0cmlnZ2VyQ3VsdHVyYWxFdmVudCIsImdldEN1bHR1cmFsTmFycmF0aXZlIiwibmFycmF0aXZlcyIsInJlY2VudE1vdmVzIiwicGxheVN0eWxlSGlzdG9yeSIsInNsaWNlIiwic3R5bGVBbmFseXNpcyIsImFuYWx5emVQbGF5U3R5bGUiLCJwdXNoIiwiZG9taW5hbnRTdHlsZSIsImdldFN0eWxlQ2hhcmFjdGVyaXN0aWNzIiwibGVuZ3RoIiwicmVjZW50U3R5bGUiLCJhbmFseXplTW92ZVNlcXVlbmNlIiwiZ2V0U3R5bGVUZW5kZW5jeSIsImdldEN1bHR1cmFsU3R5bGVOYXJyYXRpdmUiLCJnZXRTdHlsZUJhc2VkRXZhbHVhdGlvbiIsImJhc2VFdmFsdWF0aW9uIiwiZXZhbHVhdGVQb3NpdGlvbiIsInN0eWxlTW9kaWZpZXIiLCJnZXRTdHlsZU1vZGlmaWVyIiwibW9kaWZpZWRFdmFsdWF0aW9uIiwiZXZhbHVhdGlvbiIsImV4cGxhbmF0aW9uIiwiZ2V0U3R5bGVFdmFsdWF0aW9uIiwidHlwZSIsImV2ZW50IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImRlc2NyaXB0aW9uIiwiZ2V0RXZlbnREZXNjcmlwdGlvbiIsImN1bHR1cmFsRXZlbnRzIiwiZW1pdEV2ZW50IiwiZ2V0Q3VsdHVyYWxFdmVudEhpc3RvcnkiLCJtZXRyaWNzIiwiY2FsY3VsYXRlU3R5bGVNZXRyaWNzIiwiZmluZERvbWluYW50U3R5bGUiLCJyZWNvbW1lbmRhdGlvbnMiLCJnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyIsInN0eWxlTWV0cmljcyIsImFuYWx5emVNb3ZlU3R5bGUiLCJtb3ZlIiwiaXNBZ2dyZXNzaXZlIiwiaXNBZ2dyZXNzaXZlTW92ZSIsImlzUG9zaXRpb25hbCIsImlzUG9zaXRpb25hbE1vdmUiLCJpc1RhY3RpY2FsIiwiaXNUYWN0aWNhbE1vdmUiLCJtb3ZlcyIsImFnZ3Jlc3NpdmVDb3VudCIsInBvc2l0aW9uYWxDb3VudCIsInRhY3RpY2FsQ291bnQiLCJmb3JFYWNoIiwidG90YWwiLCJzY29yZXMiLCJhZ2dyZXNzaXZlIiwicG9zaXRpb25hbCIsInRhY3RpY2FsIiwiT2JqZWN0IiwiZW50cmllcyIsInJlZHVjZSIsImEiLCJiIiwiQm9vbGVhbiIsImNhcHR1cmVkIiwiaXNDaGVjayIsImlzQXR0YWNraW5nQ2VudGVyUGllY2VzIiwiaW1wcm92ZXNQb3NpdGlvbiIsImNvbnRyb2xzSW1wb3J0YW50U3F1YXJlcyIsImltcHJvdmVzUGF3blN0cnVjdHVyZSIsImNyZWF0ZXNUaHJlYXQiLCJjcmVhdGVzRm9yayIsImNyZWF0ZXNQaW4iLCJkZWZlbnNpdmUiLCJpc0RlZmVuc2l2ZU1vdmUiLCJ2YWx1ZXMiLCJrZXlzIiwia2V5IiwiZmlsdGVyIiwic29ydCIsInZhbHVlIiwiZ2V0U3R5bGVSZWNvbW1lbmRhdGlvbiIsIm1vZGlmaWVycyIsIm1lZGlldmFsIiwicmVuYWlzc2FuY2UiLCJtb2Rlcm4iLCJhbmNpZW50IiwiY2hhcmFjdGVyaXN0aWNzIiwidGVuZGVuY2llcyIsImRlc2NyaXB0aW9ucyIsIkFHR1JFU1NJVkVfTU9WRSIsIlBPU0lUSU9OQUxfTU9WRSIsIlRBQ1RJQ0FMX01PVkUiLCJTVFlMRV9DSEFOR0VEIiwiQlJJTExJQU5UX01PVkUiLCJDUklUSUNBTF9QT1NJVElPTiIsImNlbnRlclNxdWFyZXMiLCJyb3ciLCJjb2wiLCJzb21lIiwic3F1YXJlIiwidG8iLCJmcm9tU2NvcmUiLCJnZXRTcXVhcmVWYWx1ZSIsImZyb20iLCJ0b1Njb3JlIiwiYXR0YWNrcyIsImdldFBvc3NpYmxlTW92ZXMiLCJhdHRhY2siLCJpc0ltcG9ydGFudFNxdWFyZSIsImNsb25lIiwibWFrZU1vdmUiLCJwb3NpdGlvbiIsInNxdWFyZVZhbHVlcyIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIm9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/shared/engine/CulturalChessEngine.ts\n"));

/***/ }),

/***/ "./src/shared/engine/monitoring/ArquimaxMonitor.ts":
/*!*********************************************************!*\
  !*** ./src/shared/engine/monitoring/ArquimaxMonitor.ts ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArquimaxMonitor\": function() { return /* binding */ ArquimaxMonitor; }\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/next/dist/compiled/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n/**\n * Sistema de monitoramento ARQUIMAX para o motor de xadrez.\n * \n * Responsvel por:\n * - Coleta de mtricas em tempo real\n * - Verificaes de sade do sistema\n * - Monitoramento de performance\n * - Logs de eventos\n */ class ArquimaxMonitor {\n    /**\n   * Registra um evento do motor de xadrez.\n   * \n   * @param event - Evento a ser registrado\n   */ recordEvent(event) {\n        this.eventEmitter.emit(\"engine-event\", event);\n        if (event.type === \"MOVE_MADE\") {\n            this.moveCount++;\n            this.updateMovesPerSecond();\n        }\n    }\n    /**\n   * Realiza verificao de sade do sistema.\n   * \n   * @returns Status atual de sade do sistema\n   */ checkHealth() {\n        const now = Date.now();\n        // Atualiza mtricas apenas se passou o intervalo definido\n        if (now - this.lastHealthCheck >= this.healthCheckInterval) {\n            this.updateMetrics();\n            this.lastHealthCheck = now;\n        }\n        return {\n            status: this.evaluateHealth(),\n            metrics: this.metrics,\n            timestamp: now\n        };\n    }\n    /**\n   * Obtm mtricas atuais do sistema.\n   * \n   * @returns Mtricas coletadas\n   */ getMetrics() {\n        return {\n            ...this.metrics\n        };\n    }\n    recordCacheAccess(hit) {\n        this.cacheAccesses++;\n        if (hit) this.cacheHits++;\n        this.metrics.cacheHitRate = this.cacheHits / this.cacheAccesses;\n    }\n    /**\n   * Registra tempo de pensamento para um movimento.\n   * \n   * @param thinkingTime - Tempo em millisegundos\n   */ recordThinkingTime(thinkingTime) {\n        const current = this.metrics.averageThinkingTime;\n        this.metrics.averageThinkingTime = (current * this.moveCount + thinkingTime) / (this.moveCount + 1);\n    }\n    updateMovesPerSecond() {\n        const elapsedSeconds = (Date.now() - this.startTime) / 1000;\n        this.metrics.movesPerSecond = this.moveCount / elapsedSeconds;\n    }\n    async updateMetrics() {\n        // Atualiza uso de memria\n        if (process.memoryUsage) {\n            const { heapUsed  } = process.memoryUsage();\n            this.metrics.memoryUsage = heapUsed / 1024 / 1024; // Em MB\n        }\n        // Atualiza uso de CPU (implementao simplificada)\n        this.metrics.cpuUsage = await this.measureCPUUsage();\n    }\n    evaluateHealth() {\n        // Critrios de sade\n        const memoryThreshold = 512; // MB\n        const cpuThreshold = 80; // %\n        const moveRateThreshold = 0.5; // moves/sec\n        if (this.metrics.memoryUsage > memoryThreshold || this.metrics.cpuUsage > cpuThreshold) {\n            return \"unhealthy\";\n        }\n        // Sistema recm iniciado est saudvel por padro\n        if (this.moveCount === 0) {\n            return \"healthy\";\n        }\n        if (this.metrics.movesPerSecond < moveRateThreshold || this.metrics.cacheHitRate < 0.3 && this.moveCount > 10) {\n            return \"degraded\";\n        }\n        return \"healthy\";\n    }\n    async measureCPUUsage() {\n        // Implementao simplificada de medio de CPU\n        // Em uma implementao real, usaramos mtricas do sistema operacional\n        return new Promise((resolve)=>{\n            setTimeout(()=>{\n                // Simula medio de CPU entre 0-100%\n                resolve(Math.random() * 100);\n            }, 100);\n        });\n    }\n    constructor(){\n        /**\n   * Registra uso de cache.\n   * \n   * @param hit - true se houve hit no cache, false se houve miss\n   */ this.cacheHits = 0;\n        this.cacheAccesses = 0;\n        this.metrics = {\n            movesPerSecond: 0,\n            averageThinkingTime: 0,\n            cacheHitRate: 0,\n            memoryUsage: 0,\n            cpuUsage: 0\n        };\n        this.eventEmitter = new events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this.startTime = Date.now();\n        this.moveCount = 0;\n        this.lastHealthCheck = Date.now();\n        this.healthCheckInterval = 5000; // 5 segundos\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2VuZ2luZS9tb25pdG9yaW5nL0FycXVpbWF4TW9uaXRvci50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNDO0FBR3RDOzs7Ozs7OztDQVFDLEdBQ00sTUFBTUM7SUF1Qlg7Ozs7R0FJQyxHQUNELFlBQW1CRSxLQUFrQixFQUFRO1FBQzNDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsZ0JBQWdCRjtRQUV2QyxJQUFJQSxNQUFNRyxJQUFJLEtBQUssYUFBYTtZQUM5QixJQUFJLENBQUNDLFNBQVM7WUFDZCxJQUFJLENBQUNDLG9CQUFvQjtRQUMzQixDQUFDO0lBQ0g7SUFFQTs7OztHQUlDLEdBQ0QsY0FBbUM7UUFDakMsTUFBTUUsTUFBTUMsS0FBS0QsR0FBRztRQUVwQiwwREFBMEQ7UUFDMUQsSUFBSUEsTUFBTSxJQUFJLENBQUNFLGVBQWUsSUFBSSxJQUFJLENBQUNDLG1CQUFtQixFQUFFO1lBQzFELElBQUksQ0FBQ0MsYUFBYTtZQUNsQixJQUFJLENBQUNGLGVBQWUsR0FBR0Y7UUFDekIsQ0FBQztRQUVELE9BQU87WUFDTEssUUFBUSxJQUFJLENBQUNDLGNBQWM7WUFDM0JDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxXQUFXUjtRQUNiO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0QsYUFBbUM7UUFDakMsT0FBTztZQUFFLEdBQUcsSUFBSSxDQUFDTyxPQUFPO1FBQUM7SUFDM0I7SUFVT0csa0JBQWtCQyxHQUFZLEVBQVE7UUFDM0MsSUFBSSxDQUFDQyxhQUFhO1FBQ2xCLElBQUlELEtBQUssSUFBSSxDQUFDRSxTQUFTO1FBQ3ZCLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxZQUFZLEdBQUcsSUFBSSxDQUFDRCxTQUFTLEdBQUcsSUFBSSxDQUFDRCxhQUFhO0lBQ2pFO0lBRUE7Ozs7R0FJQyxHQUNELG1CQUEwQkksWUFBb0IsRUFBUTtRQUNwRCxNQUFNQyxVQUFVLElBQUksQ0FBQ1YsT0FBTyxDQUFDVyxtQkFBbUI7UUFDaEQsSUFBSSxDQUFDWCxPQUFPLENBQUNXLG1CQUFtQixHQUM5QixDQUFDRCxVQUFVLElBQUksQ0FBQ3BCLFNBQVMsR0FBR21CLFlBQVcsSUFBTSxLQUFJLENBQUNuQixTQUFTLEdBQUc7SUFDbEU7SUFFUUMsdUJBQTZCO1FBQ25DLE1BQU1xQixpQkFBaUIsQ0FBQ2xCLEtBQUtELEdBQUcsS0FBSyxJQUFJLENBQUNvQixTQUFTLElBQUk7UUFDdkQsSUFBSSxDQUFDYixPQUFPLENBQUNjLGNBQWMsR0FBRyxJQUFJLENBQUN4QixTQUFTLEdBQUdzQjtJQUNqRDtJQUVBLE1BQWNmLGdCQUErQjtRQUMzQywwQkFBMEI7UUFDMUIsSUFBSWtCLE9BQU9BLENBQUNDLFdBQVcsRUFBRTtZQUN2QixNQUFNLEVBQUVDLFNBQVEsRUFBRSxHQUFHRixPQUFPQSxDQUFDQyxXQUFXO1lBQ3hDLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ2dCLFdBQVcsR0FBR0MsV0FBVyxPQUFPLE1BQU0sUUFBUTtRQUM3RCxDQUFDO1FBRUQsbURBQW1EO1FBQ25ELElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ2tCLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQ0MsZUFBZTtJQUNwRDtJQUVRcEIsaUJBQXVEO1FBQzdELHFCQUFxQjtRQUNyQixNQUFNcUIsa0JBQWtCLEtBQUssS0FBSztRQUNsQyxNQUFNQyxlQUFlLElBQUksSUFBSTtRQUM3QixNQUFNQyxvQkFBb0IsS0FBSyxZQUFZO1FBRTNDLElBQ0UsSUFBSSxDQUFDdEIsT0FBTyxDQUFDZ0IsV0FBVyxHQUFHSSxtQkFDM0IsSUFBSSxDQUFDcEIsT0FBTyxDQUFDa0IsUUFBUSxHQUFHRyxjQUN4QjtZQUNBLE9BQU87UUFDVCxDQUFDO1FBRUQsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDL0IsU0FBUyxLQUFLLEdBQUc7WUFDeEIsT0FBTztRQUNULENBQUM7UUFFRCxJQUNFLElBQUksQ0FBQ1UsT0FBTyxDQUFDYyxjQUFjLEdBQUdRLHFCQUM3QixJQUFJLENBQUN0QixPQUFPLENBQUNPLFlBQVksR0FBRyxPQUFPLElBQUksQ0FBQ2pCLFNBQVMsR0FBRyxJQUNyRDtZQUNBLE9BQU87UUFDVCxDQUFDO1FBRUQsT0FBTztJQUNUO0lBRUEsTUFBYzZCLGtCQUFtQztRQUMvQywrQ0FBK0M7UUFDL0MsdUVBQXVFO1FBQ3ZFLE9BQU8sSUFBSUksUUFBUSxDQUFDQyxVQUFZO1lBQzlCQyxXQUFXLElBQU07Z0JBQ2YscUNBQXFDO2dCQUNyQ0QsUUFBUUUsS0FBS0MsTUFBTSxLQUFLO1lBQzFCLEdBQUc7UUFDTDtJQUNGO0lBeklBQyxhQUFjO1FBMkRkOzs7O0dBSUMsUUFDT3RCLFlBQW9CO2FBQ3BCRCxnQkFBd0I7UUFoRTlCLElBQUksQ0FBQ0wsT0FBTyxHQUFHO1lBQ2JjLGdCQUFnQjtZQUNoQkgscUJBQXFCO1lBQ3JCSixjQUFjO1lBQ2RTLGFBQWE7WUFDYkUsVUFBVTtRQUNaO1FBQ0EsSUFBSSxDQUFDL0IsWUFBWSxHQUFHLElBQUlKLGdEQUFZQTtRQUNwQyxJQUFJLENBQUM4QixTQUFTLEdBQUduQixLQUFLRCxHQUFHO1FBQ3pCLElBQUksQ0FBQ0gsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0ssZUFBZSxHQUFHRCxLQUFLRCxHQUFHO1FBQy9CLElBQUksQ0FBQ0csbUJBQW1CLEdBQUcsTUFBTSxhQUFhO0lBQ2hEO0FBNkhGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NoYXJlZC9lbmdpbmUvbW9uaXRvcmluZy9BcnF1aW1heE1vbml0b3IudHM/ZDgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgRW5naW5lRXZlbnQsIEVuZ2luZU1ldHJpY3MsIEhlYWx0aFN0YXR1cyB9IGZyb20gJy4uLy4uL3R5cGVzL2VuZ2luZSc7XG5cbi8qKlxuICogU2lzdGVtYSBkZSBtb25pdG9yYW1lbnRvIEFSUVVJTUFYIHBhcmEgbyBtb3RvciBkZSB4YWRyZXouXG4gKiBcbiAqIFJlc3BvbnPDoXZlbCBwb3I6XG4gKiAtIENvbGV0YSBkZSBtw6l0cmljYXMgZW0gdGVtcG8gcmVhbFxuICogLSBWZXJpZmljYcOnw7VlcyBkZSBzYcO6ZGUgZG8gc2lzdGVtYVxuICogLSBNb25pdG9yYW1lbnRvIGRlIHBlcmZvcm1hbmNlXG4gKiAtIExvZ3MgZGUgZXZlbnRvc1xuICovXG5leHBvcnQgY2xhc3MgQXJxdWltYXhNb25pdG9yIHtcbiAgcHJpdmF0ZSBtZXRyaWNzOiBFbmdpbmVNZXRyaWNzO1xuICBwcml2YXRlIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyO1xuICBwcml2YXRlIHN0YXJ0VGltZTogbnVtYmVyO1xuICBwcml2YXRlIG1vdmVDb3VudDogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RIZWFsdGhDaGVjazogbnVtYmVyO1xuICBwcml2YXRlIGhlYWx0aENoZWNrSW50ZXJ2YWw6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1ldHJpY3MgPSB7XG4gICAgICBtb3Zlc1BlclNlY29uZDogMCxcbiAgICAgIGF2ZXJhZ2VUaGlua2luZ1RpbWU6IDAsXG4gICAgICBjYWNoZUhpdFJhdGU6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMCxcbiAgICAgIGNwdVVzYWdlOiAwXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5tb3ZlQ291bnQgPSAwO1xuICAgIHRoaXMubGFzdEhlYWx0aENoZWNrID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwgPSA1MDAwOyAvLyA1IHNlZ3VuZG9zXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0cmEgdW0gZXZlbnRvIGRvIG1vdG9yIGRlIHhhZHJlei5cbiAgICogXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50byBhIHNlciByZWdpc3RyYWRvXG4gICAqL1xuICBwdWJsaWMgcmVjb3JkRXZlbnQoZXZlbnQ6IEVuZ2luZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZW5naW5lLWV2ZW50JywgZXZlbnQpO1xuICAgIFxuICAgIGlmIChldmVudC50eXBlID09PSAnTU9WRV9NQURFJykge1xuICAgICAgdGhpcy5tb3ZlQ291bnQrKztcbiAgICAgIHRoaXMudXBkYXRlTW92ZXNQZXJTZWNvbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhbGl6YSB2ZXJpZmljYcOnw6NvIGRlIHNhw7pkZSBkbyBzaXN0ZW1hLlxuICAgKiBcbiAgICogQHJldHVybnMgU3RhdHVzIGF0dWFsIGRlIHNhw7pkZSBkbyBzaXN0ZW1hXG4gICAqL1xuICBwdWJsaWMgY2hlY2tIZWFsdGgoKTogSGVhbHRoU3RhdHVzIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIEF0dWFsaXphIG3DqXRyaWNhcyBhcGVuYXMgc2UgcGFzc291IG8gaW50ZXJ2YWxvIGRlZmluaWRvXG4gICAgaWYgKG5vdyAtIHRoaXMubGFzdEhlYWx0aENoZWNrID49IHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy51cGRhdGVNZXRyaWNzKCk7XG4gICAgICB0aGlzLmxhc3RIZWFsdGhDaGVjayA9IG5vdztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiB0aGlzLmV2YWx1YXRlSGVhbHRoKCksXG4gICAgICBtZXRyaWNzOiB0aGlzLm1ldHJpY3MsXG4gICAgICB0aW1lc3RhbXA6IG5vd1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogT2J0w6ltIG3DqXRyaWNhcyBhdHVhaXMgZG8gc2lzdGVtYS5cbiAgICogXG4gICAqIEByZXR1cm5zIE3DqXRyaWNhcyBjb2xldGFkYXNcbiAgICovXG4gIHB1YmxpYyBnZXRNZXRyaWNzKCk6IEVuZ2luZU1ldHJpY3Mge1xuICAgIHJldHVybiB7IC4uLnRoaXMubWV0cmljcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdHJhIHVzbyBkZSBjYWNoZS5cbiAgICogXG4gICAqIEBwYXJhbSBoaXQgLSB0cnVlIHNlIGhvdXZlIGhpdCBubyBjYWNoZSwgZmFsc2Ugc2UgaG91dmUgbWlzc1xuICAgKi9cbiAgcHJpdmF0ZSBjYWNoZUhpdHM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY2FjaGVBY2Nlc3NlczogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgcmVjb3JkQ2FjaGVBY2Nlc3MoaGl0OiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZUFjY2Vzc2VzKys7XG4gICAgaWYgKGhpdCkgdGhpcy5jYWNoZUhpdHMrKztcbiAgICB0aGlzLm1ldHJpY3MuY2FjaGVIaXRSYXRlID0gdGhpcy5jYWNoZUhpdHMgLyB0aGlzLmNhY2hlQWNjZXNzZXM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0cmEgdGVtcG8gZGUgcGVuc2FtZW50byBwYXJhIHVtIG1vdmltZW50by5cbiAgICogXG4gICAqIEBwYXJhbSB0aGlua2luZ1RpbWUgLSBUZW1wbyBlbSBtaWxsaXNlZ3VuZG9zXG4gICAqL1xuICBwdWJsaWMgcmVjb3JkVGhpbmtpbmdUaW1lKHRoaW5raW5nVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMubWV0cmljcy5hdmVyYWdlVGhpbmtpbmdUaW1lO1xuICAgIHRoaXMubWV0cmljcy5hdmVyYWdlVGhpbmtpbmdUaW1lID0gXG4gICAgICAoY3VycmVudCAqIHRoaXMubW92ZUNvdW50ICsgdGhpbmtpbmdUaW1lKSAvICh0aGlzLm1vdmVDb3VudCArIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNb3Zlc1BlclNlY29uZCgpOiB2b2lkIHtcbiAgICBjb25zdCBlbGFwc2VkU2Vjb25kcyA9IChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMDtcbiAgICB0aGlzLm1ldHJpY3MubW92ZXNQZXJTZWNvbmQgPSB0aGlzLm1vdmVDb3VudCAvIGVsYXBzZWRTZWNvbmRzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVNZXRyaWNzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEF0dWFsaXphIHVzbyBkZSBtZW3Ds3JpYVxuICAgIGlmIChwcm9jZXNzLm1lbW9yeVVzYWdlKSB7XG4gICAgICBjb25zdCB7IGhlYXBVc2VkIH0gPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICB0aGlzLm1ldHJpY3MubWVtb3J5VXNhZ2UgPSBoZWFwVXNlZCAvIDEwMjQgLyAxMDI0OyAvLyBFbSBNQlxuICAgIH1cblxuICAgIC8vIEF0dWFsaXphIHVzbyBkZSBDUFUgKGltcGxlbWVudGHDp8OjbyBzaW1wbGlmaWNhZGEpXG4gICAgdGhpcy5tZXRyaWNzLmNwdVVzYWdlID0gYXdhaXQgdGhpcy5tZWFzdXJlQ1BVVXNhZ2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgZXZhbHVhdGVIZWFsdGgoKTogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknIHtcbiAgICAvLyBDcml0w6lyaW9zIGRlIHNhw7pkZVxuICAgIGNvbnN0IG1lbW9yeVRocmVzaG9sZCA9IDUxMjsgLy8gTUJcbiAgICBjb25zdCBjcHVUaHJlc2hvbGQgPSA4MDsgLy8gJVxuICAgIGNvbnN0IG1vdmVSYXRlVGhyZXNob2xkID0gMC41OyAvLyBtb3Zlcy9zZWNcblxuICAgIGlmIChcbiAgICAgIHRoaXMubWV0cmljcy5tZW1vcnlVc2FnZSA+IG1lbW9yeVRocmVzaG9sZCB8fFxuICAgICAgdGhpcy5tZXRyaWNzLmNwdVVzYWdlID4gY3B1VGhyZXNob2xkXG4gICAgKSB7XG4gICAgICByZXR1cm4gJ3VuaGVhbHRoeSc7XG4gICAgfVxuXG4gICAgLy8gU2lzdGVtYSByZWPDqW0gaW5pY2lhZG8gZXN0w6Egc2F1ZMOhdmVsIHBvciBwYWRyw6NvXG4gICAgaWYgKHRoaXMubW92ZUNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gJ2hlYWx0aHknO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMubWV0cmljcy5tb3Zlc1BlclNlY29uZCA8IG1vdmVSYXRlVGhyZXNob2xkIHx8XG4gICAgICAodGhpcy5tZXRyaWNzLmNhY2hlSGl0UmF0ZSA8IDAuMyAmJiB0aGlzLm1vdmVDb3VudCA+IDEwKVxuICAgICkge1xuICAgICAgcmV0dXJuICdkZWdyYWRlZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdoZWFsdGh5JztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbWVhc3VyZUNQVVVzYWdlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgLy8gSW1wbGVtZW50YcOnw6NvIHNpbXBsaWZpY2FkYSBkZSBtZWRpw6fDo28gZGUgQ1BVXG4gICAgLy8gRW0gdW1hIGltcGxlbWVudGHDp8OjbyByZWFsLCB1c2Fyw61hbW9zIG3DqXRyaWNhcyBkbyBzaXN0ZW1hIG9wZXJhY2lvbmFsXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gU2ltdWxhIG1lZGnDp8OjbyBkZSBDUFUgZW50cmUgMC0xMDAlXG4gICAgICAgIHJlc29sdmUoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiQXJxdWltYXhNb25pdG9yIiwicmVjb3JkRXZlbnQiLCJldmVudCIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJ0eXBlIiwibW92ZUNvdW50IiwidXBkYXRlTW92ZXNQZXJTZWNvbmQiLCJjaGVja0hlYWx0aCIsIm5vdyIsIkRhdGUiLCJsYXN0SGVhbHRoQ2hlY2siLCJoZWFsdGhDaGVja0ludGVydmFsIiwidXBkYXRlTWV0cmljcyIsInN0YXR1cyIsImV2YWx1YXRlSGVhbHRoIiwibWV0cmljcyIsInRpbWVzdGFtcCIsImdldE1ldHJpY3MiLCJyZWNvcmRDYWNoZUFjY2VzcyIsImhpdCIsImNhY2hlQWNjZXNzZXMiLCJjYWNoZUhpdHMiLCJjYWNoZUhpdFJhdGUiLCJyZWNvcmRUaGlua2luZ1RpbWUiLCJ0aGlua2luZ1RpbWUiLCJjdXJyZW50IiwiYXZlcmFnZVRoaW5raW5nVGltZSIsImVsYXBzZWRTZWNvbmRzIiwic3RhcnRUaW1lIiwibW92ZXNQZXJTZWNvbmQiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJoZWFwVXNlZCIsImNwdVVzYWdlIiwibWVhc3VyZUNQVVVzYWdlIiwibWVtb3J5VGhyZXNob2xkIiwiY3B1VGhyZXNob2xkIiwibW92ZVJhdGVUaHJlc2hvbGQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJNYXRoIiwicmFuZG9tIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shared/engine/monitoring/ArquimaxMonitor.ts\n"));

/***/ }),

/***/ "./src/shared/utils/chess.ts":
/*!***********************************!*\
  !*** ./src/shared/utils/chess.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"algebraicToCoords\": function() { return /* binding */ algebraicToCoords; },\n/* harmony export */   \"coordsToAlgebraic\": function() { return /* binding */ coordsToAlgebraic; },\n/* harmony export */   \"formatMove\": function() { return /* binding */ formatMove; },\n/* harmony export */   \"getAllSquares\": function() { return /* binding */ getAllSquares; },\n/* harmony export */   \"getHighlightedSquares\": function() { return /* binding */ getHighlightedSquares; },\n/* harmony export */   \"getMoveDirection\": function() { return /* binding */ getMoveDirection; },\n/* harmony export */   \"getPathBetween\": function() { return /* binding */ getPathBetween; },\n/* harmony export */   \"getPieceSymbol\": function() { return /* binding */ getPieceSymbol; },\n/* harmony export */   \"getSquareColor\": function() { return /* binding */ getSquareColor; },\n/* harmony export */   \"getSquareDistance\": function() { return /* binding */ getSquareDistance; },\n/* harmony export */   \"isDiagonalMove\": function() { return /* binding */ isDiagonalMove; },\n/* harmony export */   \"isOrthogonalMove\": function() { return /* binding */ isOrthogonalMove; },\n/* harmony export */   \"isSamePosition\": function() { return /* binding */ isSamePosition; },\n/* harmony export */   \"isValidPosition\": function() { return /* binding */ isValidPosition; }\n/* harmony export */ });\n/* harmony import */ var _constants_game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/game */ \"./src/shared/constants/game.ts\");\n\n/**\n * Converte coordenadas algbricas (ex: \"e4\") para coordenadas internas (row, col)\n */ function algebraicToCoords(square) {\n    const col = square.charCodeAt(0) - \"a\".charCodeAt(0);\n    const row = _constants_game__WEBPACK_IMPORTED_MODULE_0__.BOARD_SIZE - parseInt(square[1]);\n    return {\n        row,\n        col\n    };\n}\n/**\n * Converte coordenadas internas (row, col) para notao algbrica (ex: \"e4\")\n */ function coordsToAlgebraic(position) {\n    const { row , col  } = position;\n    const file = String.fromCharCode(\"a\".charCodeAt(0) + col);\n    const rank = _constants_game__WEBPACK_IMPORTED_MODULE_0__.BOARD_SIZE - row;\n    return \"\".concat(file).concat(rank);\n}\n/**\n * Verifica se uma posio est dentro do tabuleiro\n */ function isValidPosition(position) {\n    const { row , col  } = position;\n    return row >= 0 && row < _constants_game__WEBPACK_IMPORTED_MODULE_0__.BOARD_SIZE && col >= 0 && col < _constants_game__WEBPACK_IMPORTED_MODULE_0__.BOARD_SIZE;\n}\n/**\n * Compara duas posies\n */ function isSamePosition(a, b) {\n    return a.row === b.row && a.col === b.col;\n}\n/**\n * Retorna a cor de uma casa do tabuleiro\n */ function getSquareColor(row, col) {\n    return (row + col) % 2 === 0 ? \"light\" : \"dark\";\n}\n/**\n * Retorna o smbolo Unicode para uma pea\n */ function getPieceSymbol(piece) {\n    const symbol = piece.color === \"white\" ? piece.type.toUpperCase() : piece.type.toLowerCase();\n    return _constants_game__WEBPACK_IMPORTED_MODULE_0__.PIECE_SYMBOLS[symbol] || \"\";\n}\n/**\n * Gera array com todas as posies do tabuleiro\n */ function getAllSquares() {\n    const squares = [];\n    for(let row = 0; row < _constants_game__WEBPACK_IMPORTED_MODULE_0__.BOARD_SIZE; row++){\n        for(let col = 0; col < _constants_game__WEBPACK_IMPORTED_MODULE_0__.BOARD_SIZE; col++){\n            squares.push({\n                row,\n                col\n            });\n        }\n    }\n    return squares;\n}\n/**\n * Retorna as coordenadas das casas destacadas para um movimento\n */ function getHighlightedSquares(selectedSquare, lastMove, possibleMoves) {\n    return {\n        selected: selectedSquare,\n        lastMove,\n        possible: possibleMoves\n    };\n}\n/**\n * Retorna a distncia entre duas casas\n */ function getSquareDistance(a, b) {\n    const rowDiff = Math.abs(a.row - b.row);\n    const colDiff = Math.abs(a.col - b.col);\n    return Math.max(rowDiff, colDiff);\n}\n/**\n * Retorna a direo do movimento entre duas casas\n */ function getMoveDirection(from, to) {\n    const rowDir = Math.sign(to.row - from.row);\n    const colDir = Math.sign(to.col - from.col);\n    return {\n        rowDir,\n        colDir\n    };\n}\n/**\n * Verifica se um movimento  diagonal\n */ function isDiagonalMove(from, to) {\n    const rowDiff = Math.abs(to.row - from.row);\n    const colDiff = Math.abs(to.col - from.col);\n    return rowDiff === colDiff && rowDiff > 0;\n}\n/**\n * Verifica se um movimento  ortogonal (horizontal ou vertical)\n */ function isOrthogonalMove(from, to) {\n    return from.row === to.row && from.col !== to.col || from.col === to.col && from.row !== to.row;\n}\n/**\n * Calcula o caminho entre duas casas (para verificar obstrues)\n */ function getPathBetween(from, to) {\n    const path = [];\n    const { rowDir , colDir  } = getMoveDirection(from, to);\n    let { row , col  } = from;\n    while(row !== to.row || col !== to.col){\n        row += rowDir;\n        col += colDir;\n        if (row === to.row && col === to.col) break;\n        path.push({\n            row,\n            col\n        });\n    }\n    return path;\n}\n/**\n * Formata um movimento para notao algbrica\n */ function formatMove(from, to, piece, capture, promotion) {\n    const fromSquare = coordsToAlgebraic(from);\n    const toSquare = coordsToAlgebraic(to);\n    const pieceSymbol = piece.type.toUpperCase();\n    const captureSymbol = capture ? \"x\" : \"\";\n    const promotionSymbol = promotion ? \"=\".concat(promotion.toUpperCase()) : \"\";\n    return \"\".concat(pieceSymbol).concat(fromSquare).concat(captureSymbol).concat(toSquare).concat(promotionSymbol);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxDQUFDO1lBQUV0QjtZQUFLRjtRQUFJO0lBQ3ZCO0lBRUEsT0FBTzhDO0FBQ1QsQ0FBQztBQUVEOztDQUVDLEdBQ00sU0FBU0MsV0FDZFQsSUFBbUIsRUFDbkJDLEVBQWlCLEVBQ2pCdkIsS0FBaUIsRUFDakJnQyxPQUFpQixFQUNqQkMsU0FBa0IsRUFDVjtJQUNSLE1BQU1DLGFBQWE5QyxrQkFBa0JrQztJQUNyQyxNQUFNYSxXQUFXL0Msa0JBQWtCbUM7SUFDbkMsTUFBTWEsY0FBY3BDLE1BQU1HLElBQUksQ0FBQ0MsV0FBVztJQUMxQyxNQUFNaUMsZ0JBQWdCTCxVQUFVLE1BQU0sRUFBRTtJQUN4QyxNQUFNTSxrQkFBa0JMLFlBQVksSUFBNEIsT0FBeEJBLFVBQVU3QixXQUFXLE1BQU8sRUFBRTtJQUV0RSxPQUFPLEdBQWlCOEIsT0FBZEUsYUFBMkJDLE9BQWJILFlBQTZCQyxPQUFoQkUsZUFBMkJDLE9BQVhILFVBQTJCLE9BQWhCRztBQUNsRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zaGFyZWQvdXRpbHMvY2hlc3MudHM/N2NmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVzc1Bvc2l0aW9uLCBDaGVzc1BpZWNlIH0gZnJvbSAnLi4vdHlwZXMvY2hlc3MnO1xuaW1wb3J0IHsgQk9BUkRfU0laRSwgUElFQ0VfU1lNQk9MUyB9IGZyb20gJy4uL2NvbnN0YW50cy9nYW1lJztcblxuLyoqXG4gKiBDb252ZXJ0ZSBjb29yZGVuYWRhcyBhbGfDqWJyaWNhcyAoZXg6IFwiZTRcIikgcGFyYSBjb29yZGVuYWRhcyBpbnRlcm5hcyAocm93LCBjb2wpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGdlYnJhaWNUb0Nvb3JkcyhzcXVhcmU6IHN0cmluZyk6IENoZXNzUG9zaXRpb24ge1xuICBjb25zdCBjb2wgPSBzcXVhcmUuY2hhckNvZGVBdCgwKSAtICdhJy5jaGFyQ29kZUF0KDApO1xuICBjb25zdCByb3cgPSBCT0FSRF9TSVpFIC0gcGFyc2VJbnQoc3F1YXJlWzFdKTtcbiAgcmV0dXJuIHsgcm93LCBjb2wgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0ZSBjb29yZGVuYWRhcyBpbnRlcm5hcyAocm93LCBjb2wpIHBhcmEgbm90YcOnw6NvIGFsZ8OpYnJpY2EgKGV4OiBcImU0XCIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0FsZ2VicmFpYyhwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgcm93LCBjb2wgfSA9IHBvc2l0aW9uO1xuICBjb25zdCBmaWxlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgnYScuY2hhckNvZGVBdCgwKSArIGNvbCk7XG4gIGNvbnN0IHJhbmsgPSBCT0FSRF9TSVpFIC0gcm93O1xuICByZXR1cm4gYCR7ZmlsZX0ke3Jhbmt9YDtcbn1cblxuLyoqXG4gKiBWZXJpZmljYSBzZSB1bWEgcG9zacOnw6NvIGVzdMOhIGRlbnRybyBkbyB0YWJ1bGVpcm9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbihwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICBjb25zdCB7IHJvdywgY29sIH0gPSBwb3NpdGlvbjtcbiAgcmV0dXJuIHJvdyA+PSAwICYmIHJvdyA8IEJPQVJEX1NJWkUgJiYgY29sID49IDAgJiYgY29sIDwgQk9BUkRfU0laRTtcbn1cblxuLyoqXG4gKiBDb21wYXJhIGR1YXMgcG9zacOnw7Vlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYW1lUG9zaXRpb24oYTogQ2hlc3NQb3NpdGlvbiwgYjogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gYS5yb3cgPT09IGIucm93ICYmIGEuY29sID09PSBiLmNvbDtcbn1cblxuLyoqXG4gKiBSZXRvcm5hIGEgY29yIGRlIHVtYSBjYXNhIGRvIHRhYnVsZWlyb1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1YXJlQ29sb3Iocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogJ2xpZ2h0JyB8ICdkYXJrJyB7XG4gIHJldHVybiAocm93ICsgY29sKSAlIDIgPT09IDAgPyAnbGlnaHQnIDogJ2RhcmsnO1xufVxuXG4vKipcbiAqIFJldG9ybmEgbyBzw61tYm9sbyBVbmljb2RlIHBhcmEgdW1hIHBlw6dhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWVjZVN5bWJvbChwaWVjZTogQ2hlc3NQaWVjZSk6IHN0cmluZyB7XG4gIGNvbnN0IHN5bWJvbCA9IHBpZWNlLmNvbG9yID09PSAnd2hpdGUnIFxuICAgID8gcGllY2UudHlwZS50b1VwcGVyQ2FzZSgpIFxuICAgIDogcGllY2UudHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gUElFQ0VfU1lNQk9MU1tzeW1ib2xdIHx8ICcnO1xufVxuXG4vKipcbiAqIEdlcmEgYXJyYXkgY29tIHRvZGFzIGFzIHBvc2nDp8O1ZXMgZG8gdGFidWxlaXJvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxTcXVhcmVzKCk6IENoZXNzUG9zaXRpb25bXSB7XG4gIGNvbnN0IHNxdWFyZXM6IENoZXNzUG9zaXRpb25bXSA9IFtdO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBCT0FSRF9TSVpFOyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEJPQVJEX1NJWkU7IGNvbCsrKSB7XG4gICAgICBzcXVhcmVzLnB1c2goeyByb3csIGNvbCB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNxdWFyZXM7XG59XG5cbi8qKlxuICogUmV0b3JuYSBhcyBjb29yZGVuYWRhcyBkYXMgY2FzYXMgZGVzdGFjYWRhcyBwYXJhIHVtIG1vdmltZW50b1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZWRTcXVhcmVzKFxuICBzZWxlY3RlZFNxdWFyZTogQ2hlc3NQb3NpdGlvbiB8IG51bGwsXG4gIGxhc3RNb3ZlOiB7IGZyb206IENoZXNzUG9zaXRpb247IHRvOiBDaGVzc1Bvc2l0aW9uIH0gfCBudWxsLFxuICBwb3NzaWJsZU1vdmVzOiBDaGVzc1Bvc2l0aW9uW11cbik6IHtcbiAgc2VsZWN0ZWQ6IENoZXNzUG9zaXRpb24gfCBudWxsO1xuICBsYXN0TW92ZTogeyBmcm9tOiBDaGVzc1Bvc2l0aW9uOyB0bzogQ2hlc3NQb3NpdGlvbiB9IHwgbnVsbDtcbiAgcG9zc2libGU6IENoZXNzUG9zaXRpb25bXTtcbn0ge1xuICByZXR1cm4ge1xuICAgIHNlbGVjdGVkOiBzZWxlY3RlZFNxdWFyZSxcbiAgICBsYXN0TW92ZSxcbiAgICBwb3NzaWJsZTogcG9zc2libGVNb3ZlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXRvcm5hIGEgZGlzdMOibmNpYSBlbnRyZSBkdWFzIGNhc2FzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcXVhcmVEaXN0YW5jZShhOiBDaGVzc1Bvc2l0aW9uLCBiOiBDaGVzc1Bvc2l0aW9uKTogbnVtYmVyIHtcbiAgY29uc3Qgcm93RGlmZiA9IE1hdGguYWJzKGEucm93IC0gYi5yb3cpO1xuICBjb25zdCBjb2xEaWZmID0gTWF0aC5hYnMoYS5jb2wgLSBiLmNvbCk7XG4gIHJldHVybiBNYXRoLm1heChyb3dEaWZmLCBjb2xEaWZmKTtcbn1cblxuLyoqXG4gKiBSZXRvcm5hIGEgZGlyZcOnw6NvIGRvIG1vdmltZW50byBlbnRyZSBkdWFzIGNhc2FzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3ZlRGlyZWN0aW9uKFxuICBmcm9tOiBDaGVzc1Bvc2l0aW9uLFxuICB0bzogQ2hlc3NQb3NpdGlvblxuKTogeyByb3dEaXI6IG51bWJlcjsgY29sRGlyOiBudW1iZXIgfSB7XG4gIGNvbnN0IHJvd0RpciA9IE1hdGguc2lnbih0by5yb3cgLSBmcm9tLnJvdyk7XG4gIGNvbnN0IGNvbERpciA9IE1hdGguc2lnbih0by5jb2wgLSBmcm9tLmNvbCk7XG4gIHJldHVybiB7IHJvd0RpciwgY29sRGlyIH07XG59XG5cbi8qKlxuICogVmVyaWZpY2Egc2UgdW0gbW92aW1lbnRvIMOpIGRpYWdvbmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RpYWdvbmFsTW92ZShmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICBjb25zdCByb3dEaWZmID0gTWF0aC5hYnModG8ucm93IC0gZnJvbS5yb3cpO1xuICBjb25zdCBjb2xEaWZmID0gTWF0aC5hYnModG8uY29sIC0gZnJvbS5jb2wpO1xuICByZXR1cm4gcm93RGlmZiA9PT0gY29sRGlmZiAmJiByb3dEaWZmID4gMDtcbn1cblxuLyoqXG4gKiBWZXJpZmljYSBzZSB1bSBtb3ZpbWVudG8gw6kgb3J0b2dvbmFsIChob3Jpem9udGFsIG91IHZlcnRpY2FsKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcnRob2dvbmFsTW92ZShmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKGZyb20ucm93ID09PSB0by5yb3cgJiYgZnJvbS5jb2wgIT09IHRvLmNvbCkgfHxcbiAgICAgICAgIChmcm9tLmNvbCA9PT0gdG8uY29sICYmIGZyb20ucm93ICE9PSB0by5yb3cpO1xufVxuXG4vKipcbiAqIENhbGN1bGEgbyBjYW1pbmhvIGVudHJlIGR1YXMgY2FzYXMgKHBhcmEgdmVyaWZpY2FyIG9ic3RydcOnw7VlcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhCZXR3ZWVuKFxuICBmcm9tOiBDaGVzc1Bvc2l0aW9uLFxuICB0bzogQ2hlc3NQb3NpdGlvblxuKTogQ2hlc3NQb3NpdGlvbltdIHtcbiAgY29uc3QgcGF0aDogQ2hlc3NQb3NpdGlvbltdID0gW107XG4gIGNvbnN0IHsgcm93RGlyLCBjb2xEaXIgfSA9IGdldE1vdmVEaXJlY3Rpb24oZnJvbSwgdG8pO1xuICBsZXQgeyByb3csIGNvbCB9ID0gZnJvbTtcblxuICB3aGlsZSAocm93ICE9PSB0by5yb3cgfHwgY29sICE9PSB0by5jb2wpIHtcbiAgICByb3cgKz0gcm93RGlyO1xuICAgIGNvbCArPSBjb2xEaXI7XG4gICAgaWYgKHJvdyA9PT0gdG8ucm93ICYmIGNvbCA9PT0gdG8uY29sKSBicmVhaztcbiAgICBwYXRoLnB1c2goeyByb3csIGNvbCB9KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG4vKipcbiAqIEZvcm1hdGEgdW0gbW92aW1lbnRvIHBhcmEgbm90YcOnw6NvIGFsZ8OpYnJpY2FcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE1vdmUoXG4gIGZyb206IENoZXNzUG9zaXRpb24sXG4gIHRvOiBDaGVzc1Bvc2l0aW9uLFxuICBwaWVjZTogQ2hlc3NQaWVjZSxcbiAgY2FwdHVyZT86IGJvb2xlYW4sXG4gIHByb21vdGlvbj86IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgZnJvbVNxdWFyZSA9IGNvb3Jkc1RvQWxnZWJyYWljKGZyb20pO1xuICBjb25zdCB0b1NxdWFyZSA9IGNvb3Jkc1RvQWxnZWJyYWljKHRvKTtcbiAgY29uc3QgcGllY2VTeW1ib2wgPSBwaWVjZS50eXBlLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IGNhcHR1cmVTeW1ib2wgPSBjYXB0dXJlID8gJ3gnIDogJyc7XG4gIGNvbnN0IHByb21vdGlvblN5bWJvbCA9IHByb21vdGlvbiA/IGA9JHtwcm9tb3Rpb24udG9VcHBlckNhc2UoKX1gIDogJyc7XG5cbiAgcmV0dXJuIGAke3BpZWNlU3ltYm9sfSR7ZnJvbVNxdWFyZX0ke2NhcHR1cmVTeW1ib2x9JHt0b1NxdWFyZX0ke3Byb21vdGlvblN5bWJvbH1gO1xufVxuIl0sIm5hbWVzIjpbIkJPQVJEX1NJWkUiLCJQSUVDRV9TWU1CT0xTIiwiYWxnZWJyYWljVG9Db29yZHMiLCJzcXVhcmUiLCJjb2wiLCJjaGFyQ29kZUF0Iiwicm93IiwicGFyc2VJbnQiLCJjb29yZHNUb0FsZ2VicmFpYyIsInBvc2l0aW9uIiwiZmlsZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJhbmsiLCJpc1ZhbGlkUG9zaXRpb24iLCJpc1NhbWVQb3NpdGlvbiIsImEiLCJiIiwiZ2V0U3F1YXJlQ29sb3IiLCJnZXRQaWVjZVN5bWJvbCIsInBpZWNlIiwic3ltYm9sIiwiY29sb3IiLCJ0eXBlIiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImdldEFsbFNxdWFyZXMiLCJzcXVhcmVzIiwicHVzaCIsImdldEhpZ2hsaWdodGVkU3F1YXJlcyIsInNlbGVjdGVkU3F1YXJlIiwibGFzdE1vdmUiLCJwb3NzaWJsZU1vdmVzIiwic2VsZWN0ZWQiLCJwb3NzaWJsZSIsImdldFNxdWFyZURpc3RhbmNlIiwicm93RGlmZiIsIk1hdGgiLCJhYnMiLCJjb2xEaWZmIiwibWF4IiwiZ2V0TW92ZURpcmVjdGlvbiIsImZyb20iLCJ0byIsInJvd0RpciIsInNpZ24iLCJjb2xEaXIiLCJpc0RpYWdvbmFsTW92ZSIsImlzT3J0aG9nb25hbE1vdmUiLCJnZXRQYXRoQmV0d2VlbiIsInBhdGgiLCJmb3JtYXRNb3ZlIiwiY2FwdHVyZSIsInByb21vdGlvbiIsImZyb21TcXVhcmUiLCJ0b1NxdWFyZSIsInBpZWNlU3ltYm9sIiwiY2FwdHVyZVN5bWJvbCIsInByb21vdGlvblN5bWJvbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/shared/utils/chess.ts\n"));

/***/ }),

/***/ "./src/shared/utils/id.ts":
/*!********************************!*\
  !*** ./src/shared/utils/id.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateId\": function() { return /* binding */ generateId; }\n/* harmony export */ });\n/**\n * Gera um ID nico usando crypto.randomUUID() se disponvel,\n * ou fallback para Math.random() se no estiver.\n */ function generateId() {\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL3V0aWxzL2lkLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxTQUFTQSxhQUFxQjtJQUNuQyxJQUFJLE9BQU9DLFdBQVcsZUFBZUEsT0FBT0MsVUFBVSxFQUFFO1FBQ3RELE9BQU9ELE9BQU9DLFVBQVU7SUFDMUIsQ0FBQztJQUNELE9BQU9DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLE1BQ3hDSCxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztBQUNqRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zaGFyZWQvdXRpbHMvaWQudHM/MTJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdlcmEgdW0gSUQgw7puaWNvIHVzYW5kbyBjcnlwdG8ucmFuZG9tVVVJRCgpIHNlIGRpc3BvbsOtdmVsLFxuICogb3UgZmFsbGJhY2sgcGFyYSBNYXRoLnJhbmRvbSgpIHNlIG7Do28gZXN0aXZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBcbiAgICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG59XG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVJZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shared/utils/id.ts\n"));

/***/ }),

/***/ "./src/web/components/board/ChessBoard.tsx":
/*!*************************************************!*\
  !*** ./src/web/components/board/ChessBoard.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChessBoard\": function() { return /* binding */ ChessBoard; },\n/* harmony export */   \"MemoizedChessBoard\": function() { return /* binding */ MemoizedChessBoard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _hooks_useGameState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../hooks/useGameState */ \"./src/web/hooks/useGameState.ts\");\n/* harmony import */ var _hooks_useResponsiveBoard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../hooks/useResponsiveBoard */ \"./src/web/hooks/useResponsiveBoard.ts\");\n/* harmony import */ var _Square__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Square */ \"./src/web/components/board/Square.tsx\");\n/* harmony import */ var _Piece__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Piece */ \"./src/web/components/board/Piece.tsx\");\n/* harmony import */ var _shared_constants_game__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../shared/constants/game */ \"./src/shared/constants/game.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst ChessBoard = (param)=>{\n    let { initialFen , orientation =\"white\" , culturalStyle =\"modern\" , showCoordinates =true , onMove , onGameEnd  } = param;\n    _s();\n    // Estado do jogo\n    const { gameState , selectedSquare , possibleMoves , lastMove , pieceAt , selectSquare , makeMove  } = (0,_hooks_useGameState__WEBPACK_IMPORTED_MODULE_3__.useGameState)({\n        initialFen,\n        culturalStyle\n    });\n    // Estado de arrastar e soltar\n    const [draggedPiece, setDraggedPiece] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    // Container ref para dimensionamento responsivo\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    // Hook de dimensionamento responsivo\n    const { boardSize , squareSize , pieceSize  } = (0,_hooks_useResponsiveBoard__WEBPACK_IMPORTED_MODULE_4__.useResponsiveBoard)(containerRef);\n    // Manipuladores de eventos de arrastar e soltar\n    const handleDragStart = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((position, piece, e)=>{\n        if (piece.color !== gameState.currentPlayer) {\n            e.preventDefault();\n            return;\n        }\n        setDraggedPiece({\n            piece,\n            position\n        });\n        selectSquare(position);\n        // Define a imagem de arrasto transparente\n        const dragImage = new Image();\n        dragImage.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n        e.dataTransfer.setDragImage(dragImage, 0, 0);\n    }, [\n        gameState.currentPlayer,\n        selectSquare\n    ]);\n    const handleDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        setDraggedPiece(null);\n    }, []);\n    const handleDrop = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((toPosition)=>{\n        if (!draggedPiece) return;\n        const success = makeMove(draggedPiece.position, toPosition);\n        if (success && onMove) {\n            onMove(draggedPiece.position, toPosition);\n        }\n        setDraggedPiece(null);\n    }, [\n        draggedPiece,\n        makeMove,\n        onMove\n    ]);\n    // Manipulador de clique na casa\n    const handleSquareClick = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((position)=>{\n        if (selectedSquare) {\n            if (makeMove(selectedSquare, position) && onMove) {\n                onMove(selectedSquare, position);\n            }\n        } else {\n            selectSquare(position);\n        }\n    }, [\n        selectedSquare,\n        makeMove,\n        onMove,\n        selectSquare\n    ]);\n    // Renderiza o tabuleiro\n    const renderBoard = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        const board = [];\n        const rangeY = orientation === \"white\" ? Array.from({\n            length: _shared_constants_game__WEBPACK_IMPORTED_MODULE_7__.BOARD_SIZE\n        }, (_, i)=>i) : Array.from({\n            length: _shared_constants_game__WEBPACK_IMPORTED_MODULE_7__.BOARD_SIZE\n        }, (_, i)=>_shared_constants_game__WEBPACK_IMPORTED_MODULE_7__.BOARD_SIZE - 1 - i);\n        const rangeX = orientation === \"white\" ? Array.from({\n            length: _shared_constants_game__WEBPACK_IMPORTED_MODULE_7__.BOARD_SIZE\n        }, (_, i)=>i) : Array.from({\n            length: _shared_constants_game__WEBPACK_IMPORTED_MODULE_7__.BOARD_SIZE\n        }, (_, i)=>_shared_constants_game__WEBPACK_IMPORTED_MODULE_7__.BOARD_SIZE - 1 - i);\n        for (const row of rangeY){\n            for (const col of rangeX){\n                const position = {\n                    row,\n                    col\n                };\n                const piece = pieceAt(position);\n                const isSelected = selectedSquare && selectedSquare.row === row && selectedSquare.col === col;\n                const isPossibleMove = possibleMoves.some((move)=>move.row === row && move.col === col);\n                const isLastMove = lastMove && (lastMove.from.row === row && lastMove.from.col === col || lastMove.to.row === row && lastMove.to.col === col);\n                board.push(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    \"data-testid\": \"square-\".concat(row, \"-\").concat(col),\n                    style: {\n                        width: squareSize,\n                        height: squareSize\n                    },\n                    onDragOver: (e)=>e.preventDefault(),\n                    onDrop: ()=>handleDrop(position),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Square__WEBPACK_IMPORTED_MODULE_5__.MemoizedSquare, {\n                        position: position,\n                        piece: piece,\n                        isSelected: isSelected,\n                        isPossibleMove: isPossibleMove,\n                        isLastMove: isLastMove,\n                        showCoordinates: showCoordinates,\n                        culturalStyle: culturalStyle,\n                        onClick: ()=>handleSquareClick(position),\n                        children: piece && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Piece__WEBPACK_IMPORTED_MODULE_6__.MemoizedPiece, {\n                            piece: piece,\n                            isDragging: (draggedPiece === null || draggedPiece === void 0 ? void 0 : draggedPiece.position) === position,\n                            culturalStyle: culturalStyle,\n                            size: squareSize * 0.8,\n                            onDragStart: (e)=>handleDragStart(position, piece, e),\n                            onDragEnd: handleDragEnd\n                        }, void 0, false, {\n                            fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                            lineNumber: 146,\n                            columnNumber: 17\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                        lineNumber: 135,\n                        columnNumber: 13\n                    }, undefined)\n                }, \"\".concat(row, \"-\").concat(col), false, {\n                    fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                    lineNumber: 125,\n                    columnNumber: 11\n                }, undefined));\n            }\n        }\n        return board;\n    }, [\n        orientation,\n        squareSize,\n        pieceAt,\n        selectedSquare,\n        possibleMoves,\n        lastMove,\n        draggedPiece,\n        culturalStyle,\n        showCoordinates,\n        handleDragStart,\n        handleDragEnd,\n        handleDrop,\n        handleSquareClick\n    ]);\n    // Efeito para verificar fim de jogo\n    react__WEBPACK_IMPORTED_MODULE_2___default().useEffect(()=>{\n        if (gameState.isCheckmate || gameState.isDraw) {\n            let result = \"\";\n            if (gameState.isCheckmate) {\n                result = gameState.currentPlayer === \"white\" ? \"black\" : \"white\";\n            } else {\n                result = \"draw\";\n            }\n            onGameEnd === null || onGameEnd === void 0 ? void 0 : onGameEnd(result);\n        }\n    }, [\n        gameState.isCheckmate,\n        gameState.isDraw,\n        gameState.currentPlayer,\n        onGameEnd\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            width: boardSize,\n            height: boardSize\n        },\n        className: styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default().dynamic([\n            [\n                \"34830f102c4e591c\",\n                [\n                    culturalStyle\n                ]\n            ]\n        ]) + \" \" + \"relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default().dynamic([\n                    [\n                        \"34830f102c4e591c\",\n                        [\n                            culturalStyle\n                        ]\n                    ]\n                ]) + \" \" + \"p-2 rounded-lg shadow-xl bg-gradient-to-br from-emerald-700 to-emerald-900\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    \"data-testid\": \"chessboard\",\n                    \"data-style\": culturalStyle,\n                    style: {\n                        backgroundImage: \"url('/images/patterns/\".concat(culturalStyle, \".png')\")\n                    },\n                    className: styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default().dynamic([\n                        [\n                            \"34830f102c4e591c\",\n                            [\n                                culturalStyle\n                            ]\n                        ]\n                    ]) + \" \" + \"grid grid-cols-8 rounded-md overflow-hidden border-4 border-emerald-800\",\n                    children: renderBoard()\n                }, void 0, false, {\n                    fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                    lineNumber: 202,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                lineNumber: 200,\n                columnNumber: 7\n            }, undefined),\n            gameState.isCheck && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    border: \"4px solid #f59e0b\",\n                    animation: \"pulse 2s infinite\"\n                },\n                className: styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default().dynamic([\n                    [\n                        \"34830f102c4e591c\",\n                        [\n                            culturalStyle\n                        ]\n                    ]\n                ]) + \" \" + \"absolute inset-0 pointer-events-none\"\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                lineNumber: 216,\n                columnNumber: 9\n            }, undefined),\n            gameState.isCheckmate && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    border: \"4px solid #ef4444\",\n                    animation: \"shake 0.5s\"\n                },\n                className: styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default().dynamic([\n                    [\n                        \"34830f102c4e591c\",\n                        [\n                            culturalStyle\n                        ]\n                    ]\n                ]) + \" \" + \"absolute inset-0 pointer-events-none\"\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n                lineNumber: 227,\n                columnNumber: 9\n            }, undefined),\n            (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"34830f102c4e591c\",\n                dynamic: [\n                    culturalStyle\n                ],\n                children: '@-webkit-keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}@-moz-keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}@-o-keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}@keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}@-webkit-keyframes shake{0%,100%{-webkit-transform:translatex(0);transform:translatex(0)}25%{-webkit-transform:translatex(-5px);transform:translatex(-5px)}75%{-webkit-transform:translatex(5px);transform:translatex(5px)}}@-moz-keyframes shake{0%,100%{-moz-transform:translatex(0);transform:translatex(0)}25%{-moz-transform:translatex(-5px);transform:translatex(-5px)}75%{-moz-transform:translatex(5px);transform:translatex(5px)}}@-o-keyframes shake{0%,100%{-o-transform:translatex(0);transform:translatex(0)}25%{-o-transform:translatex(-5px);transform:translatex(-5px)}75%{-o-transform:translatex(5px);transform:translatex(5px)}}@keyframes shake{0%,100%{-webkit-transform:translatex(0);-moz-transform:translatex(0);-o-transform:translatex(0);transform:translatex(0)}25%{-webkit-transform:translatex(-5px);-moz-transform:translatex(-5px);-o-transform:translatex(-5px);transform:translatex(-5px)}75%{-webkit-transform:translatex(5px);-moz-transform:translatex(5px);-o-transform:translatex(5px);transform:translatex(5px)}}.grid.__jsx-style-dynamic-selector{background-image:url(\"/images/patterns/'.concat(culturalStyle, '.png\");-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;background-size:cover;background-blend-mode:overlay}')\n            }, void 0, false, void 0, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/ChessBoard.tsx\",\n        lineNumber: 192,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ChessBoard, \"3hz5A1dk5+eY/pQHB8iSBy7TE18=\", false, function() {\n    return [\n        _hooks_useGameState__WEBPACK_IMPORTED_MODULE_3__.useGameState,\n        _hooks_useResponsiveBoard__WEBPACK_IMPORTED_MODULE_4__.useResponsiveBoard\n    ];\n});\n_c = ChessBoard;\n// Otimizao de renderizao\nconst MemoizedChessBoard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().memo(ChessBoard);\n_c1 = MemoizedChessBoard;\nvar _c, _c1;\n$RefreshReg$(_c, \"ChessBoard\");\n$RefreshReg$(_c1, \"MemoizedChessBoard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViL2NvbXBvbmVudHMvYm9hcmQvQ2hlc3NCb2FyZC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRTtBQUVkO0FBQ1k7QUFDMUI7QUFDRjtBQUNvQjtBQVdyRCxNQUFNUyxhQUF3QyxTQU8vQztRQVBnRCxFQUNwREMsV0FBVSxFQUNWQyxhQUFjLFFBQU8sRUFDckJDLGVBQWdCLFNBQVEsRUFDeEJDLGlCQUFrQixJQUFJLEdBQ3RCQyxPQUFNLEVBQ05DLFVBQVMsRUFDVjs7SUFDQyxpQkFBaUI7SUFDakIsTUFBTSxFQUNKQyxVQUFTLEVBQ1RDLGVBQWMsRUFDZEMsY0FBYSxFQUNiQyxTQUFRLEVBQ1JDLFFBQU8sRUFDUEMsYUFBWSxFQUNaQyxTQUFRLEVBQ1QsR0FBR2xCLGlFQUFZQSxDQUFDO1FBQ2ZNO1FBQ0FFO0lBQ0Y7SUFFQSw4QkFBOEI7SUFDOUIsTUFBTSxDQUFDVyxjQUFjQyxnQkFBZ0IsR0FBR3ZCLCtDQUFRQSxDQUd0QyxJQUFJO0lBRWQsZ0RBQWdEO0lBQ2hELE1BQU13QixlQUFldEIsNkNBQU1BLENBQWlCLElBQUk7SUFFaEQscUNBQXFDO0lBQ3JDLE1BQU0sRUFBRXVCLFVBQVMsRUFBRUMsV0FBVSxFQUFFQyxVQUFTLEVBQUUsR0FBR3ZCLDZFQUFrQkEsQ0FBQ29CO0lBRWhFLGdEQUFnRDtJQUNoRCxNQUFNSSxrQkFBa0IzQixrREFBV0EsQ0FBQyxDQUNsQzRCLFVBQ0FDLE9BQ0FDLElBQ0c7UUFDSCxJQUFJRCxNQUFNRSxLQUFLLEtBQUtqQixVQUFVa0IsYUFBYSxFQUFFO1lBQzNDRixFQUFFRyxjQUFjO1lBQ2hCO1FBQ0YsQ0FBQztRQUVEWCxnQkFBZ0I7WUFBRU87WUFBT0Q7UUFBUztRQUNsQ1QsYUFBYVM7UUFFYiwwQ0FBMEM7UUFDMUMsTUFBTU0sWUFBWSxJQUFJQztRQUN0QkQsVUFBVUUsR0FBRyxHQUFHO1FBQ2hCTixFQUFFTyxZQUFZLENBQUNDLFlBQVksQ0FBQ0osV0FBVyxHQUFHO0lBQzVD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QUVac0QsT0FBTzt3QkFDTGUsaUJBQWlCLHlCQUF1QyxPQUFkckUsZUFBYztvQkFDMUQ7Ozs7O2dDQTJDMENBOzs7K0JBOUNoQzs4QkFLVGtDOzs7Ozs7Ozs7OztZQUtKOUIsVUFBVWtFLE9BQU8sa0JBQ2hCLDhEQUFDbEI7Z0JBRUNFLE9BQU87b0JBQ0xpQixRQUFRO29CQUNSQyxXQUFXO2dCQUNiOzs7Ozs0QkE4QjBDeEU7OzsyQkFsQ2hDOzs7Ozs7WUFTYkksVUFBVTZELFdBQVcsa0JBQ3BCLDhEQUFDYjtnQkFFQ0UsT0FBTztvQkFDTGlCLFFBQVE7b0JBQ1JDLFdBQVc7Z0JBQ2I7Ozs7OzRCQW1CMEN4RTs7OzJCQXZCaEM7Ozs7Ozs7OztvQkF1QmdDQTs7ZzNDQUFBQTs7Ozs7Ozs7QUFPcEQsRUFBRTtHQWhQV0g7O1FBaUJQTCw2REFBWUE7UUFlNkJDLHlFQUFrQkE7OztLQWhDcERJO0FBa1BiLDZCQUE2QjtBQUN0QixNQUFNNEUsbUNBQXFCckYsaURBQVUsQ0FBQ1MsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvd2ViL2NvbXBvbmVudHMvYm9hcmQvQ2hlc3NCb2FyZC50c3g/MDg4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGVzc1Bvc2l0aW9uLCBDaGVzc1BpZWNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3R5cGVzL2NoZXNzJztcbmltcG9ydCB7IHVzZUdhbWVTdGF0ZSB9IGZyb20gJy4uLy4uL2hvb2tzL3VzZUdhbWVTdGF0ZSc7XG5pbXBvcnQgeyB1c2VSZXNwb25zaXZlQm9hcmQgfSBmcm9tICcuLi8uLi9ob29rcy91c2VSZXNwb25zaXZlQm9hcmQnO1xuaW1wb3J0IHsgTWVtb2l6ZWRTcXVhcmUgfSBmcm9tICcuL1NxdWFyZSc7XG5pbXBvcnQgeyBNZW1vaXplZFBpZWNlIH0gZnJvbSAnLi9QaWVjZSc7XG5pbXBvcnQgeyBCT0FSRF9TSVpFIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYW1lJztcblxuaW50ZXJmYWNlIENoZXNzQm9hcmRQcm9wcyB7XG4gIGluaXRpYWxGZW4/OiBzdHJpbmc7XG4gIG9yaWVudGF0aW9uPzogJ3doaXRlJyB8ICdibGFjayc7XG4gIGN1bHR1cmFsU3R5bGU/OiBzdHJpbmc7XG4gIHNob3dDb29yZGluYXRlcz86IGJvb2xlYW47XG4gIG9uTW92ZT86IChmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbikgPT4gdm9pZDtcbiAgb25HYW1lRW5kPzogKHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgQ2hlc3NCb2FyZDogUmVhY3QuRkM8Q2hlc3NCb2FyZFByb3BzPiA9ICh7XG4gIGluaXRpYWxGZW4sXG4gIG9yaWVudGF0aW9uID0gJ3doaXRlJyxcbiAgY3VsdHVyYWxTdHlsZSA9ICdtb2Rlcm4nLFxuICBzaG93Q29vcmRpbmF0ZXMgPSB0cnVlLFxuICBvbk1vdmUsXG4gIG9uR2FtZUVuZCxcbn0pID0+IHtcbiAgLy8gRXN0YWRvIGRvIGpvZ29cbiAgY29uc3Qge1xuICAgIGdhbWVTdGF0ZSxcbiAgICBzZWxlY3RlZFNxdWFyZSxcbiAgICBwb3NzaWJsZU1vdmVzLFxuICAgIGxhc3RNb3ZlLFxuICAgIHBpZWNlQXQsXG4gICAgc2VsZWN0U3F1YXJlLFxuICAgIG1ha2VNb3ZlLFxuICB9ID0gdXNlR2FtZVN0YXRlKHtcbiAgICBpbml0aWFsRmVuLFxuICAgIGN1bHR1cmFsU3R5bGUsXG4gIH0pO1xuXG4gIC8vIEVzdGFkbyBkZSBhcnJhc3RhciBlIHNvbHRhclxuICBjb25zdCBbZHJhZ2dlZFBpZWNlLCBzZXREcmFnZ2VkUGllY2VdID0gdXNlU3RhdGU8e1xuICAgIHBpZWNlOiBDaGVzc1BpZWNlO1xuICAgIHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uO1xuICB9IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gQ29udGFpbmVyIHJlZiBwYXJhIGRpbWVuc2lvbmFtZW50byByZXNwb25zaXZvXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG5cbiAgLy8gSG9vayBkZSBkaW1lbnNpb25hbWVudG8gcmVzcG9uc2l2b1xuICBjb25zdCB7IGJvYXJkU2l6ZSwgc3F1YXJlU2l6ZSwgcGllY2VTaXplIH0gPSB1c2VSZXNwb25zaXZlQm9hcmQoY29udGFpbmVyUmVmKTtcblxuICAvLyBNYW5pcHVsYWRvcmVzIGRlIGV2ZW50b3MgZGUgYXJyYXN0YXIgZSBzb2x0YXJcbiAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gdXNlQ2FsbGJhY2soKFxuICAgIHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uLFxuICAgIHBpZWNlOiBDaGVzc1BpZWNlLFxuICAgIGU6IFJlYWN0LkRyYWdFdmVudFxuICApID0+IHtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGdhbWVTdGF0ZS5jdXJyZW50UGxheWVyKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0RHJhZ2dlZFBpZWNlKHsgcGllY2UsIHBvc2l0aW9uIH0pO1xuICAgIHNlbGVjdFNxdWFyZShwb3NpdGlvbik7XG5cbiAgICAvLyBEZWZpbmUgYSBpbWFnZW0gZGUgYXJyYXN0byB0cmFuc3BhcmVudGVcbiAgICBjb25zdCBkcmFnSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBkcmFnSW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XG4gICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdJbWFnZSwgMCwgMCk7XG4gIH0sIFtnYW1lU3RhdGUuY3VycmVudFBsYXllciwgc2VsZWN0U3F1YXJlXSk7XG5cbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXREcmFnZ2VkUGllY2UobnVsbCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBoYW5kbGVEcm9wID0gdXNlQ2FsbGJhY2soKHRvUG9zaXRpb246IENoZXNzUG9zaXRpb24pID0+IHtcbiAgICBpZiAoIWRyYWdnZWRQaWVjZSkgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3VjY2VzcyA9IG1ha2VNb3ZlKGRyYWdnZWRQaWVjZS5wb3NpdGlvbiwgdG9Qb3NpdGlvbik7XG4gICAgaWYgKHN1Y2Nlc3MgJiYgb25Nb3ZlKSB7XG4gICAgICBvbk1vdmUoZHJhZ2dlZFBpZWNlLnBvc2l0aW9uLCB0b1Bvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBzZXREcmFnZ2VkUGllY2UobnVsbCk7XG4gIH0sIFtkcmFnZ2VkUGllY2UsIG1ha2VNb3ZlLCBvbk1vdmVdKTtcblxuICAvLyBNYW5pcHVsYWRvciBkZSBjbGlxdWUgbmEgY2FzYVxuICBjb25zdCBoYW5kbGVTcXVhcmVDbGljayA9IHVzZUNhbGxiYWNrKChwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbikgPT4ge1xuICAgIGlmIChzZWxlY3RlZFNxdWFyZSkge1xuICAgICAgaWYgKG1ha2VNb3ZlKHNlbGVjdGVkU3F1YXJlLCBwb3NpdGlvbikgJiYgb25Nb3ZlKSB7XG4gICAgICAgIG9uTW92ZShzZWxlY3RlZFNxdWFyZSwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RTcXVhcmUocG9zaXRpb24pO1xuICAgIH1cbiAgfSwgW3NlbGVjdGVkU3F1YXJlLCBtYWtlTW92ZSwgb25Nb3ZlLCBzZWxlY3RTcXVhcmVdKTtcblxuICAvLyBSZW5kZXJpemEgbyB0YWJ1bGVpcm9cbiAgY29uc3QgcmVuZGVyQm9hcmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgYm9hcmQgPSBbXTtcbiAgICBjb25zdCByYW5nZVkgPSBvcmllbnRhdGlvbiA9PT0gJ3doaXRlJyBcbiAgICAgID8gQXJyYXkuZnJvbSh7IGxlbmd0aDogQk9BUkRfU0laRSB9LCAoXywgaSkgPT4gaSlcbiAgICAgIDogQXJyYXkuZnJvbSh7IGxlbmd0aDogQk9BUkRfU0laRSB9LCAoXywgaSkgPT4gQk9BUkRfU0laRSAtIDEgLSBpKTtcbiAgICBcbiAgICBjb25zdCByYW5nZVggPSBvcmllbnRhdGlvbiA9PT0gJ3doaXRlJ1xuICAgICAgPyBBcnJheS5mcm9tKHsgbGVuZ3RoOiBCT0FSRF9TSVpFIH0sIChfLCBpKSA9PiBpKVxuICAgICAgOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBCT0FSRF9TSVpFIH0sIChfLCBpKSA9PiBCT0FSRF9TSVpFIC0gMSAtIGkpO1xuXG4gICAgZm9yIChjb25zdCByb3cgb2YgcmFuZ2VZKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbCBvZiByYW5nZVgpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb246IENoZXNzUG9zaXRpb24gPSB7IHJvdywgY29sIH07XG4gICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VBdChwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZFNxdWFyZSAmJiBcbiAgICAgICAgICBzZWxlY3RlZFNxdWFyZS5yb3cgPT09IHJvdyAmJiBcbiAgICAgICAgICBzZWxlY3RlZFNxdWFyZS5jb2wgPT09IGNvbDtcbiAgICAgICAgY29uc3QgaXNQb3NzaWJsZU1vdmUgPSBwb3NzaWJsZU1vdmVzLnNvbWUoXG4gICAgICAgICAgbW92ZSA9PiBtb3ZlLnJvdyA9PT0gcm93ICYmIG1vdmUuY29sID09PSBjb2xcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNMYXN0TW92ZSA9IGxhc3RNb3ZlICYmIChcbiAgICAgICAgICAobGFzdE1vdmUuZnJvbS5yb3cgPT09IHJvdyAmJiBsYXN0TW92ZS5mcm9tLmNvbCA9PT0gY29sKSB8fFxuICAgICAgICAgIChsYXN0TW92ZS50by5yb3cgPT09IHJvdyAmJiBsYXN0TW92ZS50by5jb2wgPT09IGNvbClcbiAgICAgICAgKTtcblxuICAgICAgICBib2FyZC5wdXNoKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGtleT17YCR7cm93fS0ke2NvbH1gfVxuICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e2BzcXVhcmUtJHtyb3d9LSR7Y29sfWB9XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICB3aWR0aDogc3F1YXJlU2l6ZSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBzcXVhcmVTaXplLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uRHJhZ092ZXI9eyhlKSA9PiBlLnByZXZlbnREZWZhdWx0KCl9XG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IGhhbmRsZURyb3AocG9zaXRpb24pfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxNZW1vaXplZFNxdWFyZVxuICAgICAgICAgICAgICBwb3NpdGlvbj17cG9zaXRpb259XG4gICAgICAgICAgICAgIHBpZWNlPXtwaWVjZX1cbiAgICAgICAgICAgICAgaXNTZWxlY3RlZD17aXNTZWxlY3RlZH1cbiAgICAgICAgICAgICAgaXNQb3NzaWJsZU1vdmU9e2lzUG9zc2libGVNb3ZlfVxuICAgICAgICAgICAgICBpc0xhc3RNb3ZlPXtpc0xhc3RNb3ZlfVxuICAgICAgICAgICAgICBzaG93Q29vcmRpbmF0ZXM9e3Nob3dDb29yZGluYXRlc31cbiAgICAgICAgICAgICAgY3VsdHVyYWxTdHlsZT17Y3VsdHVyYWxTdHlsZX1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlU3F1YXJlQ2xpY2socG9zaXRpb24pfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7cGllY2UgJiYgKFxuICAgICAgICAgICAgICAgIDxNZW1vaXplZFBpZWNlXG4gICAgICAgICAgICAgICAgICBwaWVjZT17cGllY2V9XG4gICAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtkcmFnZ2VkUGllY2U/LnBvc2l0aW9uID09PSBwb3NpdGlvbn1cbiAgICAgICAgICAgICAgICAgIGN1bHR1cmFsU3R5bGU9e2N1bHR1cmFsU3R5bGV9XG4gICAgICAgICAgICAgICAgICBzaXplPXtzcXVhcmVTaXplICogMC44fVxuICAgICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9eyhlKSA9PiBoYW5kbGVEcmFnU3RhcnQocG9zaXRpb24sIHBpZWNlLCBlKX1cbiAgICAgICAgICAgICAgICAgIG9uRHJhZ0VuZD17aGFuZGxlRHJhZ0VuZH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9NZW1vaXplZFNxdWFyZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm9hcmQ7XG4gIH0sIFtcbiAgICBvcmllbnRhdGlvbixcbiAgICBzcXVhcmVTaXplLFxuICAgIHBpZWNlQXQsXG4gICAgc2VsZWN0ZWRTcXVhcmUsXG4gICAgcG9zc2libGVNb3ZlcyxcbiAgICBsYXN0TW92ZSxcbiAgICBkcmFnZ2VkUGllY2UsXG4gICAgY3VsdHVyYWxTdHlsZSxcbiAgICBzaG93Q29vcmRpbmF0ZXMsXG4gICAgaGFuZGxlRHJhZ1N0YXJ0LFxuICAgIGhhbmRsZURyYWdFbmQsXG4gICAgaGFuZGxlRHJvcCxcbiAgICBoYW5kbGVTcXVhcmVDbGljayxcbiAgXSk7XG5cbiAgLy8gRWZlaXRvIHBhcmEgdmVyaWZpY2FyIGZpbSBkZSBqb2dvXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdhbWVTdGF0ZS5pc0NoZWNrbWF0ZSB8fCBnYW1lU3RhdGUuaXNEcmF3KSB7XG4gICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoZ2FtZVN0YXRlLmlzQ2hlY2ttYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGdhbWVTdGF0ZS5jdXJyZW50UGxheWVyID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAnZHJhdyc7XG4gICAgICB9XG4gICAgICBvbkdhbWVFbmQ/LihyZXN1bHQpO1xuICAgIH1cbiAgfSwgW2dhbWVTdGF0ZS5pc0NoZWNrbWF0ZSwgZ2FtZVN0YXRlLmlzRHJhdywgZ2FtZVN0YXRlLmN1cnJlbnRQbGF5ZXIsIG9uR2FtZUVuZF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmVcIlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGg6IGJvYXJkU2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBib2FyZFNpemUsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHsvKiBDb250YWluZXIgZG8gdGFidWxlaXJvIGNvbSBncmFkaWVudGUgZGUgZnVuZG8gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtMiByb3VuZGVkLWxnIHNoYWRvdy14bCBiZy1ncmFkaWVudC10by1iciBmcm9tLWVtZXJhbGQtNzAwIHRvLWVtZXJhbGQtOTAwXCI+XG4gICAgICAgIHsvKiBHcmFkZSBkbyB0YWJ1bGVpcm8gKi99XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBkYXRhLXRlc3RpZD1cImNoZXNzYm9hcmRcIlxuICAgICAgICAgIGRhdGEtc3R5bGU9e2N1bHR1cmFsU3R5bGV9XG4gICAgICAgICAgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtOCByb3VuZGVkLW1kIG92ZXJmbG93LWhpZGRlbiBib3JkZXItNCBib3JkZXItZW1lcmFsZC04MDBcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJy9pbWFnZXMvcGF0dGVybnMvJHtjdWx0dXJhbFN0eWxlfS5wbmcnKWBcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAge3JlbmRlckJvYXJkKCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBJbmRpY2Fkb3IgZGUgeGVxdWUgKi99XG4gICAgICB7Z2FtZVN0YXRlLmlzQ2hlY2sgJiYgKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgYm9yZGVyOiAnNHB4IHNvbGlkICNmNTllMGInLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiAncHVsc2UgMnMgaW5maW5pdGUnLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICApfVxuXG4gICAgICB7LyogSW5kaWNhZG9yIGRlIHhlcXVlLW1hdGUgKi99XG4gICAgICB7Z2FtZVN0YXRlLmlzQ2hlY2ttYXRlICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGJvcmRlcjogJzRweCBzb2xpZCAjZWY0NDQ0JyxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogJ3NoYWtlIDAuNXMnLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICApfVxuXG4gICAgICB7LyogRXN0aWxvIGN1bHR1cmFsIGVzcGVjw61maWNvICovfVxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICBAa2V5ZnJhbWVzIHB1bHNlIHtcbiAgICAgICAgICAwJSB7IG9wYWNpdHk6IDAuNTsgfVxuICAgICAgICAgIDUwJSB7IG9wYWNpdHk6IDE7IH1cbiAgICAgICAgICAxMDAlIHsgb3BhY2l0eTogMC41OyB9XG4gICAgICAgIH1cblxuICAgICAgICBAa2V5ZnJhbWVzIHNoYWtlIHtcbiAgICAgICAgICAwJSwgMTAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfVxuICAgICAgICAgIDI1JSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNXB4KTsgfVxuICAgICAgICAgIDc1JSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCg1cHgpOyB9XG4gICAgICAgIH1cblxuICAgICAgICAuZ3JpZCB7XG4gICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcvaW1hZ2VzL3BhdHRlcm5zLyR7Y3VsdHVyYWxTdHlsZX0ucG5nJyk7XG4gICAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWJsZW5kLW1vZGU6IG92ZXJsYXk7XG4gICAgICAgIH1cbiAgICAgIGB9PC9zdHlsZT5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vIE90aW1pemHDp8OjbyBkZSByZW5kZXJpemHDp8Ojb1xuZXhwb3J0IGNvbnN0IE1lbW9pemVkQ2hlc3NCb2FyZCA9IFJlYWN0Lm1lbW8oQ2hlc3NCb2FyZCk7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlUmVmIiwidXNlR2FtZVN0YXRlIiwidXNlUmVzcG9uc2l2ZUJvYXJkIiwiTWVtb2l6ZWRTcXVhcmUiLCJNZW1vaXplZFBpZWNlIiwiQk9BUkRfU0laRSIsIkNoZXNzQm9hcmQiLCJpbml0aWFsRmVuIiwib3JpZW50YXRpb24iLCJjdWx0dXJhbFN0eWxlIiwic2hvd0Nvb3JkaW5hdGVzIiwib25Nb3ZlIiwib25HYW1lRW5kIiwiZ2FtZVN0YXRlIiwic2VsZWN0ZWRTcXVhcmUiLCJwb3NzaWJsZU1vdmVzIiwibGFzdE1vdmUiLCJwaWVjZUF0Iiwic2VsZWN0U3F1YXJlIiwibWFrZU1vdmUiLCJkcmFnZ2VkUGllY2UiLCJzZXREcmFnZ2VkUGllY2UiLCJjb250YWluZXJSZWYiLCJib2FyZFNpemUiLCJzcXVhcmVTaXplIiwicGllY2VTaXplIiwiaGFuZGxlRHJhZ1N0YXJ0IiwicG9zaXRpb24iLCJwaWVjZSIsImUiLCJjb2xvciIsImN1cnJlbnRQbGF5ZXIiLCJwcmV2ZW50RGVmYXVsdCIsImRyYWdJbWFnZSIsIkltYWdlIiwic3JjIiwiZGF0YVRyYW5zZmVyIiwic2V0RHJhZ0ltYWdlIiwiaGFuZGxlRHJhZ0VuZCIsImhhbmRsZURyb3AiLCJ0b1Bvc2l0aW9uIiwic3VjY2VzcyIsImhhbmRsZVNxdWFyZUNsaWNrIiwicmVuZGVyQm9hcmQiLCJib2FyZCIsInJhbmdlWSIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwicmFuZ2VYIiwicm93IiwiY29sIiwiaXNTZWxlY3RlZCIsImlzUG9zc2libGVNb3ZlIiwic29tZSIsIm1vdmUiLCJpc0xhc3RNb3ZlIiwidG8iLCJwdXNoIiwiZGl2IiwiZGF0YS10ZXN0aWQiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0Iiwib25EcmFnT3ZlciIsIm9uRHJvcCIsIm9uQ2xpY2siLCJpc0RyYWdnaW5nIiwic2l6ZSIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnRW5kIiwidXNlRWZmZWN0IiwiaXNDaGVja21hdGUiLCJpc0RyYXciLCJyZXN1bHQiLCJkYXRhLXN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwiaXNDaGVjayIsImJvcmRlciIsImFuaW1hdGlvbiIsIk1lbW9pemVkQ2hlc3NCb2FyZCIsIm1lbW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/web/components/board/ChessBoard.tsx\n"));

/***/ }),

/***/ "./src/web/components/board/Piece.tsx":
/*!********************************************!*\
  !*** ./src/web/components/board/Piece.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MemoizedPiece\": function() { return /* binding */ MemoizedPiece; },\n/* harmony export */   \"Piece\": function() { return /* binding */ Piece; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _shared_utils_chess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/utils/chess */ \"./src/shared/utils/chess.ts\");\n\n\n\nconst Piece = (param)=>{\n    let { piece , isDragging , culturalStyle =\"modern\" , size , onDragStart , onDragEnd  } = param;\n    // Define o estilo da pea baseado no estilo cultural\n    const pieceStyles = {\n        modern: \"traditional\",\n        ancient: \"hieroglyphic\",\n        medieval: \"artistic\"\n    };\n    const pieceStyle = pieceStyles[culturalStyle] || \"traditional\";\n    // Calcula a escala baseada no estado de dragging\n    const scale = isDragging ? 1.2 : 1;\n    // Determina o smbolo da pea\n    const symbol = (0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_2__.getPieceSymbol)(piece);\n    // Estilo base da pea\n    const baseStyle = {\n        fontSize: \"\".concat(size, \"px\"),\n        lineHeight: \"\".concat(size, \"px\"),\n        transform: \"scale(\".concat(scale, \")\"),\n        transition: \"transform 150ms ease\",\n        color: piece.color === \"white\" ? \"#fff\" : \"#000\",\n        textShadow: piece.color === \"white\" ? \"2px 2px 2px rgba(0,0,0,0.4)\" : \"2px 2px 2px rgba(255,255,255,0.4)\",\n        cursor: \"grab\",\n        userSelect: \"none\"\n    };\n    // Modifica o estilo baseado no tema cultural\n    const culturalModifiers = {\n        traditional: {},\n        artistic: {\n            filter: \"drop-shadow(2px 2px 3px rgba(0,0,0,0.3))\"\n        },\n        minimalist: {\n            textShadow: \"none\",\n            fontWeight: \"normal\"\n        },\n        hieroglyphic: {\n            fontFamily: \"'Noto Sans', sans-serif\",\n            fontWeight: \"normal\"\n        }\n    };\n    const styleModifiers = culturalModifiers[pieceStyle] || {};\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"\\n        select-none\\n        flex\\n        items-center\\n        justify-center\\n        transform\\n        transition-transform\\n        \".concat(isDragging ? \"cursor-grabbing z-50\" : \"cursor-grab\", \"\\n      \"),\n        style: {\n            width: size,\n            height: size,\n            transform: \"scale(\".concat(scale, \")\"),\n            transition: \"transform 150ms ease\"\n        },\n        draggable: true,\n        onDragStart: onDragStart,\n        onDragEnd: onDragEnd,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"text-5xl select-none relative\",\n            style: {\n                color: piece.color === \"white\" ? \"#fff\" : \"#000\",\n                textShadow: piece.color === \"white\" ? \"2px 2px 2px rgba(0,0,0,0.4)\" : \"2px 2px 2px rgba(255,255,255,0.4)\",\n                lineHeight: \"1\",\n                ...styleModifiers\n            },\n            children: symbol\n        }, void 0, false, {\n            fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Piece.tsx\",\n            lineNumber: 89,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Piece.tsx\",\n        lineNumber: 69,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Piece;\n// Otimizao de renderizao\nconst MemoizedPiece = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().memo(Piece);\n_c1 = MemoizedPiece;\nvar _c, _c1;\n$RefreshReg$(_c, \"Piece\");\n$RefreshReg$(_c1, \"MemoizedPiece\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViL2NvbXBvbmVudHMvYm9hcmQvUGllY2UudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBCO0FBRW1DO0FBV3RELE1BQU1FLFFBQThCLFNBT3JDO1FBUHNDLEVBQzFDQyxNQUFLLEVBQ0xDLFdBQVUsRUFDVkMsZUFBZ0IsU0FBUSxFQUN4QkMsS0FBSSxFQUNKQyxZQUFXLEVBQ1hDLFVBQVMsRUFDVjtJQUNDLHFEQUFxRDtJQUNyRCxNQUFNQyxjQUFjO1FBQ2xCQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsVUFBVTtJQUNaO0lBQ0EsTUFBTUMsYUFBYUosV0FBVyxDQUFDSixjQUEwQyxJQUFJO0lBRTdFLGlEQUFpRDtJQUNqRCxNQUFNUyxRQUFRVixhQUFhLE1BQU0sQ0FBQztJQUVsQyw4QkFBOEI7SUFDOUIsTUFBTVcsU0FBU2QsbUVBQWNBLENBQUNFO0lBRTlCLHNCQUFzQjtJQUN0QixNQUFNYSxZQUFZO1FBQ2hCQyxVQUFVLEdBQVEsT0FBTFgsTUFBSztRQUNsQlksWUFBWSxHQUFRLE9BQUxaLE1BQUs7UUFDcEJhLFdBQVcsU0FBZSxPQUFOTCxPQUFNO1FBQzFCTSxZQUFZO1FBQ1pDLE9BQU9sQixNQUFNa0IsS0FBSyxLQUFLLFVBQVUsU0FBUyxNQUFNO1FBQ2hEQyxZQUFZbkIsTUFBTWtCLEtBQUssS0FBSyxVQUN4QixnQ0FDQSxtQ0FBbUM7UUFDdkNFLFFBQVE7UUFDUkMsWUFBWTtJQUNkO0lBRUEsNkNBQTZDO0lBQzdDLE1BQU1DLG9CQUFvQjtRQUN4QkMsYUFBYSxDQUFDO1FBQ2RDLFVBQVU7WUFDUkMsUUFBUTtRQUNWO1FBQ0FDLFlBQVk7WUFDVlAsWUFBWTtZQUNaUSxZQUFZO1FBQ2Q7UUFDQUMsY0FBYztZQUNaQyxZQUFZO1lBQ1pGLFlBQVk7UUFDZDtJQUNGO0lBRUEsTUFBTUcsaUJBQWlCUixpQkFBaUIsQ0FBQ1osV0FBNkMsSUFBSSxDQUFDO0lBRTNGLHFCQUNFLDhEQUFDcUI7UUFDQ0MsV0FBVywrSUFPNkMsT0FBcEQvQixhQUFhLHlCQUF5QixhQUFhLEVBQUM7UUFFeERnQyxPQUFPO1lBQ0xDLE9BQU8vQjtZQUNQZ0MsUUFBUWhDO1lBQ1JhLFdBQVcsU0FBZSxPQUFOTCxPQUFNO1lBQzFCTSxZQUFZO1FBQ2Q7UUFDQW1CLFdBQVcsSUFBSTtRQUNmaEMsYUFBYUE7UUFDYkMsV0FBV0E7a0JBRVgsNEVBQUMwQjtZQUNDQyxXQUFVO1lBQ1ZDLE9BQU87Z0JBQ0xmLE9BQU9sQixNQUFNa0IsS0FBSyxLQUFLLFVBQVUsU0FBUyxNQUFNO2dCQUNoREMsWUFBWW5CLE1BQU1rQixLQUFLLEtBQUssVUFDeEIsZ0NBQ0EsbUNBQW1DO2dCQUN2Q0gsWUFBWTtnQkFDWixHQUFHZSxjQUFjO1lBQ25CO3NCQUVDbEI7Ozs7Ozs7Ozs7O0FBSVQsRUFBRTtLQTFGV2I7QUE0RmIsNkJBQTZCO0FBQ3RCLE1BQU1zQyw4QkFBZ0J4QyxpREFBVSxDQUFDRSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy93ZWIvY29tcG9uZW50cy9ib2FyZC9QaWVjZS50c3g/YzYzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2hlc3NQaWVjZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC90eXBlcy9jaGVzcyc7XG5pbXBvcnQgeyBnZXRQaWVjZVN5bWJvbCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9jaGVzcyc7XG5cbmludGVyZmFjZSBQaWVjZVByb3BzIHtcbiAgcGllY2U6IENoZXNzUGllY2U7XG4gIGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuICBjdWx0dXJhbFN0eWxlPzogc3RyaW5nO1xuICBzaXplPzogbnVtYmVyO1xuICBvbkRyYWdTdGFydD86IChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHZvaWQ7XG4gIG9uRHJhZ0VuZD86IChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBQaWVjZTogUmVhY3QuRkM8UGllY2VQcm9wcz4gPSAoe1xuICBwaWVjZSxcbiAgaXNEcmFnZ2luZyxcbiAgY3VsdHVyYWxTdHlsZSA9ICdtb2Rlcm4nLFxuICBzaXplLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnRW5kLFxufSkgPT4ge1xuICAvLyBEZWZpbmUgbyBlc3RpbG8gZGEgcGXDp2EgYmFzZWFkbyBubyBlc3RpbG8gY3VsdHVyYWxcbiAgY29uc3QgcGllY2VTdHlsZXMgPSB7XG4gICAgbW9kZXJuOiAndHJhZGl0aW9uYWwnLFxuICAgIGFuY2llbnQ6ICdoaWVyb2dseXBoaWMnLFxuICAgIG1lZGlldmFsOiAnYXJ0aXN0aWMnXG4gIH07XG4gIGNvbnN0IHBpZWNlU3R5bGUgPSBwaWVjZVN0eWxlc1tjdWx0dXJhbFN0eWxlIGFzIGtleW9mIHR5cGVvZiBwaWVjZVN0eWxlc10gfHwgJ3RyYWRpdGlvbmFsJztcblxuICAvLyBDYWxjdWxhIGEgZXNjYWxhIGJhc2VhZGEgbm8gZXN0YWRvIGRlIGRyYWdnaW5nXG4gIGNvbnN0IHNjYWxlID0gaXNEcmFnZ2luZyA/IDEuMiA6IDE7XG5cbiAgLy8gRGV0ZXJtaW5hIG8gc8OtbWJvbG8gZGEgcGXDp2FcbiAgY29uc3Qgc3ltYm9sID0gZ2V0UGllY2VTeW1ib2wocGllY2UpO1xuXG4gIC8vIEVzdGlsbyBiYXNlIGRhIHBlw6dhXG4gIGNvbnN0IGJhc2VTdHlsZSA9IHtcbiAgICBmb250U2l6ZTogYCR7c2l6ZX1weGAsXG4gICAgbGluZUhlaWdodDogYCR7c2l6ZX1weGAsXG4gICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZX0pYCxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDE1MG1zIGVhc2UnLFxuICAgIGNvbG9yOiBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICcjZmZmJyA6ICcjMDAwJyxcbiAgICB0ZXh0U2hhZG93OiBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJ1xuICAgICAgPyAnMnB4IDJweCAycHggcmdiYSgwLDAsMCwwLjQpJ1xuICAgICAgOiAnMnB4IDJweCAycHggcmdiYSgyNTUsMjU1LDI1NSwwLjQpJyxcbiAgICBjdXJzb3I6ICdncmFiJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScgYXMgY29uc3QsXG4gIH07XG5cbiAgLy8gTW9kaWZpY2EgbyBlc3RpbG8gYmFzZWFkbyBubyB0ZW1hIGN1bHR1cmFsXG4gIGNvbnN0IGN1bHR1cmFsTW9kaWZpZXJzID0ge1xuICAgIHRyYWRpdGlvbmFsOiB7fSxcbiAgICBhcnRpc3RpYzoge1xuICAgICAgZmlsdGVyOiAnZHJvcC1zaGFkb3coMnB4IDJweCAzcHggcmdiYSgwLDAsMCwwLjMpKScsXG4gICAgfSxcbiAgICBtaW5pbWFsaXN0OiB7XG4gICAgICB0ZXh0U2hhZG93OiAnbm9uZScsXG4gICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGhpZXJvZ2x5cGhpYzoge1xuICAgICAgZm9udEZhbWlseTogXCInTm90byBTYW5zJywgc2Fucy1zZXJpZlwiLFxuICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBzdHlsZU1vZGlmaWVycyA9IGN1bHR1cmFsTW9kaWZpZXJzW3BpZWNlU3R5bGUgYXMga2V5b2YgdHlwZW9mIGN1bHR1cmFsTW9kaWZpZXJzXSB8fCB7fTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17YFxuICAgICAgICBzZWxlY3Qtbm9uZVxuICAgICAgICBmbGV4XG4gICAgICAgIGl0ZW1zLWNlbnRlclxuICAgICAgICBqdXN0aWZ5LWNlbnRlclxuICAgICAgICB0cmFuc2Zvcm1cbiAgICAgICAgdHJhbnNpdGlvbi10cmFuc2Zvcm1cbiAgICAgICAgJHtpc0RyYWdnaW5nID8gJ2N1cnNvci1ncmFiYmluZyB6LTUwJyA6ICdjdXJzb3ItZ3JhYid9XG4gICAgICBgfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZX0pYCxcbiAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAxNTBtcyBlYXNlJyxcbiAgICAgIH19XG4gICAgICBkcmFnZ2FibGU9e3RydWV9XG4gICAgICBvbkRyYWdTdGFydD17b25EcmFnU3RhcnR9XG4gICAgICBvbkRyYWdFbmQ9e29uRHJhZ0VuZH1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInRleHQtNXhsIHNlbGVjdC1ub25lIHJlbGF0aXZlXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBjb2xvcjogcGllY2UuY29sb3IgPT09ICd3aGl0ZScgPyAnI2ZmZicgOiAnIzAwMCcsXG4gICAgICAgICAgdGV4dFNoYWRvdzogcGllY2UuY29sb3IgPT09ICd3aGl0ZSdcbiAgICAgICAgICAgID8gJzJweCAycHggMnB4IHJnYmEoMCwwLDAsMC40KSdcbiAgICAgICAgICAgIDogJzJweCAycHggMnB4IHJnYmEoMjU1LDI1NSwyNTUsMC40KScsXG4gICAgICAgICAgbGluZUhlaWdodDogJzEnLFxuICAgICAgICAgIC4uLnN0eWxlTW9kaWZpZXJzLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7c3ltYm9sfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG4vLyBPdGltaXphw6fDo28gZGUgcmVuZGVyaXphw6fDo29cbmV4cG9ydCBjb25zdCBNZW1vaXplZFBpZWNlID0gUmVhY3QubWVtbyhQaWVjZSk7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJnZXRQaWVjZVN5bWJvbCIsIlBpZWNlIiwicGllY2UiLCJpc0RyYWdnaW5nIiwiY3VsdHVyYWxTdHlsZSIsInNpemUiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsInBpZWNlU3R5bGVzIiwibW9kZXJuIiwiYW5jaWVudCIsIm1lZGlldmFsIiwicGllY2VTdHlsZSIsInNjYWxlIiwic3ltYm9sIiwiYmFzZVN0eWxlIiwiZm9udFNpemUiLCJsaW5lSGVpZ2h0IiwidHJhbnNmb3JtIiwidHJhbnNpdGlvbiIsImNvbG9yIiwidGV4dFNoYWRvdyIsImN1cnNvciIsInVzZXJTZWxlY3QiLCJjdWx0dXJhbE1vZGlmaWVycyIsInRyYWRpdGlvbmFsIiwiYXJ0aXN0aWMiLCJmaWx0ZXIiLCJtaW5pbWFsaXN0IiwiZm9udFdlaWdodCIsImhpZXJvZ2x5cGhpYyIsImZvbnRGYW1pbHkiLCJzdHlsZU1vZGlmaWVycyIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJkcmFnZ2FibGUiLCJNZW1vaXplZFBpZWNlIiwibWVtbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/web/components/board/Piece.tsx\n"));

/***/ }),

/***/ "./src/web/components/board/Square.tsx":
/*!*********************************************!*\
  !*** ./src/web/components/board/Square.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MemoizedSquare\": function() { return /* binding */ MemoizedSquare; },\n/* harmony export */   \"Square\": function() { return /* binding */ Square; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _shared_utils_chess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/utils/chess */ \"./src/shared/utils/chess.ts\");\n\n\n\nconst Square = (param)=>{\n    let { position , piece , isSelected , isPossibleMove , isLastMove , showCoordinates , culturalStyle =\"modern\" , onClick , children  } = param;\n    const { row , col  } = position;\n    const squareColor = (0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_2__.getSquareColor)(row, col);\n    // Determina a cor final da casa com base nos estados e estilo cultural\n    let backgroundColor;\n    // Cores base do tabuleiro para cada estilo cultural\n    const boardColors = {\n        modern: {\n            light: \"#f0d9b5\",\n            dark: \"#b58863\"\n        },\n        ancient: {\n            light: \"#e6d5ac\",\n            dark: \"#7c6c54\"\n        },\n        medieval: {\n            light: \"#eed2a4\",\n            dark: \"#8b4513\"\n        }\n    };\n    // Seleciona as cores base do estilo cultural atual\n    const styleColors = boardColors[culturalStyle] || boardColors.modern;\n    // Aplica as cores de acordo com o estado do quadrado\n    if (isSelected) {\n        backgroundColor = \"#fcd34d\";\n    } else if (isLastMove) {\n        backgroundColor = \"#34d399\";\n    } else if (isPossibleMove) {\n        backgroundColor = \"#fbbf24\";\n    } else {\n        backgroundColor = styleColors[squareColor];\n    }\n    // Gera coordenadas algbricas para exibio\n    const file = String.fromCharCode(\"a\".charCodeAt(0) + col);\n    const rank = 8 - row;\n    // Manipulador de clique\n    const handleClick = ()=>{\n        onClick === null || onClick === void 0 ? void 0 : onClick(position);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"\\n        relative\\n        w-full\\n        h-full\\n        flex\\n        items-center\\n        justify-center\\n        transition-all\\n        duration-200\\n        \".concat(isPossibleMove ? \"cursor-pointer\" : \"\", \"\\n        \").concat(isSelected ? \"ring-2 ring-yellow-400\" : \"\", \"\\n        \").concat(isLastMove ? \"ring-2 ring-green-400\" : \"\", \"\\n      \"),\n        style: {\n            backgroundColor: backgroundColor\n        },\n        onClick: handleClick,\n        children: [\n            isPossibleMove && !piece && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-3 h-3 rounded-full bg-yellow-400 opacity-50\"\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n                lineNumber: 95,\n                columnNumber: 9\n            }, undefined),\n            isPossibleMove && piece && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 border-2 border-yellow-400 opacity-50\"\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n                lineNumber: 102,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative z-10\",\n                children: children\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n                lineNumber: 108,\n                columnNumber: 7\n            }, undefined),\n            showCoordinates && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    col === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"absolute top-0.5 left-1 text-xs font-bold opacity-75\",\n                        style: {\n                            color: squareColor === \"light\" ? \"#666\" : \"#fff\"\n                        },\n                        children: rank\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n                        lineNumber: 116,\n                        columnNumber: 13\n                    }, undefined),\n                    row === 7 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"absolute bottom-0.5 right-1 text-xs font-bold opacity-75\",\n                        style: {\n                            color: squareColor === \"light\" ? \"#666\" : \"#fff\"\n                        },\n                        children: file\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n                        lineNumber: 124,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 opacity-0 hover:opacity-20 transition-opacity duration-200 bg-white\"\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n                lineNumber: 135,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/board/Square.tsx\",\n        lineNumber: 74,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Square;\n// Otimizao de renderizao\nconst MemoizedSquare = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().memo(Square);\n_c1 = MemoizedSquare;\nvar _c, _c1;\n$RefreshReg$(_c, \"Square\");\n$RefreshReg$(_c1, \"MemoizedSquare\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViL2NvbXBvbmVudHMvYm9hcmQvU3F1YXJlLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwQjtBQUVtQztBQWN0RCxNQUFNRSxTQUFnQyxTQVV2QztRQVZ3QyxFQUM1Q0MsU0FBUSxFQUNSQyxNQUFLLEVBQ0xDLFdBQVUsRUFDVkMsZUFBYyxFQUNkQyxXQUFVLEVBQ1ZDLGdCQUFlLEVBQ2ZDLGVBQWdCLFNBQVEsRUFDeEJDLFFBQU8sRUFDUEMsU0FBUSxFQUNUO0lBQ0MsTUFBTSxFQUFFQyxJQUFHLEVBQUVDLElBQUcsRUFBRSxHQUFHVjtJQUNyQixNQUFNVyxjQUFjYixtRUFBY0EsQ0FBQ1csS0FBS0M7SUFFeEMsdUVBQXVFO0lBQ3ZFLElBQUlFO0lBRUosb0RBQW9EO0lBQ3BELE1BQU1DLGNBQWM7UUFDbEJDLFFBQVE7WUFDTkMsT0FBTztZQUNQQyxNQUFNO1FBQ1I7UUFDQUMsU0FBUztZQUNQRixPQUFPO1lBQ1BDLE1BQU07UUFDUjtRQUNBRSxVQUFVO1lBQ1JILE9BQU87WUFDUEMsTUFBTTtRQUNSO0lBQ0Y7SUFFQSxtREFBbUQ7SUFDbkQsTUFBTUcsY0FBY04sV0FBVyxDQUFDUCxjQUEwQyxJQUFJTyxZQUFZQyxNQUFNO0lBRWhHLHFEQUFxRDtJQUNyRCxJQUFJWixZQUFZO1FBQ2RVLGtCQUFrQjtJQUNwQixPQUFPLElBQUlSLFlBQVk7UUFDckJRLGtCQUFrQjtJQUNwQixPQUFPLElBQUlULGdCQUFnQjtRQUN6QlMsa0JBQWtCO0lBQ3BCLE9BQU87UUFDTEEsa0JBQWtCTyxXQUFXLENBQUNSLFlBQVk7SUFDNUMsQ0FBQztJQUVELDRDQUE0QztJQUM1QyxNQUFNUyxPQUFPQyxPQUFPQyxZQUFZLENBQUMsSUFBSUMsVUFBVSxDQUFDLEtBQUtiO0lBQ3JELE1BQU1jLE9BQU8sSUFBSWY7SUFFakIsd0JBQXdCO0lBQ3hCLE1BQU1nQixjQUFjLElBQU07UUFDeEJsQixvQkFBQUEscUJBQUFBLEtBQUFBLElBQUFBLFFBQVVQO0lBQ1o7SUFFQSxxQkFDRSw4REFBQzBCO1FBQ0NDLFdBQVcseUtBVVB6QixPQURBQyxpQkFBaUIsbUJBQW1CLEVBQUUsRUFBQyxjQUV2Q0MsT0FEQUYsYUFBYSwyQkFBMkIsRUFBRSxFQUFDLGNBQ0QsT0FBMUNFLGFBQWEsMEJBQTBCLEVBQUUsRUFBQztRQUU5Q3dCLE9BQU87WUFDTGhCLGlCQUFpQkE7UUFDbkI7UUFDQUwsU0FBU2tCOztZQUdSdEIsa0JBQWtCLENBQUNGLHVCQUNsQiw4REFBQ3lCO2dCQUNDQyxXQUFVOzs7Ozs7WUFLYnhCLGtCQUFrQkYsdUJBQ2pCLDhEQUFDeUI7Z0JBQ0NDLFdBQVU7Ozs7OzswQkFLZCw4REFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ1puQjs7Ozs7O1lBSUZILGlDQUNDOztvQkFDR0ssUUFBUSxtQkFDUCw4REFBQ21CO3dCQUNDRixXQUFVO3dCQUNWQyxPQUFPOzRCQUFFRSxPQUFPbkIsZ0JBQWdCLFVBQVUsU0FBUyxNQUFNO3dCQUFDO2tDQUV6RGE7Ozs7OztvQkFHSmYsUUFBUSxtQkFDUCw4REFBQ29CO3dCQUNDRixXQUFVO3dCQUNWQyxPQUFPOzRCQUFFRSxPQUFPbkIsZ0JBQWdCLFVBQVUsU0FBUyxNQUFNO3dCQUFDO2tDQUV6RFM7Ozs7Ozs7OzBCQU9ULDhEQUFDTTtnQkFDQ0MsV0FBVTs7Ozs7Ozs7Ozs7O0FBSWxCLEVBQUU7S0EzSFc1QjtBQTZIYiw2QkFBNkI7QUFDdEIsTUFBTWdDLCtCQUFpQmxDLGlEQUFVLENBQUNFLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3dlYi9jb21wb25lbnRzL2JvYXJkL1NxdWFyZS50c3g/M2Q3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2hlc3NQb3NpdGlvbiwgQ2hlc3NQaWVjZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC90eXBlcy9jaGVzcyc7XG5pbXBvcnQgeyBnZXRTcXVhcmVDb2xvciB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy9jaGVzcyc7XG5cbmludGVyZmFjZSBTcXVhcmVQcm9wcyB7XG4gIHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uO1xuICBwaWVjZT86IENoZXNzUGllY2U7XG4gIGlzU2VsZWN0ZWQ/OiBib29sZWFuO1xuICBpc1Bvc3NpYmxlTW92ZT86IGJvb2xlYW47XG4gIGlzTGFzdE1vdmU/OiBib29sZWFuO1xuICBzaG93Q29vcmRpbmF0ZXM/OiBib29sZWFuO1xuICBjdWx0dXJhbFN0eWxlPzogc3RyaW5nO1xuICBvbkNsaWNrPzogKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uKSA9PiB2b2lkO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGNvbnN0IFNxdWFyZTogUmVhY3QuRkM8U3F1YXJlUHJvcHM+ID0gKHtcbiAgcG9zaXRpb24sXG4gIHBpZWNlLFxuICBpc1NlbGVjdGVkLFxuICBpc1Bvc3NpYmxlTW92ZSxcbiAgaXNMYXN0TW92ZSxcbiAgc2hvd0Nvb3JkaW5hdGVzLFxuICBjdWx0dXJhbFN0eWxlID0gJ21vZGVybicsXG4gIG9uQ2xpY2ssXG4gIGNoaWxkcmVuLFxufSkgPT4ge1xuICBjb25zdCB7IHJvdywgY29sIH0gPSBwb3NpdGlvbjtcbiAgY29uc3Qgc3F1YXJlQ29sb3IgPSBnZXRTcXVhcmVDb2xvcihyb3csIGNvbCk7XG4gIFxuICAvLyBEZXRlcm1pbmEgYSBjb3IgZmluYWwgZGEgY2FzYSBjb20gYmFzZSBub3MgZXN0YWRvcyBlIGVzdGlsbyBjdWx0dXJhbFxuICBsZXQgYmFja2dyb3VuZENvbG9yO1xuICBcbiAgLy8gQ29yZXMgYmFzZSBkbyB0YWJ1bGVpcm8gcGFyYSBjYWRhIGVzdGlsbyBjdWx0dXJhbFxuICBjb25zdCBib2FyZENvbG9ycyA9IHtcbiAgICBtb2Rlcm46IHtcbiAgICAgIGxpZ2h0OiAnI2YwZDliNScsXG4gICAgICBkYXJrOiAnI2I1ODg2MydcbiAgICB9LFxuICAgIGFuY2llbnQ6IHtcbiAgICAgIGxpZ2h0OiAnI2U2ZDVhYycsXG4gICAgICBkYXJrOiAnIzdjNmM1NCdcbiAgICB9LFxuICAgIG1lZGlldmFsOiB7XG4gICAgICBsaWdodDogJyNlZWQyYTQnLFxuICAgICAgZGFyazogJyM4YjQ1MTMnXG4gICAgfVxuICB9O1xuICBcbiAgLy8gU2VsZWNpb25hIGFzIGNvcmVzIGJhc2UgZG8gZXN0aWxvIGN1bHR1cmFsIGF0dWFsXG4gIGNvbnN0IHN0eWxlQ29sb3JzID0gYm9hcmRDb2xvcnNbY3VsdHVyYWxTdHlsZSBhcyBrZXlvZiB0eXBlb2YgYm9hcmRDb2xvcnNdIHx8IGJvYXJkQ29sb3JzLm1vZGVybjtcbiAgXG4gIC8vIEFwbGljYSBhcyBjb3JlcyBkZSBhY29yZG8gY29tIG8gZXN0YWRvIGRvIHF1YWRyYWRvXG4gIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgYmFja2dyb3VuZENvbG9yID0gJyNmY2QzNGQnO1xuICB9IGVsc2UgaWYgKGlzTGFzdE1vdmUpIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSAnIzM0ZDM5OSc7XG4gIH0gZWxzZSBpZiAoaXNQb3NzaWJsZU1vdmUpIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSAnI2ZiYmYyNCc7XG4gIH0gZWxzZSB7XG4gICAgYmFja2dyb3VuZENvbG9yID0gc3R5bGVDb2xvcnNbc3F1YXJlQ29sb3JdO1xuICB9XG5cbiAgLy8gR2VyYSBjb29yZGVuYWRhcyBhbGfDqWJyaWNhcyBwYXJhIGV4aWJpw6fDo29cbiAgY29uc3QgZmlsZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJ2EnLmNoYXJDb2RlQXQoMCkgKyBjb2wpO1xuICBjb25zdCByYW5rID0gOCAtIHJvdztcblxuICAvLyBNYW5pcHVsYWRvciBkZSBjbGlxdWVcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG4gICAgb25DbGljaz8uKHBvc2l0aW9uKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17YFxuICAgICAgICByZWxhdGl2ZVxuICAgICAgICB3LWZ1bGxcbiAgICAgICAgaC1mdWxsXG4gICAgICAgIGZsZXhcbiAgICAgICAgaXRlbXMtY2VudGVyXG4gICAgICAgIGp1c3RpZnktY2VudGVyXG4gICAgICAgIHRyYW5zaXRpb24tYWxsXG4gICAgICAgIGR1cmF0aW9uLTIwMFxuICAgICAgICAke2lzUG9zc2libGVNb3ZlID8gJ2N1cnNvci1wb2ludGVyJyA6ICcnfVxuICAgICAgICAke2lzU2VsZWN0ZWQgPyAncmluZy0yIHJpbmcteWVsbG93LTQwMCcgOiAnJ31cbiAgICAgICAgJHtpc0xhc3RNb3ZlID8gJ3JpbmctMiByaW5nLWdyZWVuLTQwMCcgOiAnJ31cbiAgICAgIGB9XG4gICAgICBzdHlsZT17e1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgIH19XG4gICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICA+XG4gICAgICB7LyogSW5kaWNhZG9yIGRlIG1vdmltZW50byBwb3Nzw612ZWwgKi99XG4gICAgICB7aXNQb3NzaWJsZU1vdmUgJiYgIXBpZWNlICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cInctMyBoLTMgcm91bmRlZC1mdWxsIGJnLXllbGxvdy00MDAgb3BhY2l0eS01MFwiXG4gICAgICAgIC8+XG4gICAgICApfVxuXG4gICAgICB7LyogSW5kaWNhZG9yIGRlIGNhcHR1cmEgcG9zc8OtdmVsICovfVxuICAgICAge2lzUG9zc2libGVNb3ZlICYmIHBpZWNlICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgYm9yZGVyLTIgYm9yZGVyLXllbGxvdy00MDAgb3BhY2l0eS01MFwiXG4gICAgICAgIC8+XG4gICAgICApfVxuXG4gICAgICB7LyogQ29udGXDumRvIGRhIGNhc2EgKHBlw6dhIG91IG91dHJvIGVsZW1lbnRvKSAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgei0xMFwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIENvb3JkZW5hZGFzICovfVxuICAgICAge3Nob3dDb29yZGluYXRlcyAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2NvbCA9PT0gMCAmJiAoXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMC41IGxlZnQtMSB0ZXh0LXhzIGZvbnQtYm9sZCBvcGFjaXR5LTc1XCJcbiAgICAgICAgICAgICAgc3R5bGU9e3sgY29sb3I6IHNxdWFyZUNvbG9yID09PSAnbGlnaHQnID8gJyM2NjYnIDogJyNmZmYnIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtyYW5rfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICl9XG4gICAgICAgICAge3JvdyA9PT0gNyAmJiAoXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBib3R0b20tMC41IHJpZ2h0LTEgdGV4dC14cyBmb250LWJvbGQgb3BhY2l0eS03NVwiXG4gICAgICAgICAgICAgIHN0eWxlPXt7IGNvbG9yOiBzcXVhcmVDb2xvciA9PT0gJ2xpZ2h0JyA/ICcjNjY2JyA6ICcjZmZmJyB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7ZmlsZX1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICApfVxuICAgICAgICA8Lz5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBFZmVpdG8gZGUgaG92ZXIgKi99XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgb3BhY2l0eS0wIGhvdmVyOm9wYWNpdHktMjAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTIwMCBiZy13aGl0ZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gT3RpbWl6YcOnw6NvIGRlIHJlbmRlcml6YcOnw6NvXG5leHBvcnQgY29uc3QgTWVtb2l6ZWRTcXVhcmUgPSBSZWFjdC5tZW1vKFNxdWFyZSk7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJnZXRTcXVhcmVDb2xvciIsIlNxdWFyZSIsInBvc2l0aW9uIiwicGllY2UiLCJpc1NlbGVjdGVkIiwiaXNQb3NzaWJsZU1vdmUiLCJpc0xhc3RNb3ZlIiwic2hvd0Nvb3JkaW5hdGVzIiwiY3VsdHVyYWxTdHlsZSIsIm9uQ2xpY2siLCJjaGlsZHJlbiIsInJvdyIsImNvbCIsInNxdWFyZUNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYm9hcmRDb2xvcnMiLCJtb2Rlcm4iLCJsaWdodCIsImRhcmsiLCJhbmNpZW50IiwibWVkaWV2YWwiLCJzdHlsZUNvbG9ycyIsImZpbGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUF0IiwicmFuayIsImhhbmRsZUNsaWNrIiwiZGl2IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJzcGFuIiwiY29sb3IiLCJNZW1vaXplZFNxdWFyZSIsIm1lbW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/web/components/board/Square.tsx\n"));

/***/ }),

/***/ "./src/web/components/controls/GameControls.tsx":
/*!******************************************************!*\
  !*** ./src/web/components/controls/GameControls.tsx ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameControls\": function() { return /* binding */ GameControls; },\n/* harmony export */   \"MemoizedGameControls\": function() { return /* binding */ MemoizedGameControls; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _shared_constants_game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/constants/game */ \"./src/shared/constants/game.ts\");\n\n\n\nconst GameControls = (param)=>{\n    let { culturalStyle , onStyleChange , onFlipBoard , onNewGame , onUndo , canUndo , isPlayerTurn  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col gap-4 p-6 bg-emerald-800/30 backdrop-blur-sm rounded-xl border border-emerald-600/50 shadow-xl\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-2xl font-bold text-white mb-4 flex items-center gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"w-8 h-8 flex items-center justify-center rounded-lg bg-emerald-500/20\",\n                        children: \"\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                        lineNumber: 27,\n                        columnNumber: 9\n                    }, undefined),\n                    \"Controles\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                lineNumber: 26,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"text-emerald-100 text-sm\",\n                        children: \"Estilo Cultural\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                        \"data-testid\": \"style-select\",\n                        value: culturalStyle,\n                        onChange: (e)=>onStyleChange(e.target.value),\n                        className: \" w-full bg-emerald-700/50 text-white  border border-emerald-600/50 rounded-lg  px-4 py-3  focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-colors hover:bg-emerald-700/70 \",\n                        children: Object.entries(_shared_constants_game__WEBPACK_IMPORTED_MODULE_2__.CULTURAL_STYLES).map((param)=>/*#__PURE__*/ {\n                            let [key, value] = param;\n                            return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                value: value,\n                                \"data-testid\": \"style-\".concat(value),\n                                children: value.charAt(0).toUpperCase() + value.slice(1)\n                            }, key, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                                lineNumber: 48,\n                                columnNumber: 13\n                            }, undefined);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                        lineNumber: 34,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                lineNumber: 32,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        \"data-testid\": \"new-game-btn\",\n                        onClick: onNewGame,\n                        className: \" bg-emerald-600/70 hover:bg-emerald-500  text-white font-medium rounded-lg px-4 py-3  transition-all duration-200 hover:shadow-lg hover:scale-[1.02] active:scale-[0.98] \",\n                        style: {\n                            backgroundImage: \"url('/images/buttons/\".concat(culturalStyle, \".png')\")\n                        },\n                        children: \"Nova Partida\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                        lineNumber: 57,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        \"data-testid\": \"flip-board-btn\",\n                        onClick: onFlipBoard,\n                        className: \" bg-emerald-600/70 hover:bg-emerald-500  text-white font-medium rounded-lg px-4 py-3  transition-all duration-200 hover:shadow-lg hover:scale-[1.02] active:scale-[0.98] \",\n                        style: {\n                            backgroundImage: \"url('/images/buttons/\".concat(culturalStyle, \".png')\")\n                        },\n                        children: \"Inverter Tabuleiro\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                        lineNumber: 75,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        \"data-testid\": \"undo-btn\",\n                        onClick: onUndo,\n                        disabled: !canUndo,\n                        className: \"\\n            col-span-2 \\n            \".concat(canUndo ? \"bg-emerald-600/70 hover:bg-emerald-500 hover:shadow-lg hover:scale-[1.02] active:scale-[0.98]\" : \"bg-emerald-800/50 cursor-not-allowed opacity-50\", \"\\n            text-white font-medium\\n            rounded-lg px-4 py-3\\n            transition-all duration-200\\n          \"),\n                        style: canUndo ? {\n                            backgroundImage: \"url('/images/buttons/\".concat(culturalStyle, \".png')\")\n                        } : undefined,\n                        children: \"Desfazer Jogada\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                        lineNumber: 93,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                lineNumber: 56,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-2 text-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    \"data-testid\": \"game-status\",\n                    \"data-state\": isPlayerTurn ? \"playing\" : \"waiting\",\n                    className: \"text-emerald-100\",\n                    children: isPlayerTurn ? \"Sua vez de jogar\" : \"Aguardando oponente...\"\n                }, void 0, false, {\n                    fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                    lineNumber: 122,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n                lineNumber: 121,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/controls/GameControls.tsx\",\n        lineNumber: 25,\n        columnNumber: 5\n    }, undefined);\n};\n_c = GameControls;\nconst MemoizedGameControls = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().memo(GameControls);\n_c1 = MemoizedGameControls;\nvar _c, _c1;\n$RefreshReg$(_c, \"GameControls\");\n$RefreshReg$(_c1, \"MemoizedGameControls\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViL2NvbXBvbmVudHMvY29udHJvbHMvR2FtZUNvbnRyb2xzLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwQjtBQUN1QztBQWExRCxNQUFNRSxlQUE0QyxTQVFuRDtRQVJvRCxFQUN4REMsY0FBYSxFQUNiQyxjQUFhLEVBQ2JDLFlBQVcsRUFDWEMsVUFBUyxFQUNUQyxPQUFNLEVBQ05DLFFBQU8sRUFDUEMsYUFBWSxFQUNiO0lBQ0MscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDQztnQkFBR0QsV0FBVTs7a0NBQ1osOERBQUNFO3dCQUFLRixXQUFVO2tDQUF3RTs7Ozs7O29CQUFTOzs7Ozs7OzBCQUtuRyw4REFBQ0Q7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDRzt3QkFBTUgsV0FBVTtrQ0FBMkI7Ozs7OztrQ0FDNUMsOERBQUNJO3dCQUNDQyxlQUFZO3dCQUNaQyxPQUFPZDt3QkFDUGUsVUFBVSxDQUFDQyxJQUFNZixjQUFjZSxFQUFFQyxNQUFNLENBQUNILEtBQUs7d0JBQzdDTixXQUFVO2tDQVNUVSxPQUFPQyxPQUFPLENBQUNyQixtRUFBZUEsRUFBRXNCLEdBQUcsQ0FBQyx1QkFDbkM7Z0NBRG9DLENBQUNDLEtBQUtQLE1BQU07bUNBQ2hELDhEQUFDUTtnQ0FBaUJSLE9BQU9BO2dDQUFPRCxlQUFhLFNBQWUsT0FBTkM7MENBQ25EQSxNQUFNUyxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLVixNQUFNVyxLQUFLLENBQUM7K0JBRGxDSjs7Ozs7d0JBRUw7Ozs7Ozs7Ozs7OzswQkFNZCw4REFBQ2Q7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDa0I7d0JBQ0NiLGVBQVk7d0JBQ1pjLFNBQVN4Qjt3QkFDVEssV0FBVTt3QkFRVm9CLE9BQU87NEJBQ0xDLGlCQUFpQix3QkFBc0MsT0FBZDdCLGVBQWM7d0JBQ3pEO2tDQUNEOzs7Ozs7a0NBSUQsOERBQUMwQjt3QkFDQ2IsZUFBWTt3QkFDWmMsU0FBU3pCO3dCQUNUTSxXQUFVO3dCQVFWb0IsT0FBTzs0QkFDTEMsaUJBQWlCLHdCQUFzQyxPQUFkN0IsZUFBYzt3QkFDekQ7a0NBQ0Q7Ozs7OztrQ0FJRCw4REFBQzBCO3dCQUNDYixlQUFZO3dCQUNaYyxTQUFTdkI7d0JBQ1QwQixVQUFVLENBQUN6Qjt3QkFDWEcsV0FBVywwQ0FNUixPQUhESCxVQUNJLGtHQUNBLGlEQUFpRCxFQUNwRDt3QkFLSHVCLE9BQ0V2QixVQUNJOzRCQUNFd0IsaUJBQWlCLHdCQUFzQyxPQUFkN0IsZUFBYzt3QkFDekQsSUFDQStCLFNBQVM7a0NBRWhCOzs7Ozs7Ozs7Ozs7MEJBTUgsOERBQUN4QjtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ3dCO29CQUNDbkIsZUFBWTtvQkFDWm9CLGNBQVkzQixlQUFlLFlBQVksU0FBUztvQkFDaERFLFdBQVU7OEJBQ1RGLGVBQWUscUJBQXFCLHdCQUF3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLdkUsRUFBRTtLQXBIV1A7QUFzSE4sTUFBTW1DLHFDQUF1QnJDLGlEQUFVLENBQUNFLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3dlYi9jb21wb25lbnRzL2NvbnRyb2xzL0dhbWVDb250cm9scy50c3g/Mzg4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ1VMVFVSQUxfU1RZTEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYW1lJztcbmltcG9ydCB7IHRoZW1lIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3N0eWxlcy90aGVtZSc7XG5cbmludGVyZmFjZSBHYW1lQ29udHJvbHNQcm9wcyB7XG4gIGN1bHR1cmFsU3R5bGU6IHN0cmluZztcbiAgb25TdHlsZUNoYW5nZTogKHN0eWxlOiBzdHJpbmcpID0+IHZvaWQ7XG4gIG9uRmxpcEJvYXJkOiAoKSA9PiB2b2lkO1xuICBvbk5ld0dhbWU6ICgpID0+IHZvaWQ7XG4gIG9uVW5kbzogKCkgPT4gdm9pZDtcbiAgY2FuVW5kbzogYm9vbGVhbjtcbiAgaXNQbGF5ZXJUdXJuOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgR2FtZUNvbnRyb2xzOiBSZWFjdC5GQzxHYW1lQ29udHJvbHNQcm9wcz4gPSAoe1xuICBjdWx0dXJhbFN0eWxlLFxuICBvblN0eWxlQ2hhbmdlLFxuICBvbkZsaXBCb2FyZCxcbiAgb25OZXdHYW1lLFxuICBvblVuZG8sXG4gIGNhblVuZG8sXG4gIGlzUGxheWVyVHVybixcbn0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTQgcC02IGJnLWVtZXJhbGQtODAwLzMwIGJhY2tkcm9wLWJsdXItc20gcm91bmRlZC14bCBib3JkZXIgYm9yZGVyLWVtZXJhbGQtNjAwLzUwIHNoYWRvdy14bFwiPlxuICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1iLTQgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWxnIGJnLWVtZXJhbGQtNTAwLzIwXCI+4pqZ77iPPC9zcGFuPlxuICAgICAgICBDb250cm9sZXNcbiAgICAgIDwvaDI+XG4gICAgICBcbiAgICAgIHsvKiBFc3RpbG8gQ3VsdHVyYWwgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTJcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInRleHQtZW1lcmFsZC0xMDAgdGV4dC1zbVwiPkVzdGlsbyBDdWx0dXJhbDwvbGFiZWw+XG4gICAgICAgIDxzZWxlY3RcbiAgICAgICAgICBkYXRhLXRlc3RpZD1cInN0eWxlLXNlbGVjdFwiXG4gICAgICAgICAgdmFsdWU9e2N1bHR1cmFsU3R5bGV9XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBvblN0eWxlQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJcbiAgICAgICAgICAgIHctZnVsbCBiZy1lbWVyYWxkLTcwMC81MCB0ZXh0LXdoaXRlIFxuICAgICAgICAgICAgYm9yZGVyIGJvcmRlci1lbWVyYWxkLTYwMC81MCByb3VuZGVkLWxnIFxuICAgICAgICAgICAgcHgtNCBweS0zIFxuICAgICAgICAgICAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWVtZXJhbGQtNTAwXG4gICAgICAgICAgICB0cmFuc2l0aW9uLWNvbG9yc1xuICAgICAgICAgICAgaG92ZXI6YmctZW1lcmFsZC03MDAvNzBcbiAgICAgICAgICBcIlxuICAgICAgICA+XG4gICAgICAgICAge09iamVjdC5lbnRyaWVzKENVTFRVUkFMX1NUWUxFUykubWFwKChba2V5LCB2YWx1ZV0pID0+IChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtrZXl9IHZhbHVlPXt2YWx1ZX0gZGF0YS10ZXN0aWQ9e2BzdHlsZS0ke3ZhbHVlfWB9PlxuICAgICAgICAgICAgICB7dmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKX1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L3NlbGVjdD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogQm90w7VlcyBkZSBBw6fDo28gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTJcIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGRhdGEtdGVzdGlkPVwibmV3LWdhbWUtYnRuXCJcbiAgICAgICAgICBvbkNsaWNrPXtvbk5ld0dhbWV9XG4gICAgICAgICAgY2xhc3NOYW1lPVwiXG4gICAgICAgICAgICBiZy1lbWVyYWxkLTYwMC83MCBob3ZlcjpiZy1lbWVyYWxkLTUwMCBcbiAgICAgICAgICAgIHRleHQtd2hpdGUgZm9udC1tZWRpdW1cbiAgICAgICAgICAgIHJvdW5kZWQtbGcgcHgtNCBweS0zIFxuICAgICAgICAgICAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwXG4gICAgICAgICAgICBob3ZlcjpzaGFkb3ctbGcgaG92ZXI6c2NhbGUtWzEuMDJdXG4gICAgICAgICAgICBhY3RpdmU6c2NhbGUtWzAuOThdXG4gICAgICAgICAgXCJcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCcvaW1hZ2VzL2J1dHRvbnMvJHtjdWx0dXJhbFN0eWxlfS5wbmcnKWBcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgTm92YSBQYXJ0aWRhXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGRhdGEtdGVzdGlkPVwiZmxpcC1ib2FyZC1idG5cIlxuICAgICAgICAgIG9uQ2xpY2s9e29uRmxpcEJvYXJkfVxuICAgICAgICAgIGNsYXNzTmFtZT1cIlxuICAgICAgICAgICAgYmctZW1lcmFsZC02MDAvNzAgaG92ZXI6YmctZW1lcmFsZC01MDAgXG4gICAgICAgICAgICB0ZXh0LXdoaXRlIGZvbnQtbWVkaXVtXG4gICAgICAgICAgICByb3VuZGVkLWxnIHB4LTQgcHktMyBcbiAgICAgICAgICAgIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMFxuICAgICAgICAgICAgaG92ZXI6c2hhZG93LWxnIGhvdmVyOnNjYWxlLVsxLjAyXVxuICAgICAgICAgICAgYWN0aXZlOnNjYWxlLVswLjk4XVxuICAgICAgICAgIFwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnL2ltYWdlcy9idXR0b25zLyR7Y3VsdHVyYWxTdHlsZX0ucG5nJylgXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIEludmVydGVyIFRhYnVsZWlyb1xuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgZGF0YS10ZXN0aWQ9XCJ1bmRvLWJ0blwiXG4gICAgICAgICAgb25DbGljaz17b25VbmRvfVxuICAgICAgICAgIGRpc2FibGVkPXshY2FuVW5kb31cbiAgICAgICAgICBjbGFzc05hbWU9e2BcbiAgICAgICAgICAgIGNvbC1zcGFuLTIgXG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgY2FuVW5kbyBcbiAgICAgICAgICAgICAgPyAnYmctZW1lcmFsZC02MDAvNzAgaG92ZXI6YmctZW1lcmFsZC01MDAgaG92ZXI6c2hhZG93LWxnIGhvdmVyOnNjYWxlLVsxLjAyXSBhY3RpdmU6c2NhbGUtWzAuOThdJyBcbiAgICAgICAgICAgICAgOiAnYmctZW1lcmFsZC04MDAvNTAgY3Vyc29yLW5vdC1hbGxvd2VkIG9wYWNpdHktNTAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LXdoaXRlIGZvbnQtbWVkaXVtXG4gICAgICAgICAgICByb3VuZGVkLWxnIHB4LTQgcHktM1xuICAgICAgICAgICAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwXG4gICAgICAgICAgYH1cbiAgICAgICAgICBzdHlsZT17XG4gICAgICAgICAgICBjYW5VbmRvXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCcvaW1hZ2VzL2J1dHRvbnMvJHtjdWx0dXJhbFN0eWxlfS5wbmcnKWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgICAgICAgRGVzZmF6ZXIgSm9nYWRhXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBTdGF0dXMgZG8gSm9nbyAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMiB0ZXh0LWNlbnRlclwiPlxuICAgICAgICA8cCBcbiAgICAgICAgICBkYXRhLXRlc3RpZD1cImdhbWUtc3RhdHVzXCJcbiAgICAgICAgICBkYXRhLXN0YXRlPXtpc1BsYXllclR1cm4gPyBcInBsYXlpbmdcIiA6IFwid2FpdGluZ1wifVxuICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtZW1lcmFsZC0xMDBcIj5cbiAgICAgICAgICB7aXNQbGF5ZXJUdXJuID8gJ1N1YSB2ZXogZGUgam9nYXInIDogJ0FndWFyZGFuZG8gb3BvbmVudGUuLi4nfVxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBNZW1vaXplZEdhbWVDb250cm9scyA9IFJlYWN0Lm1lbW8oR2FtZUNvbnRyb2xzKTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkNVTFRVUkFMX1NUWUxFUyIsIkdhbWVDb250cm9scyIsImN1bHR1cmFsU3R5bGUiLCJvblN0eWxlQ2hhbmdlIiwib25GbGlwQm9hcmQiLCJvbk5ld0dhbWUiLCJvblVuZG8iLCJjYW5VbmRvIiwiaXNQbGF5ZXJUdXJuIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJzcGFuIiwibGFiZWwiLCJzZWxlY3QiLCJkYXRhLXRlc3RpZCIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImtleSIsIm9wdGlvbiIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJidXR0b24iLCJvbkNsaWNrIiwic3R5bGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkaXNhYmxlZCIsInVuZGVmaW5lZCIsInAiLCJkYXRhLXN0YXRlIiwiTWVtb2l6ZWRHYW1lQ29udHJvbHMiLCJtZW1vIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/web/components/controls/GameControls.tsx\n"));

/***/ }),

/***/ "./src/web/components/info/GameInfo.tsx":
/*!**********************************************!*\
  !*** ./src/web/components/info/GameInfo.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameInfo\": function() { return /* binding */ GameInfo; },\n/* harmony export */   \"MemoizedGameInfo\": function() { return /* binding */ MemoizedGameInfo; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst GameInfo = (param)=>{\n    let { culturalStyle , moves , evaluation , narratives , events  } = param;\n    // Formata a avaliao como string com sinal\n    const formatEvaluation = (value)=>{\n        const absEval = Math.abs(value);\n        const sign = value > 0 ? \"+\" : value < 0 ? \"-\" : \"\";\n        return \"\".concat(sign).concat(absEval.toFixed(1));\n    };\n    // Formata o movimento para exibio\n    const formatMove = (move)=>{\n        const pieceSymbols = {\n            p: \"\",\n            n: \"N\",\n            b: \"B\",\n            r: \"R\",\n            q: \"Q\",\n            k: \"K\"\n        };\n        const piece = pieceSymbols[move.piece.type] || \"\";\n        const capture = move.captured ? \"x\" : \"\";\n        const promotion = move.promotion ? \"=\".concat(pieceSymbols[move.promotion]) : \"\";\n        const to = \"\".concat(String.fromCharCode(97 + move.to.col)).concat(8 - move.to.row);\n        return \"\".concat(piece).concat(capture).concat(to).concat(promotion);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"flex flex-col gap-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-testid\": \"evaluation-panel\",\n                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"bg-emerald-800/30 backdrop-blur-sm rounded-xl border border-emerald-600/50 shadow-xl p-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-2xl font-bold text-white mb-4 flex items-center gap-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"w-8 h-8 flex items-center justify-center rounded-lg bg-emerald-500/20\",\n                                children: \"\\uD83D\\uDCCA\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 11\n                            }, undefined),\n                            \"Avalia\\xe7\\xe3o\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 56,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"flex items-center justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-emerald-100\",\n                                children: \"Posi\\xe7\\xe3o atual:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 61,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                \"data-testid\": \"evaluation-value\",\n                                \"data-value\": evaluation,\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-lg font-bold \".concat(evaluation > 0 ? \"text-emerald-400\" : evaluation < 0 ? \"text-red-400\" : \"text-gray-400\"),\n                                children: formatEvaluation(evaluation)\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 62,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                lineNumber: 52,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-testid\": \"narratives-panel\",\n                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"bg-emerald-800/30 backdrop-blur-sm rounded-xl border border-emerald-600/50 shadow-xl p-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-2xl font-bold text-white mb-4 flex items-center gap-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"w-8 h-8 flex items-center justify-center rounded-lg bg-emerald-500/20\",\n                                children: \"\\uD83D\\uDCD6\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 84,\n                                columnNumber: 11\n                            }, undefined),\n                            \"Narrativas\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 83,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"space-y-2\",\n                        children: narratives.map((narrative, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                \"data-testid\": \"narrative-\".concat(index),\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-emerald-100 text-sm\",\n                                children: narrative\n                            }, index, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 89,\n                                columnNumber: 13\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 87,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                lineNumber: 79,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-testid\": \"move-history\",\n                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"bg-emerald-800/30 backdrop-blur-sm rounded-xl border border-emerald-600/50 shadow-xl p-6 max-h-48 overflow-y-auto scrollbar-custom\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-2xl font-bold text-white mb-4 flex items-center gap-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"w-8 h-8 flex items-center justify-center rounded-lg bg-emerald-500/20\",\n                                children: \"\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 106,\n                                columnNumber: 11\n                            }, undefined),\n                            \"Movimentos\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 105,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"grid grid-cols-2 gap-2\",\n                        children: moves.map((move, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                \"data-testid\": \"move-history-item-\".concat(index),\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-sm \".concat(index % 2 === 0 ? \"text-right\" : \"text-left\"),\n                                children: [\n                                    index % 2 === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-emerald-400 mr-2\",\n                                        children: [\n                                            Math.floor(index / 2) + 1,\n                                            \".\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                        lineNumber: 117,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-emerald-100\",\n                                        children: formatMove(move)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                        lineNumber: 121,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, index, true, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 111,\n                                columnNumber: 13\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 109,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                lineNumber: 101,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                \"data-testid\": \"events-panel\",\n                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"bg-emerald-800/30 backdrop-blur-sm rounded-xl border border-emerald-600/50 shadow-xl p-6 max-h-48 overflow-y-auto scrollbar-custom\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-2xl font-bold text-white mb-4 flex items-center gap-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"w-8 h-8 flex items-center justify-center rounded-lg bg-emerald-500/20\",\n                                children: \"\\uD83C\\uDFAD\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 133,\n                                columnNumber: 11\n                            }, undefined),\n                            \"Eventos\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 132,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"space-y-2\",\n                        children: events.map((event, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                \"data-testid\": \"event-\".concat(index),\n                                className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"flex items-center gap-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-emerald-400 text-xs\",\n                                        children: new Date(event.timestamp).toLocaleTimeString()\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                        lineNumber: 143,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"jsx-69ab07c9acd91bbc\" + \" \" + \"text-emerald-100 text-sm\",\n                                        children: event.description\n                                    }, void 0, false, {\n                                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                        lineNumber: 146,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, index, true, {\n                                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                                lineNumber: 138,\n                                columnNumber: 13\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                        lineNumber: 136,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n                lineNumber: 128,\n                columnNumber: 7\n            }, undefined),\n            (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"69ab07c9acd91bbc\",\n                children: \".scrollbar-custom{scrollbar-width:thin;scrollbar-color:#059669#065f46}.scrollbar-custom::-webkit-scrollbar{width:8px}.scrollbar-custom::-webkit-scrollbar-track{background:#065f46;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.scrollbar-custom::-webkit-scrollbar-thumb{background:#059669;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.scrollbar-custom::-webkit-scrollbar-thumb:hover{background:#10b981}\"\n            }, void 0, false, void 0, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jx/WORKSPACE/PROJECTS/CHESS/src/web/components/info/GameInfo.tsx\",\n        lineNumber: 50,\n        columnNumber: 5\n    }, undefined);\n};\n_c = GameInfo;\nconst MemoizedGameInfo = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().memo(GameInfo);\n_c1 = MemoizedGameInfo;\nvar _c, _c1;\n$RefreshReg$(_c, \"GameInfo\");\n$RefreshReg$(_c1, \"MemoizedGameInfo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QmIsOERBQUNQO2dCQUNDQyxlQUFZOzBEQUNGOztrQ0FFViw4REFBQ0M7a0VBQWE7OzBDQUNaLDhEQUFDQzswRUFBZTswQ0FBd0U7Ozs7Ozs0QkFBUzs7Ozs7OztrQ0FHbkcsOERBQUNIO2tFQUFjO2tDQUNaM0IsT0FBT2dDLEdBQUcsQ0FBQyxDQUFDSSxPQUFPRixzQkFDbEIsOERBQUNQO2dDQUVDQyxlQUFhLFNBQWUsT0FBTk07MEVBQ1o7O2tEQUVWLDhEQUFDSjtrRkFBZTtrREFDYixJQUFJTyxLQUFLRCxNQUFNRSxTQUFTLEVBQUVDLGtCQUFrQjs7Ozs7O2tEQUUvQyw4REFBQ1Q7a0ZBQWU7a0RBQ2JNLE1BQU1JLFdBQVc7Ozs7Ozs7K0JBUmZOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDbkIsRUFBRTtLQWpLV3ZDO0FBbUtOLE1BQU04QyxpQ0FBbUIvQyxpREFBVSxDQUFDQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy93ZWIvY29tcG9uZW50cy9pbmZvL0dhbWVJbmZvLnRzeD9jM2JhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGVzc01vdmUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdHlwZXMvY2hlc3MnO1xuXG5pbnRlcmZhY2UgR2FtZUluZm9Qcm9wcyB7XG4gIGN1bHR1cmFsU3R5bGU6IHN0cmluZztcbiAgbW92ZXM6IENoZXNzTW92ZVtdO1xuICBldmFsdWF0aW9uOiBudW1iZXI7XG4gIG5hcnJhdGl2ZXM6IHN0cmluZ1tdO1xuICBldmVudHM6IEFycmF5PHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgfT47XG59XG5cbmV4cG9ydCBjb25zdCBHYW1lSW5mbzogUmVhY3QuRkM8R2FtZUluZm9Qcm9wcz4gPSAoe1xuICBjdWx0dXJhbFN0eWxlLFxuICBtb3ZlcyxcbiAgZXZhbHVhdGlvbixcbiAgbmFycmF0aXZlcyxcbiAgZXZlbnRzLFxufSkgPT4ge1xuICAvLyBGb3JtYXRhIGEgYXZhbGlhw6fDo28gY29tbyBzdHJpbmcgY29tIHNpbmFsXG4gIGNvbnN0IGZvcm1hdEV2YWx1YXRpb24gPSAodmFsdWU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgYWJzRXZhbCA9IE1hdGguYWJzKHZhbHVlKTtcbiAgICBjb25zdCBzaWduID0gdmFsdWUgPiAwID8gJysnIDogdmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgcmV0dXJuIGAke3NpZ259JHthYnNFdmFsLnRvRml4ZWQoMSl9YDtcbiAgfTtcblxuICAvLyBGb3JtYXRhIG8gbW92aW1lbnRvIHBhcmEgZXhpYmnDp8Ojb1xuICBjb25zdCBmb3JtYXRNb3ZlID0gKG1vdmU6IENoZXNzTW92ZSk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgcGllY2VTeW1ib2xzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgcDogJycsXG4gICAgICBuOiAnTicsXG4gICAgICBiOiAnQicsXG4gICAgICByOiAnUicsXG4gICAgICBxOiAnUScsXG4gICAgICBrOiAnSycsXG4gICAgfTtcblxuICAgIGNvbnN0IHBpZWNlID0gcGllY2VTeW1ib2xzW21vdmUucGllY2UudHlwZV0gfHwgJyc7XG4gICAgY29uc3QgY2FwdHVyZSA9IG1vdmUuY2FwdHVyZWQgPyAneCcgOiAnJztcbiAgICBjb25zdCBwcm9tb3Rpb24gPSBtb3ZlLnByb21vdGlvbiA/IGA9JHtwaWVjZVN5bWJvbHNbbW92ZS5wcm9tb3Rpb25dfWAgOiAnJztcbiAgICBjb25zdCB0byA9IGAke1N0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBtb3ZlLnRvLmNvbCl9JHs4IC0gbW92ZS50by5yb3d9YDtcblxuICAgIHJldHVybiBgJHtwaWVjZX0ke2NhcHR1cmV9JHt0b30ke3Byb21vdGlvbn1gO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00XCI+XG4gICAgICB7LyogQXZhbGlhw6fDo28gKi99XG4gICAgICA8ZGl2IFxuICAgICAgICBkYXRhLXRlc3RpZD1cImV2YWx1YXRpb24tcGFuZWxcIlxuICAgICAgICBjbGFzc05hbWU9XCJiZy1lbWVyYWxkLTgwMC8zMCBiYWNrZHJvcC1ibHVyLXNtIHJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci1lbWVyYWxkLTYwMC81MCBzaGFkb3cteGwgcC02XCJcbiAgICAgID5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1iLTQgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ3LTggaC04IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbGcgYmctZW1lcmFsZC01MDAvMjBcIj7wn5OKPC9zcGFuPlxuICAgICAgICAgIEF2YWxpYcOnw6NvXG4gICAgICAgIDwvaDI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1lbWVyYWxkLTEwMFwiPlBvc2nDp8OjbyBhdHVhbDo8L3NwYW4+XG4gICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwiZXZhbHVhdGlvbi12YWx1ZVwiXG4gICAgICAgICAgICBkYXRhLXZhbHVlPXtldmFsdWF0aW9ufVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC1sZyBmb250LWJvbGQgJHtcbiAgICAgICAgICAgICAgZXZhbHVhdGlvbiA+IDBcbiAgICAgICAgICAgICAgICA/ICd0ZXh0LWVtZXJhbGQtNDAwJ1xuICAgICAgICAgICAgICAgIDogZXZhbHVhdGlvbiA8IDBcbiAgICAgICAgICAgICAgICA/ICd0ZXh0LXJlZC00MDAnXG4gICAgICAgICAgICAgICAgOiAndGV4dC1ncmF5LTQwMCdcbiAgICAgICAgICAgIH1gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtmb3JtYXRFdmFsdWF0aW9uKGV2YWx1YXRpb24pfVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIE5hcnJhdGl2YXMgQ3VsdHVyYWlzICovfVxuICAgICAgPGRpdiBcbiAgICAgICAgZGF0YS10ZXN0aWQ9XCJuYXJyYXRpdmVzLXBhbmVsXCJcbiAgICAgICAgY2xhc3NOYW1lPVwiYmctZW1lcmFsZC04MDAvMzAgYmFja2Ryb3AtYmx1ci1zbSByb3VuZGVkLXhsIGJvcmRlciBib3JkZXItZW1lcmFsZC02MDAvNTAgc2hhZG93LXhsIHAtNlwiXG4gICAgICA+XG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC13aGl0ZSBtYi00IGZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWxnIGJnLWVtZXJhbGQtNTAwLzIwXCI+8J+Tljwvc3Bhbj5cbiAgICAgICAgICBOYXJyYXRpdmFzXG4gICAgICAgIDwvaDI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAge25hcnJhdGl2ZXMubWFwKChuYXJyYXRpdmUsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAga2V5PXtpbmRleH0gXG4gICAgICAgICAgICAgIGRhdGEtdGVzdGlkPXtgbmFycmF0aXZlLSR7aW5kZXh9YH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1lbWVyYWxkLTEwMCB0ZXh0LXNtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge25hcnJhdGl2ZX1cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIEhpc3TDs3JpY28gZGUgTW92aW1lbnRvcyAqL31cbiAgICAgIDxkaXZcbiAgICAgICAgZGF0YS10ZXN0aWQ9XCJtb3ZlLWhpc3RvcnlcIlxuICAgICAgICBjbGFzc05hbWU9XCJiZy1lbWVyYWxkLTgwMC8zMCBiYWNrZHJvcC1ibHVyLXNtIHJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci1lbWVyYWxkLTYwMC81MCBzaGFkb3cteGwgcC02IG1heC1oLTQ4IG92ZXJmbG93LXktYXV0byBzY3JvbGxiYXItY3VzdG9tXCJcbiAgICAgID5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1iLTQgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ3LTggaC04IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbGcgYmctZW1lcmFsZC01MDAvMjBcIj7imZ/vuI88L3NwYW4+XG4gICAgICAgICAgTW92aW1lbnRvc1xuICAgICAgICA8L2gyPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTJcIj5cbiAgICAgICAgICB7bW92ZXMubWFwKChtb3ZlLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17YG1vdmUtaGlzdG9yeS1pdGVtLSR7aW5kZXh9YH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC1zbSAke2luZGV4ICUgMiA9PT0gMCA/ICd0ZXh0LXJpZ2h0JyA6ICd0ZXh0LWxlZnQnfWB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtpbmRleCAlIDIgPT09IDAgJiYgKFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZW1lcmFsZC00MDAgbXItMlwiPlxuICAgICAgICAgICAgICAgICAge01hdGguZmxvb3IoaW5kZXggLyAyKSArIDF9LlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1lbWVyYWxkLTEwMFwiPntmb3JtYXRNb3ZlKG1vdmUpfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogRXZlbnRvcyBDdWx0dXJhaXMgKi99XG4gICAgICA8ZGl2XG4gICAgICAgIGRhdGEtdGVzdGlkPVwiZXZlbnRzLXBhbmVsXCJcbiAgICAgICAgY2xhc3NOYW1lPVwiYmctZW1lcmFsZC04MDAvMzAgYmFja2Ryb3AtYmx1ci1zbSByb3VuZGVkLXhsIGJvcmRlciBib3JkZXItZW1lcmFsZC02MDAvNTAgc2hhZG93LXhsIHAtNiBtYXgtaC00OCBvdmVyZmxvdy15LWF1dG8gc2Nyb2xsYmFyLWN1c3RvbVwiXG4gICAgICA+XG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC13aGl0ZSBtYi00IGZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWxnIGJnLWVtZXJhbGQtNTAwLzIwXCI+8J+OrTwvc3Bhbj5cbiAgICAgICAgICBFdmVudG9zXG4gICAgICAgIDwvaDI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAge2V2ZW50cy5tYXAoKGV2ZW50LCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAga2V5PXtpbmRleH0gXG4gICAgICAgICAgICAgIGRhdGEtdGVzdGlkPXtgZXZlbnQtJHtpbmRleH1gfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZW1lcmFsZC00MDAgdGV4dC14c1wiPlxuICAgICAgICAgICAgICAgIHtuZXcgRGF0ZShldmVudC50aW1lc3RhbXApLnRvTG9jYWxlVGltZVN0cmluZygpfVxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZW1lcmFsZC0xMDAgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICAgIHtldmVudC5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBFc3RpbG8gcGFyYSBzY3JvbGxiYXJzICovfVxuICAgICAgPHN0eWxlIGpzeCBnbG9iYWw+e2BcbiAgICAgICAgLnNjcm9sbGJhci1jdXN0b20ge1xuICAgICAgICAgIHNjcm9sbGJhci13aWR0aDogdGhpbjtcbiAgICAgICAgICBzY3JvbGxiYXItY29sb3I6ICMwNTk2NjkgIzA2NWY0NjtcbiAgICAgICAgfVxuICAgICAgICAuc2Nyb2xsYmFyLWN1c3RvbTo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgICAgICAgIHdpZHRoOiA4cHg7XG4gICAgICAgIH1cbiAgICAgICAgLnNjcm9sbGJhci1jdXN0b206Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAjMDY1ZjQ2O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgfVxuICAgICAgICAuc2Nyb2xsYmFyLWN1c3RvbTo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICMwNTk2Njk7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICB9XG4gICAgICAgIC5zY3JvbGxiYXItY3VzdG9tOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogIzEwYjk4MTtcbiAgICAgICAgfVxuICAgICAgYH08L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IE1lbW9pemVkR2FtZUluZm8gPSBSZWFjdC5tZW1vKEdhbWVJbmZvKTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkdhbWVJbmZvIiwiY3VsdHVyYWxTdHlsZSIsIm1vdmVzIiwiZXZhbHVhdGlvbiIsIm5hcnJhdGl2ZXMiLCJldmVudHMiLCJmb3JtYXRFdmFsdWF0aW9uIiwidmFsdWUiLCJhYnNFdmFsIiwiTWF0aCIsImFicyIsInNpZ24iLCJ0b0ZpeGVkIiwiZm9ybWF0TW92ZSIsIm1vdmUiLCJwaWVjZVN5bWJvbHMiLCJwIiwibiIsImIiLCJyIiwicSIsImsiLCJwaWVjZSIsInR5cGUiLCJjYXB0dXJlIiwiY2FwdHVyZWQiLCJwcm9tb3Rpb24iLCJ0byIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvbCIsInJvdyIsImRpdiIsImRhdGEtdGVzdGlkIiwiaDIiLCJzcGFuIiwiZGF0YS12YWx1ZSIsIm1hcCIsIm5hcnJhdGl2ZSIsImluZGV4IiwiZmxvb3IiLCJldmVudCIsIkRhdGUiLCJ0aW1lc3RhbXAiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJkZXNjcmlwdGlvbiIsIk1lbW9pemVkR2FtZUluZm8iLCJtZW1vIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/web/components/info/GameInfo.tsx\n"));

/***/ }),

/***/ "./src/web/hooks/useGameState.ts":
/*!***************************************!*\
  !*** ./src/web/hooks/useGameState.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useGameState\": function() { return /* binding */ useGameState; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_constants_game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/constants/game */ \"./src/shared/constants/game.ts\");\n/* harmony import */ var _shared_utils_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/utils/id */ \"./src/shared/utils/id.ts\");\n/* harmony import */ var _shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils/chess */ \"./src/shared/utils/chess.ts\");\n\n\n\n\nfunction useGameState() {\n    let { initialFen =_shared_constants_game__WEBPACK_IMPORTED_MODULE_1__.INITIAL_FEN , culturalStyle =\"modern\" , timeControl  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Estado do jogo\n    const [gameState, setGameState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        id: (0,_shared_utils_id__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n        fen: initialFen,\n        moveHistory: [],\n        currentPlayer: \"white\",\n        isCheck: false,\n        isCheckmate: false,\n        isDraw: false,\n        status: _shared_constants_game__WEBPACK_IMPORTED_MODULE_1__.GAME_STATUS.ACTIVE,\n        timeControl\n    });\n    // Estado da interface\n    const [selectedSquare, setSelectedSquare] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [possibleMoves, setPossibleMoves] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [lastMove, setLastMove] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Reseta o jogo para o estado inicial\n    const resetGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setGameState({\n            id: (0,_shared_utils_id__WEBPACK_IMPORTED_MODULE_2__.generateId)(),\n            fen: initialFen,\n            moveHistory: [],\n            currentPlayer: \"white\",\n            isCheck: false,\n            isCheckmate: false,\n            isDraw: false,\n            status: _shared_constants_game__WEBPACK_IMPORTED_MODULE_1__.GAME_STATUS.ACTIVE,\n            timeControl\n        });\n        setSelectedSquare(null);\n        setPossibleMoves([]);\n        setLastMove(null);\n    }, [\n        initialFen,\n        timeControl\n    ]);\n    // Retorna a pea em uma posio especfica\n    const pieceAt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((position)=>{\n        const { row , col  } = position;\n        const fenParts = gameState.fen.split(\" \");\n        const boardFen = fenParts[0];\n        const ranks = boardFen.split(\"/\");\n        // Converte a posio do tabuleiro para o ndice no FEN\n        let currentRank = ranks[row];\n        let currentCol = 0;\n        for(let i = 0; i < currentRank.length; i++){\n            const char = currentRank[i];\n            if (isNaN(parseInt(char))) {\n                if (currentCol === col) {\n                    const isWhite = char === char.toUpperCase();\n                    const pieceType = char.toLowerCase();\n                    return {\n                        type: pieceType,\n                        color: isWhite ? \"white\" : \"black\"\n                    };\n                }\n                currentCol++;\n            } else {\n                currentCol += parseInt(char);\n                if (currentCol > col) {\n                    return undefined;\n                }\n            }\n        }\n        return undefined;\n    }, [\n        gameState.fen\n    ]);\n    // Calcula movimentos possveis para uma pea\n    const calculatePossibleMoves = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((position, piece)=>{\n        const moves = [];\n        const { row , col  } = position;\n        // Direes de movimento por tipo de pea\n        const directions = [];\n        switch(piece.type){\n            case \"p\":\n                const direction = piece.color === \"white\" ? -1 : 1;\n                const startRow = piece.color === \"white\" ? 6 : 1;\n                // Movimento para frente\n                if ((0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isValidPosition)({\n                    row: row + direction,\n                    col\n                }) && !pieceAt({\n                    row: row + direction,\n                    col\n                })) {\n                    moves.push({\n                        row: row + direction,\n                        col\n                    });\n                    // Movimento duplo inicial\n                    if (row === startRow && !pieceAt({\n                        row: row + 2 * direction,\n                        col\n                    })) {\n                        moves.push({\n                            row: row + 2 * direction,\n                            col\n                        });\n                    }\n                }\n                // Capturas diagonais\n                for (const dx of [\n                    -1,\n                    1\n                ]){\n                    const newPos = {\n                        row: row + direction,\n                        col: col + dx\n                    };\n                    if ((0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isValidPosition)(newPos)) {\n                        const targetPiece = pieceAt(newPos);\n                        if (targetPiece && targetPiece.color !== piece.color) {\n                            moves.push(newPos);\n                        }\n                    }\n                }\n                break;\n            case \"n\":\n                const knightMoves = [\n                    {\n                        row: -2,\n                        col: -1\n                    },\n                    {\n                        row: -2,\n                        col: 1\n                    },\n                    {\n                        row: -1,\n                        col: -2\n                    },\n                    {\n                        row: -1,\n                        col: 2\n                    },\n                    {\n                        row: 1,\n                        col: -2\n                    },\n                    {\n                        row: 1,\n                        col: 2\n                    },\n                    {\n                        row: 2,\n                        col: -1\n                    },\n                    {\n                        row: 2,\n                        col: 1\n                    }\n                ];\n                for (const move of knightMoves){\n                    const newPos = {\n                        row: row + move.row,\n                        col: col + move.col\n                    };\n                    if ((0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isValidPosition)(newPos)) {\n                        const targetPiece = pieceAt(newPos);\n                        if (!targetPiece || targetPiece.color !== piece.color) {\n                            moves.push(newPos);\n                        }\n                    }\n                }\n                break;\n            case \"b\":\n                directions.push({\n                    row: -1,\n                    col: -1\n                }, {\n                    row: -1,\n                    col: 1\n                }, {\n                    row: 1,\n                    col: -1\n                }, {\n                    row: 1,\n                    col: 1\n                });\n                break;\n            case \"r\":\n                directions.push({\n                    row: -1,\n                    col: 0\n                }, {\n                    row: 1,\n                    col: 0\n                }, {\n                    row: 0,\n                    col: -1\n                }, {\n                    row: 0,\n                    col: 1\n                });\n                break;\n            case \"q\":\n                directions.push({\n                    row: -1,\n                    col: -1\n                }, {\n                    row: -1,\n                    col: 0\n                }, {\n                    row: -1,\n                    col: 1\n                }, {\n                    row: 0,\n                    col: -1\n                }, {\n                    row: 0,\n                    col: 1\n                }, {\n                    row: 1,\n                    col: -1\n                }, {\n                    row: 1,\n                    col: 0\n                }, {\n                    row: 1,\n                    col: 1\n                });\n                break;\n            case \"k\":\n                directions.push({\n                    row: -1,\n                    col: -1\n                }, {\n                    row: -1,\n                    col: 0\n                }, {\n                    row: -1,\n                    col: 1\n                }, {\n                    row: 0,\n                    col: -1\n                }, {\n                    row: 0,\n                    col: 1\n                }, {\n                    row: 1,\n                    col: -1\n                }, {\n                    row: 1,\n                    col: 0\n                }, {\n                    row: 1,\n                    col: 1\n                });\n                break;\n        }\n        // Processa movimentos nas direes permitidas\n        for (const dir of directions){\n            let distance = piece.type === \"k\" ? 1 : 7;\n            for(let i = 1; i <= distance; i++){\n                const newPos = {\n                    row: row + dir.row * i,\n                    col: col + dir.col * i\n                };\n                if (!(0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isValidPosition)(newPos)) break;\n                const targetPiece = pieceAt(newPos);\n                if (!targetPiece) {\n                    moves.push(newPos);\n                } else {\n                    if (targetPiece.color !== piece.color) {\n                        moves.push(newPos);\n                    }\n                    break;\n                }\n            }\n        }\n        return moves;\n    }, [\n        pieceAt\n    ]);\n    // Seleciona uma casa e calcula movimentos possveis\n    const selectSquare = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((position)=>{\n        if (!position) {\n            setSelectedSquare(null);\n            setPossibleMoves([]);\n            return;\n        }\n        const piece = pieceAt(position);\n        if (!piece || piece.color !== gameState.currentPlayer) {\n            setSelectedSquare(null);\n            setPossibleMoves([]);\n            return;\n        }\n        setSelectedSquare(position);\n        setPossibleMoves(calculatePossibleMoves(position, piece));\n    }, [\n        gameState.currentPlayer,\n        pieceAt,\n        calculatePossibleMoves\n    ]);\n    // Executa um movimento\n    const makeMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((from, to)=>{\n        if (!(0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isValidPosition)(from) || !(0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isValidPosition)(to)) {\n            return false;\n        }\n        const piece = pieceAt(from);\n        if (!piece || piece.color !== gameState.currentPlayer) {\n            return false;\n        }\n        const isValidMove = possibleMoves.some((move)=>(0,_shared_utils_chess__WEBPACK_IMPORTED_MODULE_3__.isSamePosition)(move, to));\n        if (!isValidMove) {\n            return false;\n        }\n        // TODO: Implementar lgica de movimento e atualizao do estado do jogo\n        const capturedPiece = pieceAt(to);\n        const move = {\n            from,\n            to,\n            piece,\n            captured: capturedPiece\n        };\n        setGameState((prev)=>({\n                ...prev,\n                currentPlayer: prev.currentPlayer === \"white\" ? \"black\" : \"white\",\n                moveHistory: [\n                    ...prev.moveHistory,\n                    move\n                ]\n            }));\n        setLastMove(move);\n        setSelectedSquare(null);\n        setPossibleMoves([]);\n        return true;\n    }, [\n        gameState.currentPlayer,\n        pieceAt,\n        possibleMoves\n    ]);\n    // Desfaz o ltimo movimento\n    const undoLastMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (gameState.moveHistory.length === 0) {\n            return;\n        }\n        // TODO: Implementar lgica para desfazer o ltimo movimento\n        setGameState((prev)=>({\n                ...prev,\n                moveHistory: prev.moveHistory.slice(0, -1),\n                currentPlayer: prev.currentPlayer === \"white\" ? \"black\" : \"white\"\n            }));\n        setLastMove(null);\n        setSelectedSquare(null);\n        setPossibleMoves([]);\n    }, [\n        gameState.moveHistory\n    ]);\n    // Atualiza o estado quando o FEN inicial muda\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        resetGame();\n    }, [\n        initialFen,\n        resetGame\n    ]);\n    return {\n        gameState,\n        selectedSquare,\n        possibleMoves,\n        lastMove,\n        pieceAt,\n        selectSquare,\n        makeMove,\n        resetGame,\n        undoLastMove,\n        isCheck: gameState.isCheck,\n        isCheckmate: gameState.isCheckmate,\n        isDraw: gameState.isDraw,\n        currentPlayer: gameState.currentPlayer\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXO0tBQUM7SUFFMUIsOENBQThDO0lBQzlDZCxnREFBU0EsQ0FBQyxJQUFNO1FBQ2QyQjtJQUNGLEdBQUc7UUFBQ3BCO1FBQVlvQjtLQUFVO0lBRTFCLE9BQU87UUFDTGpCO1FBQ0FXO1FBQ0FFO1FBQ0FFO1FBQ0FHO1FBQ0FvQztRQUNBQztRQUNBdEM7UUFDQThDO1FBQ0F6RCxTQUFTTixVQUFVTSxPQUFPO1FBQzFCQyxhQUFhUCxVQUFVTyxXQUFXO1FBQ2xDQyxRQUFRUixVQUFVUSxNQUFNO1FBQ3hCSCxlQUFlTCxVQUFVSyxhQUFhO0lBQ3hDO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvd2ViL2hvb2tzL3VzZUdhbWVTdGF0ZS50cz84MmU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2hlc3NQb3NpdGlvbiwgQ2hlc3NQaWVjZSwgR2FtZVN0YXRlLCBDaGVzc01vdmUgfSBmcm9tICcuLi8uLi9zaGFyZWQvdHlwZXMvY2hlc3MnO1xuaW1wb3J0IHsgSU5JVElBTF9GRU4sIEdBTUVfU1RBVFVTIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYW1lJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvaWQnO1xuaW1wb3J0IHsgXG4gIGFsZ2VicmFpY1RvQ29vcmRzLFxuICBjb29yZHNUb0FsZ2VicmFpYyxcbiAgaXNWYWxpZFBvc2l0aW9uLFxuICBpc1NhbWVQb3NpdGlvbixcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL2NoZXNzJztcblxuaW50ZXJmYWNlIFVzZUdhbWVTdGF0ZVByb3BzIHtcbiAgaW5pdGlhbEZlbj86IHN0cmluZztcbiAgY3VsdHVyYWxTdHlsZT86IHN0cmluZztcbiAgdGltZUNvbnRyb2w/OiB7XG4gICAgaW5pdGlhbDogbnVtYmVyO1xuICAgIGluY3JlbWVudDogbnVtYmVyO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgVXNlR2FtZVN0YXRlUmV0dXJuIHtcbiAgZ2FtZVN0YXRlOiBHYW1lU3RhdGU7XG4gIHNlbGVjdGVkU3F1YXJlOiBDaGVzc1Bvc2l0aW9uIHwgbnVsbDtcbiAgcG9zc2libGVNb3ZlczogQ2hlc3NQb3NpdGlvbltdO1xuICBsYXN0TW92ZTogQ2hlc3NNb3ZlIHwgbnVsbDtcbiAgcGllY2VBdDogKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uKSA9PiBDaGVzc1BpZWNlIHwgdW5kZWZpbmVkO1xuICBzZWxlY3RTcXVhcmU6IChwb3NpdGlvbjogQ2hlc3NQb3NpdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIG1ha2VNb3ZlOiAoZnJvbTogQ2hlc3NQb3NpdGlvbiwgdG86IENoZXNzUG9zaXRpb24pID0+IGJvb2xlYW47XG4gIHJlc2V0R2FtZTogKCkgPT4gdm9pZDtcbiAgdW5kb0xhc3RNb3ZlOiAoKSA9PiB2b2lkO1xuICBpc0NoZWNrOiBib29sZWFuO1xuICBpc0NoZWNrbWF0ZTogYm9vbGVhbjtcbiAgaXNEcmF3OiBib29sZWFuO1xuICBjdXJyZW50UGxheWVyOiAnd2hpdGUnIHwgJ2JsYWNrJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdhbWVTdGF0ZSh7XG4gIGluaXRpYWxGZW4gPSBJTklUSUFMX0ZFTixcbiAgY3VsdHVyYWxTdHlsZSA9ICdtb2Rlcm4nLFxuICB0aW1lQ29udHJvbCxcbn06IFVzZUdhbWVTdGF0ZVByb3BzID0ge30pOiBVc2VHYW1lU3RhdGVSZXR1cm4ge1xuICAvLyBFc3RhZG8gZG8gam9nb1xuICBjb25zdCBbZ2FtZVN0YXRlLCBzZXRHYW1lU3RhdGVdID0gdXNlU3RhdGU8R2FtZVN0YXRlPih7XG4gICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICBmZW46IGluaXRpYWxGZW4sXG4gICAgbW92ZUhpc3Rvcnk6IFtdLFxuICAgIGN1cnJlbnRQbGF5ZXI6ICd3aGl0ZScsXG4gICAgaXNDaGVjazogZmFsc2UsXG4gICAgaXNDaGVja21hdGU6IGZhbHNlLFxuICAgIGlzRHJhdzogZmFsc2UsXG4gICAgc3RhdHVzOiBHQU1FX1NUQVRVUy5BQ1RJVkUsXG4gICAgdGltZUNvbnRyb2wsXG4gIH0pO1xuXG4gIC8vIEVzdGFkbyBkYSBpbnRlcmZhY2VcbiAgY29uc3QgW3NlbGVjdGVkU3F1YXJlLCBzZXRTZWxlY3RlZFNxdWFyZV0gPSB1c2VTdGF0ZTxDaGVzc1Bvc2l0aW9uIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwb3NzaWJsZU1vdmVzLCBzZXRQb3NzaWJsZU1vdmVzXSA9IHVzZVN0YXRlPENoZXNzUG9zaXRpb25bXT4oW10pO1xuICBjb25zdCBbbGFzdE1vdmUsIHNldExhc3RNb3ZlXSA9IHVzZVN0YXRlPENoZXNzTW92ZSB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFJlc2V0YSBvIGpvZ28gcGFyYSBvIGVzdGFkbyBpbmljaWFsXG4gIGNvbnN0IHJlc2V0R2FtZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRHYW1lU3RhdGUoe1xuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgIGZlbjogaW5pdGlhbEZlbixcbiAgICAgIG1vdmVIaXN0b3J5OiBbXSxcbiAgICAgIGN1cnJlbnRQbGF5ZXI6ICd3aGl0ZScsXG4gICAgICBpc0NoZWNrOiBmYWxzZSxcbiAgICAgIGlzQ2hlY2ttYXRlOiBmYWxzZSxcbiAgICAgIGlzRHJhdzogZmFsc2UsXG4gICAgICBzdGF0dXM6IEdBTUVfU1RBVFVTLkFDVElWRSxcbiAgICAgIHRpbWVDb250cm9sLFxuICAgIH0pO1xuICAgIHNldFNlbGVjdGVkU3F1YXJlKG51bGwpO1xuICAgIHNldFBvc3NpYmxlTW92ZXMoW10pO1xuICAgIHNldExhc3RNb3ZlKG51bGwpO1xuICB9LCBbaW5pdGlhbEZlbiwgdGltZUNvbnRyb2xdKTtcblxuICAvLyBSZXRvcm5hIGEgcGXDp2EgZW0gdW1hIHBvc2nDp8OjbyBlc3BlY8OtZmljYVxuICBjb25zdCBwaWVjZUF0ID0gdXNlQ2FsbGJhY2soKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uKTogQ2hlc3NQaWVjZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgY29uc3QgeyByb3csIGNvbCB9ID0gcG9zaXRpb247XG4gICAgY29uc3QgZmVuUGFydHMgPSBnYW1lU3RhdGUuZmVuLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgYm9hcmRGZW4gPSBmZW5QYXJ0c1swXTtcbiAgICBjb25zdCByYW5rcyA9IGJvYXJkRmVuLnNwbGl0KCcvJyk7XG5cbiAgICAvLyBDb252ZXJ0ZSBhIHBvc2nDp8OjbyBkbyB0YWJ1bGVpcm8gcGFyYSBvIMOtbmRpY2Ugbm8gRkVOXG4gICAgbGV0IGN1cnJlbnRSYW5rID0gcmFua3Nbcm93XTtcbiAgICBsZXQgY3VycmVudENvbCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRSYW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gY3VycmVudFJhbmtbaV07XG4gICAgICBpZiAoaXNOYU4ocGFyc2VJbnQoY2hhcikpKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29sID09PSBjb2wpIHtcbiAgICAgICAgICBjb25zdCBpc1doaXRlID0gY2hhciA9PT0gY2hhci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGNvbnN0IHBpZWNlVHlwZSA9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogcGllY2VUeXBlLFxuICAgICAgICAgICAgY29sb3I6IGlzV2hpdGUgPyAnd2hpdGUnIDogJ2JsYWNrJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudENvbCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENvbCArPSBwYXJzZUludChjaGFyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2wgPiBjb2wpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2dhbWVTdGF0ZS5mZW5dKTtcblxuICAvLyBDYWxjdWxhIG1vdmltZW50b3MgcG9zc8OtdmVpcyBwYXJhIHVtYSBwZcOnYVxuICBjb25zdCBjYWxjdWxhdGVQb3NzaWJsZU1vdmVzID0gdXNlQ2FsbGJhY2soKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uLCBwaWVjZTogQ2hlc3NQaWVjZSk6IENoZXNzUG9zaXRpb25bXSA9PiB7XG4gICAgY29uc3QgbW92ZXM6IENoZXNzUG9zaXRpb25bXSA9IFtdO1xuICAgIGNvbnN0IHsgcm93LCBjb2wgfSA9IHBvc2l0aW9uO1xuXG4gICAgLy8gRGlyZcOnw7VlcyBkZSBtb3ZpbWVudG8gcG9yIHRpcG8gZGUgcGXDp2FcbiAgICBjb25zdCBkaXJlY3Rpb25zOiB7IHJvdzogbnVtYmVyOyBjb2w6IG51bWJlciB9W10gPSBbXTtcbiAgICBcbiAgICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3AnOiAvLyBQZcOjb1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/IC0xIDogMTtcbiAgICAgICAgY29uc3Qgc3RhcnRSb3cgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/IDYgOiAxO1xuICAgICAgICBcbiAgICAgICAgLy8gTW92aW1lbnRvIHBhcmEgZnJlbnRlXG4gICAgICAgIGlmIChpc1ZhbGlkUG9zaXRpb24oeyByb3c6IHJvdyArIGRpcmVjdGlvbiwgY29sIH0pICYmICFwaWVjZUF0KHsgcm93OiByb3cgKyBkaXJlY3Rpb24sIGNvbCB9KSkge1xuICAgICAgICAgIG1vdmVzLnB1c2goeyByb3c6IHJvdyArIGRpcmVjdGlvbiwgY29sIH0pO1xuICAgICAgICAgIC8vIE1vdmltZW50byBkdXBsbyBpbmljaWFsXG4gICAgICAgICAgaWYgKHJvdyA9PT0gc3RhcnRSb3cgJiYgIXBpZWNlQXQoeyByb3c6IHJvdyArIDIgKiBkaXJlY3Rpb24sIGNvbCB9KSkge1xuICAgICAgICAgICAgbW92ZXMucHVzaCh7IHJvdzogcm93ICsgMiAqIGRpcmVjdGlvbiwgY29sIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FwdHVyYXMgZGlhZ29uYWlzXG4gICAgICAgIGZvciAoY29uc3QgZHggb2YgWy0xLCAxXSkge1xuICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IHsgcm93OiByb3cgKyBkaXJlY3Rpb24sIGNvbDogY29sICsgZHggfTtcbiAgICAgICAgICBpZiAoaXNWYWxpZFBvc2l0aW9uKG5ld1BvcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBpZWNlID0gcGllY2VBdChuZXdQb3MpO1xuICAgICAgICAgICAgaWYgKHRhcmdldFBpZWNlICYmIHRhcmdldFBpZWNlLmNvbG9yICE9PSBwaWVjZS5jb2xvcikge1xuICAgICAgICAgICAgICBtb3Zlcy5wdXNoKG5ld1Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICduJzogLy8gQ2F2YWxvXG4gICAgICAgIGNvbnN0IGtuaWdodE1vdmVzID0gW1xuICAgICAgICAgIHsgcm93OiAtMiwgY29sOiAtMSB9LCB7IHJvdzogLTIsIGNvbDogMSB9LFxuICAgICAgICAgIHsgcm93OiAtMSwgY29sOiAtMiB9LCB7IHJvdzogLTEsIGNvbDogMiB9LFxuICAgICAgICAgIHsgcm93OiAxLCBjb2w6IC0yIH0sIHsgcm93OiAxLCBjb2w6IDIgfSxcbiAgICAgICAgICB7IHJvdzogMiwgY29sOiAtMSB9LCB7IHJvdzogMiwgY29sOiAxIH0sXG4gICAgICAgIF07XG4gICAgICAgIGZvciAoY29uc3QgbW92ZSBvZiBrbmlnaHRNb3Zlcykge1xuICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IHsgcm93OiByb3cgKyBtb3ZlLnJvdywgY29sOiBjb2wgKyBtb3ZlLmNvbCB9O1xuICAgICAgICAgIGlmIChpc1ZhbGlkUG9zaXRpb24obmV3UG9zKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGllY2UgPSBwaWVjZUF0KG5ld1Bvcyk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFBpZWNlIHx8IHRhcmdldFBpZWNlLmNvbG9yICE9PSBwaWVjZS5jb2xvcikge1xuICAgICAgICAgICAgICBtb3Zlcy5wdXNoKG5ld1Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiJzogLy8gQmlzcG9cbiAgICAgICAgZGlyZWN0aW9ucy5wdXNoKFxuICAgICAgICAgIHsgcm93OiAtMSwgY29sOiAtMSB9LCB7IHJvdzogLTEsIGNvbDogMSB9LFxuICAgICAgICAgIHsgcm93OiAxLCBjb2w6IC0xIH0sIHsgcm93OiAxLCBjb2w6IDEgfVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncic6IC8vIFRvcnJlXG4gICAgICAgIGRpcmVjdGlvbnMucHVzaChcbiAgICAgICAgICB7IHJvdzogLTEsIGNvbDogMCB9LCB7IHJvdzogMSwgY29sOiAwIH0sXG4gICAgICAgICAgeyByb3c6IDAsIGNvbDogLTEgfSwgeyByb3c6IDAsIGNvbDogMSB9XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gUmFpbmhhXG4gICAgICAgIGRpcmVjdGlvbnMucHVzaChcbiAgICAgICAgICB7IHJvdzogLTEsIGNvbDogLTEgfSwgeyByb3c6IC0xLCBjb2w6IDAgfSwgeyByb3c6IC0xLCBjb2w6IDEgfSxcbiAgICAgICAgICB7IHJvdzogMCwgY29sOiAtMSB9LCB7IHJvdzogMCwgY29sOiAxIH0sXG4gICAgICAgICAgeyByb3c6IDEsIGNvbDogLTEgfSwgeyByb3c6IDEsIGNvbDogMCB9LCB7IHJvdzogMSwgY29sOiAxIH1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2snOiAvLyBSZWlcbiAgICAgICAgZGlyZWN0aW9ucy5wdXNoKFxuICAgICAgICAgIHsgcm93OiAtMSwgY29sOiAtMSB9LCB7IHJvdzogLTEsIGNvbDogMCB9LCB7IHJvdzogLTEsIGNvbDogMSB9LFxuICAgICAgICAgIHsgcm93OiAwLCBjb2w6IC0xIH0sIHsgcm93OiAwLCBjb2w6IDEgfSxcbiAgICAgICAgICB7IHJvdzogMSwgY29sOiAtMSB9LCB7IHJvdzogMSwgY29sOiAwIH0sIHsgcm93OiAxLCBjb2w6IDEgfVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzYSBtb3ZpbWVudG9zIG5hcyBkaXJlw6fDtWVzIHBlcm1pdGlkYXNcbiAgICBmb3IgKGNvbnN0IGRpciBvZiBkaXJlY3Rpb25zKSB7XG4gICAgICBsZXQgZGlzdGFuY2UgPSBwaWVjZS50eXBlID09PSAnaycgPyAxIDogNztcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGRpc3RhbmNlOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV3UG9zID0ge1xuICAgICAgICAgIHJvdzogcm93ICsgZGlyLnJvdyAqIGksXG4gICAgICAgICAgY29sOiBjb2wgKyBkaXIuY29sICogaVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghaXNWYWxpZFBvc2l0aW9uKG5ld1BvcykpIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFBpZWNlID0gcGllY2VBdChuZXdQb3MpO1xuICAgICAgICBpZiAoIXRhcmdldFBpZWNlKSB7XG4gICAgICAgICAgbW92ZXMucHVzaChuZXdQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0YXJnZXRQaWVjZS5jb2xvciAhPT0gcGllY2UuY29sb3IpIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2gobmV3UG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG4gIH0sIFtwaWVjZUF0XSk7XG5cbiAgLy8gU2VsZWNpb25hIHVtYSBjYXNhIGUgY2FsY3VsYSBtb3ZpbWVudG9zIHBvc3PDrXZlaXNcbiAgY29uc3Qgc2VsZWN0U3F1YXJlID0gdXNlQ2FsbGJhY2soKHBvc2l0aW9uOiBDaGVzc1Bvc2l0aW9uIHwgbnVsbCkgPT4ge1xuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgIHNldFNlbGVjdGVkU3F1YXJlKG51bGwpO1xuICAgICAgc2V0UG9zc2libGVNb3ZlcyhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGllY2UgPSBwaWVjZUF0KHBvc2l0aW9uKTtcbiAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLmNvbG9yICE9PSBnYW1lU3RhdGUuY3VycmVudFBsYXllcikge1xuICAgICAgc2V0U2VsZWN0ZWRTcXVhcmUobnVsbCk7XG4gICAgICBzZXRQb3NzaWJsZU1vdmVzKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3RlZFNxdWFyZShwb3NpdGlvbik7XG4gICAgc2V0UG9zc2libGVNb3ZlcyhjYWxjdWxhdGVQb3NzaWJsZU1vdmVzKHBvc2l0aW9uLCBwaWVjZSkpO1xuICB9LCBbZ2FtZVN0YXRlLmN1cnJlbnRQbGF5ZXIsIHBpZWNlQXQsIGNhbGN1bGF0ZVBvc3NpYmxlTW92ZXNdKTtcblxuICAvLyBFeGVjdXRhIHVtIG1vdmltZW50b1xuICBjb25zdCBtYWtlTW92ZSA9IHVzZUNhbGxiYWNrKChmcm9tOiBDaGVzc1Bvc2l0aW9uLCB0bzogQ2hlc3NQb3NpdGlvbik6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghaXNWYWxpZFBvc2l0aW9uKGZyb20pIHx8ICFpc1ZhbGlkUG9zaXRpb24odG8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGllY2UgPSBwaWVjZUF0KGZyb20pO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgIT09IGdhbWVTdGF0ZS5jdXJyZW50UGxheWVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaXNWYWxpZE1vdmUgPSBwb3NzaWJsZU1vdmVzLnNvbWUobW92ZSA9PiBpc1NhbWVQb3NpdGlvbihtb3ZlLCB0bykpO1xuICAgIGlmICghaXNWYWxpZE1vdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnRhciBsw7NnaWNhIGRlIG1vdmltZW50byBlIGF0dWFsaXphw6fDo28gZG8gZXN0YWRvIGRvIGpvZ29cbiAgICBjb25zdCBjYXB0dXJlZFBpZWNlID0gcGllY2VBdCh0byk7XG4gICAgY29uc3QgbW92ZTogQ2hlc3NNb3ZlID0ge1xuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgcGllY2UsXG4gICAgICBjYXB0dXJlZDogY2FwdHVyZWRQaWVjZSxcbiAgICB9O1xuXG4gICAgc2V0R2FtZVN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBjdXJyZW50UGxheWVyOiBwcmV2LmN1cnJlbnRQbGF5ZXIgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJyxcbiAgICAgIG1vdmVIaXN0b3J5OiBbLi4ucHJldi5tb3ZlSGlzdG9yeSwgbW92ZV0sXG4gICAgfSkpO1xuXG4gICAgc2V0TGFzdE1vdmUobW92ZSk7XG4gICAgc2V0U2VsZWN0ZWRTcXVhcmUobnVsbCk7XG4gICAgc2V0UG9zc2libGVNb3ZlcyhbXSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgW2dhbWVTdGF0ZS5jdXJyZW50UGxheWVyLCBwaWVjZUF0LCBwb3NzaWJsZU1vdmVzXSk7XG5cbiAgLy8gRGVzZmF6IG8gw7psdGltbyBtb3ZpbWVudG9cbiAgY29uc3QgdW5kb0xhc3RNb3ZlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChnYW1lU3RhdGUubW92ZUhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50YXIgbMOzZ2ljYSBwYXJhIGRlc2ZhemVyIG8gw7psdGltbyBtb3ZpbWVudG9cbiAgICBzZXRHYW1lU3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIG1vdmVIaXN0b3J5OiBwcmV2Lm1vdmVIaXN0b3J5LnNsaWNlKDAsIC0xKSxcbiAgICAgIGN1cnJlbnRQbGF5ZXI6IHByZXYuY3VycmVudFBsYXllciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnLFxuICAgIH0pKTtcblxuICAgIHNldExhc3RNb3ZlKG51bGwpO1xuICAgIHNldFNlbGVjdGVkU3F1YXJlKG51bGwpO1xuICAgIHNldFBvc3NpYmxlTW92ZXMoW10pO1xuICB9LCBbZ2FtZVN0YXRlLm1vdmVIaXN0b3J5XSk7XG5cbiAgLy8gQXR1YWxpemEgbyBlc3RhZG8gcXVhbmRvIG8gRkVOIGluaWNpYWwgbXVkYVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlc2V0R2FtZSgpO1xuICB9LCBbaW5pdGlhbEZlbiwgcmVzZXRHYW1lXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnYW1lU3RhdGUsXG4gICAgc2VsZWN0ZWRTcXVhcmUsXG4gICAgcG9zc2libGVNb3ZlcyxcbiAgICBsYXN0TW92ZSxcbiAgICBwaWVjZUF0LFxuICAgIHNlbGVjdFNxdWFyZSxcbiAgICBtYWtlTW92ZSxcbiAgICByZXNldEdhbWUsXG4gICAgdW5kb0xhc3RNb3ZlLFxuICAgIGlzQ2hlY2s6IGdhbWVTdGF0ZS5pc0NoZWNrLFxuICAgIGlzQ2hlY2ttYXRlOiBnYW1lU3RhdGUuaXNDaGVja21hdGUsXG4gICAgaXNEcmF3OiBnYW1lU3RhdGUuaXNEcmF3LFxuICAgIGN1cnJlbnRQbGF5ZXI6IGdhbWVTdGF0ZS5jdXJyZW50UGxheWVyLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJJTklUSUFMX0ZFTiIsIkdBTUVfU1RBVFVTIiwiZ2VuZXJhdGVJZCIsImlzVmFsaWRQb3NpdGlvbiIsImlzU2FtZVBvc2l0aW9uIiwidXNlR2FtZVN0YXRlIiwiaW5pdGlhbEZlbiIsImN1bHR1cmFsU3R5bGUiLCJ0aW1lQ29udHJvbCIsImdhbWVTdGF0ZSIsInNldEdhbWVTdGF0ZSIsImlkIiwiZmVuIiwibW92ZUhpc3RvcnkiLCJjdXJyZW50UGxheWVyIiwiaXNDaGVjayIsImlzQ2hlY2ttYXRlIiwiaXNEcmF3Iiwic3RhdHVzIiwiQUNUSVZFIiwic2VsZWN0ZWRTcXVhcmUiLCJzZXRTZWxlY3RlZFNxdWFyZSIsInBvc3NpYmxlTW92ZXMiLCJzZXRQb3NzaWJsZU1vdmVzIiwibGFzdE1vdmUiLCJzZXRMYXN0TW92ZSIsInJlc2V0R2FtZSIsInBpZWNlQXQiLCJwb3NpdGlvbiIsInJvdyIsImNvbCIsImZlblBhcnRzIiwic3BsaXQiLCJib2FyZEZlbiIsInJhbmtzIiwiY3VycmVudFJhbmsiLCJjdXJyZW50Q29sIiwiaSIsImxlbmd0aCIsImNoYXIiLCJpc05hTiIsInBhcnNlSW50IiwiaXNXaGl0ZSIsInRvVXBwZXJDYXNlIiwicGllY2VUeXBlIiwidG9Mb3dlckNhc2UiLCJ0eXBlIiwiY29sb3IiLCJ1bmRlZmluZWQiLCJjYWxjdWxhdGVQb3NzaWJsZU1vdmVzIiwicGllY2UiLCJtb3ZlcyIsImRpcmVjdGlvbnMiLCJkaXJlY3Rpb24iLCJzdGFydFJvdyIsInB1c2giLCJkeCIsIm5ld1BvcyIsInRhcmdldFBpZWNlIiwia25pZ2h0TW92ZXMiLCJtb3ZlIiwiZGlyIiwiZGlzdGFuY2UiLCJzZWxlY3RTcXVhcmUiLCJtYWtlTW92ZSIsImZyb20iLCJ0byIsImlzVmFsaWRNb3ZlIiwic29tZSIsImNhcHR1cmVkUGllY2UiLCJjYXB0dXJlZCIsInByZXYiLCJ1bmRvTGFzdE1vdmUiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/web/hooks/useGameState.ts\n"));

/***/ }),

/***/ "./src/web/hooks/useResponsiveBoard.ts":
/*!*********************************************!*\
  !*** ./src/web/hooks/useResponsiveBoard.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useResponsiveBoard\": function() { return /* binding */ useResponsiveBoard; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useResponsiveBoard = function(containerRef) {\n    let minSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 280, maxSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 800;\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        boardSize: minSize,\n        squareSize: minSize / 8,\n        pieceSize: minSize / 8 * 0.8\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (!containerRef.current) return;\n            const container = containerRef.current;\n            const containerWidth = container.clientWidth;\n            const containerHeight = container.clientHeight;\n            // Calcula o tamanho ideal do tabuleiro\n            let idealSize = Math.min(containerWidth, containerHeight);\n            // Aplica limites mnimo e mximo\n            idealSize = Math.max(minSize, Math.min(maxSize, idealSize));\n            // Calcula tamanhos derivados\n            const squareSize = idealSize / 8;\n            const pieceSize = squareSize * 0.8;\n            setDimensions({\n                boardSize: idealSize,\n                squareSize,\n                pieceSize\n            });\n        };\n        // Atualiza dimenses iniciais\n        updateDimensions();\n        // Configura observer para mudanas no tamanho do container\n        const resizeObserver = new ResizeObserver(updateDimensions);\n        if (containerRef.current) {\n            resizeObserver.observe(containerRef.current);\n        }\n        // Configura listener para mudanas na janela\n        window.addEventListener(\"resize\", updateDimensions);\n        return ()=>{\n            resizeObserver.disconnect();\n            window.removeEventListener(\"resize\", updateDimensions);\n        };\n    }, [\n        containerRef,\n        minSize,\n        maxSize\n    ]);\n    return dimensions;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViL2hvb2tzL3VzZVJlc3BvbnNpdmVCb2FyZC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFRckMsTUFBTUUscUJBQXFCLFNBQ2hDQyxjQUc4QjtRQUY5QkMsMkVBQWtCLEtBQ2xCQywyRUFBa0I7SUFFbEIsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdQLCtDQUFRQSxDQUE0QjtRQUN0RVEsV0FBV0o7UUFDWEssWUFBWUwsVUFBVTtRQUN0Qk0sV0FBVyxVQUFXLElBQUs7SUFDN0I7SUFFQVQsZ0RBQVNBLENBQUMsSUFBTTtRQUNkLE1BQU1VLG1CQUFtQixJQUFNO1lBQzdCLElBQUksQ0FBQ1IsYUFBYVMsT0FBTyxFQUFFO1lBRTNCLE1BQU1DLFlBQVlWLGFBQWFTLE9BQU87WUFDdEMsTUFBTUUsaUJBQWlCRCxVQUFVRSxXQUFXO1lBQzVDLE1BQU1DLGtCQUFrQkgsVUFBVUksWUFBWTtZQUU5Qyx1Q0FBdUM7WUFDdkMsSUFBSUMsWUFBWUMsS0FBS0MsR0FBRyxDQUFDTixnQkFBZ0JFO1lBRXpDLGlDQUFpQztZQUNqQ0UsWUFBWUMsS0FBS0UsR0FBRyxDQUFDakIsU0FBU2UsS0FBS0MsR0FBRyxDQUFDZixTQUFTYTtZQUVoRCw2QkFBNkI7WUFDN0IsTUFBTVQsYUFBYVMsWUFBWTtZQUMvQixNQUFNUixZQUFZRCxhQUFhO1lBRS9CRixjQUFjO2dCQUNaQyxXQUFXVTtnQkFDWFQ7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUVBLDhCQUE4QjtRQUM5QkM7UUFFQSwyREFBMkQ7UUFDM0QsTUFBTVcsaUJBQWlCLElBQUlDLGVBQWVaO1FBQzFDLElBQUlSLGFBQWFTLE9BQU8sRUFBRTtZQUN4QlUsZUFBZUUsT0FBTyxDQUFDckIsYUFBYVMsT0FBTztRQUM3QyxDQUFDO1FBRUQsNkNBQTZDO1FBQzdDYSxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVZjtRQUVsQyxPQUFPLElBQU07WUFDWFcsZUFBZUssVUFBVTtZQUN6QkYsT0FBT0csbUJBQW1CLENBQUMsVUFBVWpCO1FBQ3ZDO0lBQ0YsR0FBRztRQUFDUjtRQUFjQztRQUFTQztLQUFRO0lBRW5DLE9BQU9DO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvd2ViL2hvb2tzL3VzZVJlc3BvbnNpdmVCb2FyZC50cz81ZTY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBSZXNwb25zaXZlQm9hcmREaW1lbnNpb25zIHtcbiAgYm9hcmRTaXplOiBudW1iZXI7XG4gIHNxdWFyZVNpemU6IG51bWJlcjtcbiAgcGllY2VTaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCB1c2VSZXNwb25zaXZlQm9hcmQgPSAoXG4gIGNvbnRhaW5lclJlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50PixcbiAgbWluU2l6ZTogbnVtYmVyID0gMjgwLFxuICBtYXhTaXplOiBudW1iZXIgPSA4MDBcbik6IFJlc3BvbnNpdmVCb2FyZERpbWVuc2lvbnMgPT4ge1xuICBjb25zdCBbZGltZW5zaW9ucywgc2V0RGltZW5zaW9uc10gPSB1c2VTdGF0ZTxSZXNwb25zaXZlQm9hcmREaW1lbnNpb25zPih7XG4gICAgYm9hcmRTaXplOiBtaW5TaXplLFxuICAgIHNxdWFyZVNpemU6IG1pblNpemUgLyA4LFxuICAgIHBpZWNlU2l6ZTogKG1pblNpemUgLyA4KSAqIDAuOCxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYSBvIHRhbWFuaG8gaWRlYWwgZG8gdGFidWxlaXJvXG4gICAgICBsZXQgaWRlYWxTaXplID0gTWF0aC5taW4oY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEFwbGljYSBsaW1pdGVzIG3DrW5pbW8gZSBtw6F4aW1vXG4gICAgICBpZGVhbFNpemUgPSBNYXRoLm1heChtaW5TaXplLCBNYXRoLm1pbihtYXhTaXplLCBpZGVhbFNpemUpKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYSB0YW1hbmhvcyBkZXJpdmFkb3NcbiAgICAgIGNvbnN0IHNxdWFyZVNpemUgPSBpZGVhbFNpemUgLyA4O1xuICAgICAgY29uc3QgcGllY2VTaXplID0gc3F1YXJlU2l6ZSAqIDAuODtcblxuICAgICAgc2V0RGltZW5zaW9ucyh7XG4gICAgICAgIGJvYXJkU2l6ZTogaWRlYWxTaXplLFxuICAgICAgICBzcXVhcmVTaXplLFxuICAgICAgICBwaWVjZVNpemUsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXR1YWxpemEgZGltZW5zw7VlcyBpbmljaWFpc1xuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcblxuICAgIC8vIENvbmZpZ3VyYSBvYnNlcnZlciBwYXJhIG11ZGFuw6dhcyBubyB0YW1hbmhvIGRvIGNvbnRhaW5lclxuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgLy8gQ29uZmlndXJhIGxpc3RlbmVyIHBhcmEgbXVkYW7Dp2FzIG5hIGphbmVsYVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgfTtcbiAgfSwgW2NvbnRhaW5lclJlZiwgbWluU2l6ZSwgbWF4U2l6ZV0pO1xuXG4gIHJldHVybiBkaW1lbnNpb25zO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlc3BvbnNpdmVCb2FyZCIsImNvbnRhaW5lclJlZiIsIm1pblNpemUiLCJtYXhTaXplIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJib2FyZFNpemUiLCJzcXVhcmVTaXplIiwicGllY2VTaXplIiwidXBkYXRlRGltZW5zaW9ucyIsImN1cnJlbnQiLCJjb250YWluZXIiLCJjb250YWluZXJXaWR0aCIsImNsaWVudFdpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiaWRlYWxTaXplIiwiTWF0aCIsIm1pbiIsIm1heCIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/web/hooks/useResponsiveBoard.ts\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/events/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/compiled/events/events.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={864:function(e){var t=typeof Reflect===\"object\"?Reflect:null;var n=t&&typeof t.apply===\"function\"?t.apply:function ReflectApply(e,t,n){return Function.prototype.apply.call(e,t,n)};var r;if(t&&typeof t.ownKeys===\"function\"){r=t.ownKeys}else if(Object.getOwnPropertySymbols){r=function ReflectOwnKeys(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}}else{r=function ReflectOwnKeys(e){return Object.getOwnPropertyNames(e)}}function ProcessEmitWarning(e){if(console&&console.warn)console.warn(e)}var i=Number.isNaN||function NumberIsNaN(e){return e!==e};function EventEmitter(){EventEmitter.init.call(this)}e.exports=EventEmitter;e.exports.once=once;EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._eventsCount=0;EventEmitter.prototype._maxListeners=undefined;var s=10;function checkListener(e){if(typeof e!==\"function\"){throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof e)}}Object.defineProperty(EventEmitter,\"defaultMaxListeners\",{enumerable:true,get:function(){return s},set:function(e){if(typeof e!==\"number\"||e<0||i(e)){throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+e+\".\")}s=e}});EventEmitter.init=function(){if(this._events===undefined||this._events===Object.getPrototypeOf(this)._events){this._events=Object.create(null);this._eventsCount=0}this._maxListeners=this._maxListeners||undefined};EventEmitter.prototype.setMaxListeners=function setMaxListeners(e){if(typeof e!==\"number\"||e<0||i(e)){throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+e+\".\")}this._maxListeners=e;return this};function _getMaxListeners(e){if(e._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return e._maxListeners}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return _getMaxListeners(this)};EventEmitter.prototype.emit=function emit(e){var t=[];for(var r=1;r<arguments.length;r++)t.push(arguments[r]);var i=e===\"error\";var s=this._events;if(s!==undefined)i=i&&s.error===undefined;else if(!i)return false;if(i){var o;if(t.length>0)o=t[0];if(o instanceof Error){throw o}var f=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));f.context=o;throw f}var u=s[e];if(u===undefined)return false;if(typeof u===\"function\"){n(u,this,t)}else{var a=u.length;var c=arrayClone(u,a);for(var r=0;r<a;++r)n(c[r],this,t)}return true};function _addListener(e,t,n,r){var i;var s;var o;checkListener(n);s=e._events;if(s===undefined){s=e._events=Object.create(null);e._eventsCount=0}else{if(s.newListener!==undefined){e.emit(\"newListener\",t,n.listener?n.listener:n);s=e._events}o=s[t]}if(o===undefined){o=s[t]=n;++e._eventsCount}else{if(typeof o===\"function\"){o=s[t]=r?[n,o]:[o,n]}else if(r){o.unshift(n)}else{o.push(n)}i=_getMaxListeners(e);if(i>0&&o.length>i&&!o.warned){o.warned=true;var f=new Error(\"Possible EventEmitter memory leak detected. \"+o.length+\" \"+String(t)+\" listeners \"+\"added. Use emitter.setMaxListeners() to \"+\"increase limit\");f.name=\"MaxListenersExceededWarning\";f.emitter=e;f.type=t;f.count=o.length;ProcessEmitWarning(f)}}return e}EventEmitter.prototype.addListener=function addListener(e,t){return _addListener(this,e,t,false)};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(e,t){return _addListener(this,e,t,true)};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;if(arguments.length===0)return this.listener.call(this.target);return this.listener.apply(this.target,arguments)}}function _onceWrap(e,t,n){var r={fired:false,wrapFn:undefined,target:e,type:t,listener:n};var i=onceWrapper.bind(r);i.listener=n;r.wrapFn=i;return i}EventEmitter.prototype.once=function once(e,t){checkListener(t);this.on(e,_onceWrap(this,e,t));return this};EventEmitter.prototype.prependOnceListener=function prependOnceListener(e,t){checkListener(t);this.prependListener(e,_onceWrap(this,e,t));return this};EventEmitter.prototype.removeListener=function removeListener(e,t){var n,r,i,s,o;checkListener(t);r=this._events;if(r===undefined)return this;n=r[e];if(n===undefined)return this;if(n===t||n.listener===t){if(--this._eventsCount===0)this._events=Object.create(null);else{delete r[e];if(r.removeListener)this.emit(\"removeListener\",e,n.listener||t)}}else if(typeof n!==\"function\"){i=-1;for(s=n.length-1;s>=0;s--){if(n[s]===t||n[s].listener===t){o=n[s].listener;i=s;break}}if(i<0)return this;if(i===0)n.shift();else{spliceOne(n,i)}if(n.length===1)r[e]=n[0];if(r.removeListener!==undefined)this.emit(\"removeListener\",e,o||t)}return this};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.removeAllListeners=function removeAllListeners(e){var t,n,r;n=this._events;if(n===undefined)return this;if(n.removeListener===undefined){if(arguments.length===0){this._events=Object.create(null);this._eventsCount=0}else if(n[e]!==undefined){if(--this._eventsCount===0)this._events=Object.create(null);else delete n[e]}return this}if(arguments.length===0){var i=Object.keys(n);var s;for(r=0;r<i.length;++r){s=i[r];if(s===\"removeListener\")continue;this.removeAllListeners(s)}this.removeAllListeners(\"removeListener\");this._events=Object.create(null);this._eventsCount=0;return this}t=n[e];if(typeof t===\"function\"){this.removeListener(e,t)}else if(t!==undefined){for(r=t.length-1;r>=0;r--){this.removeListener(e,t[r])}}return this};function _listeners(e,t,n){var r=e._events;if(r===undefined)return[];var i=r[t];if(i===undefined)return[];if(typeof i===\"function\")return n?[i.listener||i]:[i];return n?unwrapListeners(i):arrayClone(i,i.length)}EventEmitter.prototype.listeners=function listeners(e){return _listeners(this,e,true)};EventEmitter.prototype.rawListeners=function rawListeners(e){return _listeners(this,e,false)};EventEmitter.listenerCount=function(e,t){if(typeof e.listenerCount===\"function\"){return e.listenerCount(t)}else{return listenerCount.call(e,t)}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(e){var t=this._events;if(t!==undefined){var n=t[e];if(typeof n===\"function\"){return 1}else if(n!==undefined){return n.length}}return 0}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?r(this._events):[]};function arrayClone(e,t){var n=new Array(t);for(var r=0;r<t;++r)n[r]=e[r];return n}function spliceOne(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}function unwrapListeners(e){var t=new Array(e.length);for(var n=0;n<t.length;++n){t[n]=e[n].listener||e[n]}return t}function once(e,t){return new Promise((function(n,r){function errorListener(n){e.removeListener(t,resolver);r(n)}function resolver(){if(typeof e.removeListener===\"function\"){e.removeListener(\"error\",errorListener)}n([].slice.call(arguments))}eventTargetAgnosticAddListener(e,t,resolver,{once:true});if(t!==\"error\"){addErrorHandlerIfEventEmitter(e,errorListener,{once:true})}}))}function addErrorHandlerIfEventEmitter(e,t,n){if(typeof e.on===\"function\"){eventTargetAgnosticAddListener(e,\"error\",t,n)}}function eventTargetAgnosticAddListener(e,t,n,r){if(typeof e.on===\"function\"){if(r.once){e.once(t,n)}else{e.on(t,n)}}else if(typeof e.addEventListener===\"function\"){e.addEventListener(t,(function wrapListener(i){if(r.once){e.removeEventListener(t,wrapListener)}n(i)}))}else{throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type '+typeof e)}}}};var t={};function __nccwpck_require__(n){var r=t[n];if(r!==undefined){return r.exports}var i=t[n]={exports:{}};var s=true;try{e[n](i,i.exports,__nccwpck_require__);s=false}finally{if(s)delete t[n]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n=__nccwpck_require__(864);module.exports=n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2V2ZW50cy9ldmVudHMuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksYUFBYSxPQUFPLGdCQUFnQiw2Q0FBNkMsMEVBQTBFLDZDQUE2QyxNQUFNLHFDQUFxQyxZQUFZLHNDQUFzQyw2QkFBNkIsOEVBQThFLEtBQUssNkJBQTZCLHNDQUFzQywrQkFBK0IseUNBQXlDLDRDQUE0QyxjQUFjLHdCQUF3Qiw2QkFBNkIsdUJBQXVCLG9CQUFvQix1Q0FBdUMseUNBQXlDLHNDQUFzQywrQ0FBK0MsU0FBUywwQkFBMEIsMEJBQTBCLGtHQUFrRywwREFBMEQsK0JBQStCLFNBQVMsaUJBQWlCLG1DQUFtQyw4SEFBOEgsS0FBSyxFQUFFLDZCQUE2QixpRkFBaUYsaUNBQWlDLG9CQUFvQixrREFBa0QsbUVBQW1FLG1DQUFtQyw0R0FBNEcscUJBQXFCLGFBQWEsNkJBQTZCLHVFQUF1RSx1QkFBdUIsa0VBQWtFLCtCQUErQiw2Q0FBNkMsU0FBUyxZQUFZLG1CQUFtQix5QkFBeUIsa0JBQWtCLG1CQUFtQiwwQ0FBMEMsd0JBQXdCLE1BQU0sTUFBTSxxQkFBcUIsdUJBQXVCLFFBQVEsOERBQThELFlBQVksUUFBUSxXQUFXLDhCQUE4QiwwQkFBMEIsWUFBWSxLQUFLLGVBQWUsc0JBQXNCLFlBQVksSUFBSSxtQkFBbUIsYUFBYSwrQkFBK0IsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFlBQVksa0JBQWtCLGdDQUFnQyxpQkFBaUIsS0FBSyw4QkFBOEIsZ0RBQWdELFlBQVksT0FBTyxrQkFBa0IsU0FBUyxpQkFBaUIsS0FBSywwQkFBMEIscUJBQXFCLFdBQVcsYUFBYSxLQUFLLFVBQVUsc0JBQXNCLCtCQUErQixjQUFjLGlLQUFpSyxxQ0FBcUMsWUFBWSxTQUFTLGlCQUFpQix1QkFBdUIsU0FBUyw2REFBNkQscUNBQXFDLDZEQUE2RCxxRUFBcUUsb0NBQW9DLHVCQUF1QixnQkFBZ0Isa0RBQWtELGdCQUFnQiwrREFBK0QsbURBQW1ELDBCQUEwQixPQUFPLHlEQUF5RCwwQkFBMEIsYUFBYSxXQUFXLFNBQVMsK0NBQStDLGlCQUFpQiwrQkFBK0IsYUFBYSw2RUFBNkUsaUJBQWlCLDRDQUE0QyxhQUFhLG1FQUFtRSxjQUFjLGlCQUFpQixlQUFlLDZCQUE2QixPQUFPLDZCQUE2QiwwQkFBMEIsNERBQTRELEtBQUssWUFBWSxpRUFBaUUsK0JBQStCLEtBQUssaUJBQWlCLEtBQUssS0FBSyxnQ0FBZ0MsZ0JBQWdCLElBQUksT0FBTyxtQkFBbUIsbUJBQW1CLEtBQUssZUFBZSwwQkFBMEIsbUVBQW1FLGFBQWEsaUVBQWlFLHlFQUF5RSxVQUFVLGVBQWUsNkJBQTZCLGlDQUFpQyx5QkFBeUIsaUNBQWlDLG9CQUFvQiwwQkFBMEIsNERBQTRELGlCQUFpQixZQUFZLHlCQUF5QixxQkFBcUIsTUFBTSxRQUFRLFdBQVcsS0FBSyxPQUFPLGlDQUFpQywyQkFBMkIsMENBQTBDLGlDQUFpQyxvQkFBb0IsWUFBWSxPQUFPLDBCQUEwQix5QkFBeUIsdUJBQXVCLGlCQUFpQixLQUFLLEtBQUssNkJBQTZCLGFBQWEsMkJBQTJCLGdCQUFnQiwwQkFBMEIsV0FBVywwQkFBMEIsc0RBQXNELG1EQUFtRCx1REFBdUQsZ0NBQWdDLDZEQUE2RCxpQ0FBaUMseUNBQXlDLHdDQUF3QywwQkFBMEIsS0FBSyxpQ0FBaUMsbURBQW1ELDBCQUEwQixtQkFBbUIsa0JBQWtCLFdBQVcsMEJBQTBCLFNBQVMsdUJBQXVCLGlCQUFpQixTQUFTLHdEQUF3RCwrQ0FBK0MseUJBQXlCLG1CQUFtQixZQUFZLElBQUksY0FBYyxTQUFTLHdCQUF3QixLQUFLLGFBQWEsZ0JBQWdCLFFBQVEsNEJBQTRCLDBCQUEwQixZQUFZLFdBQVcsS0FBSyx5QkFBeUIsU0FBUyxtQkFBbUIsa0NBQWtDLDBCQUEwQiw2QkFBNkIsS0FBSyxvQkFBb0IseUNBQXlDLHdDQUF3Qyw0QkFBNEIsNkNBQTZDLFVBQVUsRUFBRSxnQkFBZ0IsK0NBQStDLFVBQVUsR0FBRyxHQUFHLDhDQUE4Qyw2QkFBNkIsK0NBQStDLGlEQUFpRCw2QkFBNkIsV0FBVyxZQUFZLEtBQUssV0FBVyxnREFBZ0QsK0NBQStDLFdBQVcsc0NBQXNDLEtBQUssR0FBRyxLQUFLLHdHQUF3RyxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvZXZlbnRzL2V2ZW50cy5qcz83NjUyIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXs4NjQ6ZnVuY3Rpb24oZSl7dmFyIHQ9dHlwZW9mIFJlZmxlY3Q9PT1cIm9iamVjdFwiP1JlZmxlY3Q6bnVsbDt2YXIgbj10JiZ0eXBlb2YgdC5hcHBseT09PVwiZnVuY3Rpb25cIj90LmFwcGx5OmZ1bmN0aW9uIFJlZmxlY3RBcHBseShlLHQsbil7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGUsdCxuKX07dmFyIHI7aWYodCYmdHlwZW9mIHQub3duS2V5cz09PVwiZnVuY3Rpb25cIil7cj10Lm93bktleXN9ZWxzZSBpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXtyPWZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKSl9fWVsc2V7cj1mdW5jdGlvbiBSZWZsZWN0T3duS2V5cyhlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSl9fWZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyhlKXtpZihjb25zb2xlJiZjb25zb2xlLndhcm4pY29uc29sZS53YXJuKGUpfXZhciBpPU51bWJlci5pc05hTnx8ZnVuY3Rpb24gTnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfTtmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKXtFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpfWUuZXhwb3J0cz1FdmVudEVtaXR0ZXI7ZS5leHBvcnRzLm9uY2U9b25jZTtFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyPUV2ZW50RW1pdHRlcjtFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHM9dW5kZWZpbmVkO0V2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50PTA7RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXVuZGVmaW5lZDt2YXIgcz0xMDtmdW5jdGlvbiBjaGVja0xpc3RlbmVyKGUpe2lmKHR5cGVvZiBlIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiBlKX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlcixcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBzfSxzZXQ6ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwifHxlPDB8fGkoZSkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJytlK1wiLlwiKX1zPWV9fSk7RXZlbnRFbWl0dGVyLmluaXQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9ldmVudHM9PT11bmRlZmluZWR8fHRoaXMuX2V2ZW50cz09PU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKXt0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLl9ldmVudHNDb3VudD0wfXRoaXMuX21heExpc3RlbmVycz10aGlzLl9tYXhMaXN0ZW5lcnN8fHVuZGVmaW5lZH07RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnM9ZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcInx8ZTwwfHxpKGUpKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrZStcIi5cIil9dGhpcy5fbWF4TGlzdGVuZXJzPWU7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnMoZSl7aWYoZS5fbWF4TGlzdGVuZXJzPT09dW5kZWZpbmVkKXJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztyZXR1cm4gZS5fbWF4TGlzdGVuZXJzfUV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpe3JldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpfTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24gZW1pdChlKXt2YXIgdD1bXTtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXQucHVzaChhcmd1bWVudHNbcl0pO3ZhciBpPWU9PT1cImVycm9yXCI7dmFyIHM9dGhpcy5fZXZlbnRzO2lmKHMhPT11bmRlZmluZWQpaT1pJiZzLmVycm9yPT09dW5kZWZpbmVkO2Vsc2UgaWYoIWkpcmV0dXJuIGZhbHNlO2lmKGkpe3ZhciBvO2lmKHQubGVuZ3RoPjApbz10WzBdO2lmKG8gaW5zdGFuY2VvZiBFcnJvcil7dGhyb3cgb312YXIgZj1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKG8/XCIgKFwiK28ubWVzc2FnZStcIilcIjpcIlwiKSk7Zi5jb250ZXh0PW87dGhyb3cgZn12YXIgdT1zW2VdO2lmKHU9PT11bmRlZmluZWQpcmV0dXJuIGZhbHNlO2lmKHR5cGVvZiB1PT09XCJmdW5jdGlvblwiKXtuKHUsdGhpcyx0KX1lbHNle3ZhciBhPXUubGVuZ3RoO3ZhciBjPWFycmF5Q2xvbmUodSxhKTtmb3IodmFyIHI9MDtyPGE7KytyKW4oY1tyXSx0aGlzLHQpfXJldHVybiB0cnVlfTtmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZSx0LG4scil7dmFyIGk7dmFyIHM7dmFyIG87Y2hlY2tMaXN0ZW5lcihuKTtzPWUuX2V2ZW50cztpZihzPT09dW5kZWZpbmVkKXtzPWUuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpO2UuX2V2ZW50c0NvdW50PTB9ZWxzZXtpZihzLm5ld0xpc3RlbmVyIT09dW5kZWZpbmVkKXtlLmVtaXQoXCJuZXdMaXN0ZW5lclwiLHQsbi5saXN0ZW5lcj9uLmxpc3RlbmVyOm4pO3M9ZS5fZXZlbnRzfW89c1t0XX1pZihvPT09dW5kZWZpbmVkKXtvPXNbdF09bjsrK2UuX2V2ZW50c0NvdW50fWVsc2V7aWYodHlwZW9mIG89PT1cImZ1bmN0aW9uXCIpe289c1t0XT1yP1tuLG9dOltvLG5dfWVsc2UgaWYocil7by51bnNoaWZ0KG4pfWVsc2V7by5wdXNoKG4pfWk9X2dldE1heExpc3RlbmVycyhlKTtpZihpPjAmJm8ubGVuZ3RoPmkmJiFvLndhcm5lZCl7by53YXJuZWQ9dHJ1ZTt2YXIgZj1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK28ubGVuZ3RoK1wiIFwiK1N0cmluZyh0KStcIiBsaXN0ZW5lcnMgXCIrXCJhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gXCIrXCJpbmNyZWFzZSBsaW1pdFwiKTtmLm5hbWU9XCJNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmdcIjtmLmVtaXR0ZXI9ZTtmLnR5cGU9dDtmLmNvdW50PW8ubGVuZ3RoO1Byb2Nlc3NFbWl0V2FybmluZyhmKX19cmV0dXJuIGV9RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1mdW5jdGlvbiBhZGRMaXN0ZW5lcihlLHQpe3JldHVybiBfYWRkTGlzdGVuZXIodGhpcyxlLHQsZmFsc2UpfTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uPUV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXI9ZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGUsdCl7cmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLGUsdCx0cnVlKX07ZnVuY3Rpb24gb25jZVdyYXBwZXIoKXtpZighdGhpcy5maXJlZCl7dGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLHRoaXMud3JhcEZuKTt0aGlzLmZpcmVkPXRydWU7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7cmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsYXJndW1lbnRzKX19ZnVuY3Rpb24gX29uY2VXcmFwKGUsdCxuKXt2YXIgcj17ZmlyZWQ6ZmFsc2Usd3JhcEZuOnVuZGVmaW5lZCx0YXJnZXQ6ZSx0eXBlOnQsbGlzdGVuZXI6bn07dmFyIGk9b25jZVdyYXBwZXIuYmluZChyKTtpLmxpc3RlbmVyPW47ci53cmFwRm49aTtyZXR1cm4gaX1FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24gb25jZShlLHQpe2NoZWNrTGlzdGVuZXIodCk7dGhpcy5vbihlLF9vbmNlV3JhcCh0aGlzLGUsdCkpO3JldHVybiB0aGlzfTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXI9ZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcihlLHQpe2NoZWNrTGlzdGVuZXIodCk7dGhpcy5wcmVwZW5kTGlzdGVuZXIoZSxfb25jZVdyYXAodGhpcyxlLHQpKTtyZXR1cm4gdGhpc307RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihlLHQpe3ZhciBuLHIsaSxzLG87Y2hlY2tMaXN0ZW5lcih0KTtyPXRoaXMuX2V2ZW50cztpZihyPT09dW5kZWZpbmVkKXJldHVybiB0aGlzO249cltlXTtpZihuPT09dW5kZWZpbmVkKXJldHVybiB0aGlzO2lmKG49PT10fHxuLmxpc3RlbmVyPT09dCl7aWYoLS10aGlzLl9ldmVudHNDb3VudD09PTApdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZXtkZWxldGUgcltlXTtpZihyLnJlbW92ZUxpc3RlbmVyKXRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxuLmxpc3RlbmVyfHx0KX19ZWxzZSBpZih0eXBlb2YgbiE9PVwiZnVuY3Rpb25cIil7aT0tMTtmb3Iocz1uLmxlbmd0aC0xO3M+PTA7cy0tKXtpZihuW3NdPT09dHx8bltzXS5saXN0ZW5lcj09PXQpe289bltzXS5saXN0ZW5lcjtpPXM7YnJlYWt9fWlmKGk8MClyZXR1cm4gdGhpcztpZihpPT09MCluLnNoaWZ0KCk7ZWxzZXtzcGxpY2VPbmUobixpKX1pZihuLmxlbmd0aD09PTEpcltlXT1uWzBdO2lmKHIucmVtb3ZlTGlzdGVuZXIhPT11bmRlZmluZWQpdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIixlLG98fHQpfXJldHVybiB0aGlzfTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZj1FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO0V2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhlKXt2YXIgdCxuLHI7bj10aGlzLl9ldmVudHM7aWYobj09PXVuZGVmaW5lZClyZXR1cm4gdGhpcztpZihuLnJlbW92ZUxpc3RlbmVyPT09dW5kZWZpbmVkKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MCl7dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5fZXZlbnRzQ291bnQ9MH1lbHNlIGlmKG5bZV0hPT11bmRlZmluZWQpe2lmKC0tdGhpcy5fZXZlbnRzQ291bnQ9PT0wKXRoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIG5bZV19cmV0dXJuIHRoaXN9aWYoYXJndW1lbnRzLmxlbmd0aD09PTApe3ZhciBpPU9iamVjdC5rZXlzKG4pO3ZhciBzO2ZvcihyPTA7cjxpLmxlbmd0aDsrK3Ipe3M9aVtyXTtpZihzPT09XCJyZW1vdmVMaXN0ZW5lclwiKWNvbnRpbnVlO3RoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKHMpfXRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIik7dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5fZXZlbnRzQ291bnQ9MDtyZXR1cm4gdGhpc310PW5bZV07aWYodHlwZW9mIHQ9PT1cImZ1bmN0aW9uXCIpe3RoaXMucmVtb3ZlTGlzdGVuZXIoZSx0KX1lbHNlIGlmKHQhPT11bmRlZmluZWQpe2ZvcihyPXQubGVuZ3RoLTE7cj49MDtyLS0pe3RoaXMucmVtb3ZlTGlzdGVuZXIoZSx0W3JdKX19cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIF9saXN0ZW5lcnMoZSx0LG4pe3ZhciByPWUuX2V2ZW50cztpZihyPT09dW5kZWZpbmVkKXJldHVybltdO3ZhciBpPXJbdF07aWYoaT09PXVuZGVmaW5lZClyZXR1cm5bXTtpZih0eXBlb2YgaT09PVwiZnVuY3Rpb25cIilyZXR1cm4gbj9baS5saXN0ZW5lcnx8aV06W2ldO3JldHVybiBuP3Vud3JhcExpc3RlbmVycyhpKTphcnJheUNsb25lKGksaS5sZW5ndGgpfUV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uIGxpc3RlbmVycyhlKXtyZXR1cm4gX2xpc3RlbmVycyh0aGlzLGUsdHJ1ZSl9O0V2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzPWZ1bmN0aW9uIHJhd0xpc3RlbmVycyhlKXtyZXR1cm4gX2xpc3RlbmVycyh0aGlzLGUsZmFsc2UpfTtFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudD1mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiBlLmxpc3RlbmVyQ291bnQ9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmxpc3RlbmVyQ291bnQodCl9ZWxzZXtyZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGUsdCl9fTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQ9bGlzdGVuZXJDb3VudDtmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGUpe3ZhciB0PXRoaXMuX2V2ZW50cztpZih0IT09dW5kZWZpbmVkKXt2YXIgbj10W2VdO2lmKHR5cGVvZiBuPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gMX1lbHNlIGlmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmxlbmd0aH19cmV0dXJuIDB9RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzPWZ1bmN0aW9uIGV2ZW50TmFtZXMoKXtyZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQ+MD9yKHRoaXMuX2V2ZW50cyk6W119O2Z1bmN0aW9uIGFycmF5Q2xvbmUoZSx0KXt2YXIgbj1uZXcgQXJyYXkodCk7Zm9yKHZhciByPTA7cjx0OysrciluW3JdPWVbcl07cmV0dXJuIG59ZnVuY3Rpb24gc3BsaWNlT25lKGUsdCl7Zm9yKDt0KzE8ZS5sZW5ndGg7dCsrKWVbdF09ZVt0KzFdO2UucG9wKCl9ZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGUpe3ZhciB0PW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pe3Rbbl09ZVtuXS5saXN0ZW5lcnx8ZVtuXX1yZXR1cm4gdH1mdW5jdGlvbiBvbmNlKGUsdCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuLHIpe2Z1bmN0aW9uIGVycm9yTGlzdGVuZXIobil7ZS5yZW1vdmVMaXN0ZW5lcih0LHJlc29sdmVyKTtyKG4pfWZ1bmN0aW9uIHJlc29sdmVyKCl7aWYodHlwZW9mIGUucmVtb3ZlTGlzdGVuZXI9PT1cImZ1bmN0aW9uXCIpe2UucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLGVycm9yTGlzdGVuZXIpfW4oW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKX1ldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZSx0LHJlc29sdmVyLHtvbmNlOnRydWV9KTtpZih0IT09XCJlcnJvclwiKXthZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlLGVycm9yTGlzdGVuZXIse29uY2U6dHJ1ZX0pfX0pKX1mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlLHQsbil7aWYodHlwZW9mIGUub249PT1cImZ1bmN0aW9uXCIpe2V2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlLFwiZXJyb3JcIix0LG4pfX1mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZSx0LG4scil7aWYodHlwZW9mIGUub249PT1cImZ1bmN0aW9uXCIpe2lmKHIub25jZSl7ZS5vbmNlKHQsbil9ZWxzZXtlLm9uKHQsbil9fWVsc2UgaWYodHlwZW9mIGUuYWRkRXZlbnRMaXN0ZW5lcj09PVwiZnVuY3Rpb25cIil7ZS5hZGRFdmVudExpc3RlbmVyKHQsKGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihpKXtpZihyLm9uY2Upe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LHdyYXBMaXN0ZW5lcil9bihpKX0pKX1lbHNle3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIGUpfX19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG4pe3ZhciByPXRbbl07aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHIuZXhwb3J0c312YXIgaT10W25dPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW25dKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W25dfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBuPV9fbmNjd3Bja19yZXF1aXJlX18oODY0KTttb2R1bGUuZXhwb3J0cz1ufSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/events/events.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fjx%2FWORKSPACE%2FPROJECTS%2FCHESS%2Fsrc%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);